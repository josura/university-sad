kernel void vecinit(
	global int * restrict v1,
	int nels)
{
	const int i = get_global_id(0);

	if (i >= nels) return;

	v1[i] = i;
}

kernel void vecsmooth(
	global int * restrict s,
	global const int * restrict v,
	int nels)
{
	const int i = get_global_id(0);

	if (i >= nels) return;

#if 0
	if (nels == 1)
		s[i] = v[1];
	else if (i == 0)
		s[i] = (v[i] + v[i+1])/2;
	else if (i == nels - 1)
		s[i] = (v[i] + v[i-1])/2;
	else
		s[i] = (v[i-1] + v[i] + v[i+1])/3;
#else
	int v1 = 0, v2 = v[i], v3 = 0;
	int c = 1;
	if (i > 0) {
		v1 = v[i-1];
		++c;
	}
	if (i + 1 < nels) {
		v3 = v[i+1];
		++c;
	}
	s[i] = (v1+v2+v3)/c;
#endif
}

kernel void vecsmooth_lmem(
	global int * restrict s,
	global const int * restrict v,
	local volatile int * cache /* dimensionata come get_local_size(0) + 2 */,
	int nels)
{
	const int gi = get_global_id(0);
	const int li = get_local_id(0);

	if (gi >= nels) return;

	int v1 = 0, v2 = v[gi], v3 = 0;
	int c = 1;

	/* caricamento dei dati da gmem a lmem */
	cache[li+1] = v2;
	if (li == 0 && gi > 0)
		cache[0] = v[gi-1];
	if (li == get_local_size(0) - 1 && gi + 1 < nels)
		cache[li+2] = v[gi+1];

	barrier(CLK_LOCAL_MEM_FENCE);

	/* media dei dati leggendoli dalla lmem invece che dalla gmem */
	if (gi > 0) {
		v1 = cache[li];
		++c;
	}
	if (gi + 1 < nels) {
		v3 = cache[li+2];
		++c;
	}
	s[gi] = (v1+v2+v3)/c;
}

kernel void vecsmooth_mio(
	global int * restrict s,
	global const int * restrict v,
	local volatile int * cache /* dimensionata come get_local_size(0)*/,
	int nels)
{
	const int gi = get_global_id(0);
	const int li = get_local_id(0);

	if (gi >= nels) return;

	int v1 = 0, v2 = v[gi], v3 = 0;
	int c = 1;
	if(gi>0 && li==0){
		c++;
		v1=v[gi-1];	
	}
	if(gi<nels-1 && li==get_local_size(0)-1){
		c++;
		v3=v[gi+1];	
	}	/* caricamento dei dati da gmem a lmem */
	cache[li] = v2;
	barrier(CLK_LOCAL_MEM_FENCE);

	/* media dei dati leggendoli dalla lmem invece che dalla gmem */
	if (gi > 0 && li>0) {
		v1 = cache[li-1];
		++c;
	}
	if (gi + 1 < nels && li<get_local_size(0)-1) {
		v3 = cache[li+1];
		++c;
	}
	s[gi] = (v1+v2+v3)/c;
}


kernel void vecsmooth_vect_lmem(
	global int4 * restrict s,
	global const int4 * restrict v,
	local volatile int2 * cache /* dimensionata come get_local_size(0)*/,
	int nquarts)
{
	const int gi = get_global_id(0);
	const int li = get_local_id(0);

	if (gi >= nquarts) return;
	int4 v2=v[gi];
	int4 v1 =(int4)(0,v2.xyz), v3 = (int4)(v2.yzw,0);
	int4 c = (int4)(2,3,3,2) ;
	if(gi>0 && li==0){
		c.x++;
		v1.x=v[gi-1].w;	
	}
	if(gi<nquarts-1 && li==get_local_size(0)-1 ){
		c.w++;
		v3.w=v[gi+1].x;	
	}	/* caricamento dei dati da gmem a lmem */
	cache[li] = (int2)(v2.x,v2.w);

	barrier(CLK_LOCAL_MEM_FENCE);

	/* media dei dati leggendoli dalla lmem invece che dalla gmem */
	if (gi > 0 && li>0) {
		v1.x = cache[li-1].y;
		c.x++;
	}
	if (gi + 1 < nquarts && li<get_local_size(0)-1) {
		v3.w = cache[li+1].x;
		c.w++;
	}
	s[gi] = (v1+v2+v3)/c;
}

kernel void vecsmooth_v4(
	global int4 * restrict s,
	global const int4 * restrict v,
	int nquarts)
{
	const int i = get_global_id(0);

	if (i >= nquarts) return;

	int4 v1 = (int4)(0), v2 = v[i], v3 = (int4)(0);
	int4 c = (int4)(2,3,3,2);

	if (i > 0) {
		v1.s0 = v[i-1].s3;
		c.s0++;
	}
	if (i < nquarts - 1) {
		v3.s3 = v[i+1].s0;
		c.s3++;
	}

	v1.s123 = v2.s012;
	v3.s012 = v2.s123;

	s[i] = (v1+v2+v3)/c;

}
