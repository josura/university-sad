#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article-beamer
\begin_preamble
\usepackage{tikz}
\usepackage{algorithm} 
\usepackage{algpseudocode} 
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language italian
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date true
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style french
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title (Plain Frame)
Reti temporali e applicazioni
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Reti temporali e applicazioni
\end_layout

\end_inset


\end_layout

\begin_layout Subtitle
Algoritmi per il Graph Matching su Reti Temporali
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Algoritmi per il Graph Matching su Reti Temporali
\end_layout

\end_inset


\end_layout

\begin_layout Author
GIORGIO LOCICERO
\begin_inset Argument 1
status open

\begin_layout Plain Layout
GIORGIO LOCICERO
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename unictLogo.png

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center

\size larger
UNIVERSITÀ DEGLI STUDI DI CATANIA
\end_layout

\begin_layout Standard
\noindent
\align center
CORSO DI LAUREA IN INFORMATICA TRIENNALE (L-31)
\end_layout

\begin_layout Standard
\begin_inset VSpace 3cm
\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "30col%"
height "1pt"

\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center

\size large
TESI DI LAUREA
\end_layout

\begin_layout Standard
\align center
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "30col%"
height "1pt"

\end_inset


\end_layout

\begin_layout Standard
Relatore: ALFREDO FERRO
\end_layout

\begin_layout Standard
Correlatore: MICALE GIOVANNI
\end_layout

\begin_layout Standard
\begin_inset VSpace vfill
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "1pt"

\end_inset


\end_layout

\begin_layout Standard
\align center
ANNO ACCADEMICO 2019/2020
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList algorithm

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Abstract
Le tecnologie stanno crescendo in modo molto spedito negli ultimi decenni,
 i legami tra vari oggetti e soggetti sono sempre di più, nuovi legami si
 formano con il passare del tempo in certi istanti temporali precisi, e
 quindi nuove tecnologie servono per studiare questi legami, modellarli
 e riprodurre lo stesso comportamento reale che si vede nelle interazioni
 quotidiane, studiando le strutture più comuni per carpire informazioni
 significative ma celate.
\end_layout

\begin_layout Abstract
In particolare, i grafi temporali riescono a modellare qualsiasi sistema
 in cui ci siano delle interazioni che avvengono in certi tempi (che siano
 quanti temporali o intervalli) e riprodurre gli stessi comportamenti in
 modo formale, quindi sono di grande importanza per capire come funzionano
 le interazioni tra vari agenti (che siano esseri umani, macchine, animali,
 comportamenti emergenti), studiarle nel dettaglio estrapolando informazioni
 rilevanti alle analisi che si vogliono portare, riprodurre le caratteristiche
 di sistemi complessi come reti neurali (per la modellizzazione di reti
 neurali artificiali sulla forma di studi basati su grafi temporali) e reti
 cerebrali molto più interessanti anche per il futuro della digitalizzazione.
\end_layout

\begin_layout Abstract
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section*
Introduzione
\end_layout

\begin_layout Standard
I grafi statici sono di grandissima importanza in molti ambiti, e gli studi
 che li riguardano sono innumerevoli.
 Nonostante la loro indubbia utilità in molte applicazioni, i grafi semplici
 non riescono a modellare molte situazioni e sistemi che sarebbe utile emulare
 e modellare per studi ed analisi, si vedano ad esempio delle reti di social
 network, dove è possibile rappresentare i legami tra i singoli, ma è difficile
 rappresentare altre caratteristiche come l'invio di messaggi tra singoli
 o altre caratteristiche che possono essere molteplici per coppia di nodi/elemen
ti del sistema.
\end_layout

\begin_layout Standard
Le reti temporali permettono l'aggiunta di dettagli e attributi aggiuntivi
 che aumentano la possibilità di rappresentare reti reali, in particolare
 rappresentazione di reti dinamiche ( neurali, internet, infezioni, informazioni
 e passaggio di informazioni tra nodi).
\end_layout

\begin_layout Standard
Come per altri tipi di reti che approssimano situazioni reali e che aggiungono
 dettagli(come multigrafi e grafi multidimensionali), nelle reti temporali
 si cerca di rappresentare la componente temporale della realtà e l’interazione
 intervallare tra varie entità.
\end_layout

\begin_layout Standard
Proprio per rappresentare questo tipo di interazioni sono stati studiati
 ed utilizzati dei grafi complessi che, nel caso sopra citato, sono i multigrafi
 che permettono più archi tra due nodi oppure, nel caso di rappresentazione
 di più tipi di relazioni nella rete da rappresentare, grafi 
\begin_inset Flex Bold
status open

\begin_layout Plain Layout
multilayer
\end_layout

\end_inset

 (nello specifico reti multidimensionali che sono un tipo specifico di multilaye
r) che permettono di rappresentare i diversi tipi di relazioni del sistema
 e nel sistema.
\end_layout

\begin_layout Standard
Una parte importante di molte situazioni reali che non è stata ancora definita
 in modo chiaro è la componente temporale di una rete, che si ritrova molto
 spesso in qualsiasi sistema complesso.
 Con componente temporale si intende la temporalità delle interazioni tra
 gli elementi di una rete, che può essere espressa come intervalli temporali
 oppure come singoli contatti (queste caratteristiche verranno definite
 nello specifico nella sezione 1: 
\begin_inset Flex Bold
status open

\begin_layout Plain Layout
Reti temporali
\end_layout

\end_inset

 dove verranno definite più formalmente, insieme ai problemi logici e di
 implementazione che ne risulteranno), in particolare l'utilizzo dei contatti
 è molto utile ed importante per rappresentare situazioni dove avviene un
 processo di espansione temporale e a stati, infatti i grafi temporali a
 contatti sono molto spesso accompagnati da modelli di Markov e altri modelli
 di transizione di stati, che così riescono a rappresentare e modellare
 delle situazioni che non si potrebbero ottenere con i semplici grafi statici.
 
\end_layout

\begin_layout Standard
La simulazione e modellizzazione di reti reali che hanno una componente
 temporale(che può essere un 
\begin_inset Flex Bold
status open

\begin_layout Plain Layout
timestamp
\end_layout

\end_inset

 o un
\begin_inset Flex Bold
status open

\begin_layout Plain Layout
intervallo temporale
\end_layout

\end_inset

) è di grande importanza in molti ambiti che spaziano qualsiasi oggetto
 di studio:
\end_layout

\begin_layout Itemize
\begin_inset Flex Bold
status open

\begin_layout Plain Layout
Medicina
\end_layout

\end_inset

: nella modellizzazione di reti cerebrali e di interazioni tra parti del
 corpo o interazioni cellulari, come per esempio il metabolismo, oppure
 sintesi di proteine, collegamenti sinaptici ed interazioni microscopiche
 e mesoscopiche cerebrali, molto utili per lo studio neurologico ed intorni.
\end_layout

\begin_layout Itemize
\begin_inset Flex Bold
status open

\begin_layout Plain Layout
Trasporti
\end_layout

\end_inset

: nella modellizzazione del traffico e nella simulazione di strade, utilizzabile
 quindi per il cambiamento di percorsi dinamico in base al tempo, o per
 la costruzione di nuove strutture nel caso certe situazioni lo richiedano.
\end_layout

\begin_layout Itemize
\begin_inset Flex Bold
status open

\begin_layout Plain Layout
Blockchain
\end_layout

\end_inset

: dove i dati vengono concatenati temporalmente quindi la componente temporale
 è utilizzata totalmente per l'implementazione anche per le interazioni
 di condivisione tra gli utenti.
\end_layout

\begin_layout Itemize
\begin_inset Flex Bold
status open

\begin_layout Plain Layout
Social Network
\end_layout

\end_inset

: come già specificato, interazioni tra gli utenti sono identificate anche
 da dei timestamp che, come già accennato, possono essere singoli contatti
 o intervalli temporali, quindi aumentare l'accuratezza di algoritmi che
 utilizzano le interazioni tra gli utenti ed utilizzare i dati a vantaggio
 dell'insieme.
\end_layout

\begin_layout Itemize
\begin_inset Flex Bold
status open

\begin_layout Plain Layout
Sistemi distribuiti
\end_layout

\end_inset

: per studiare la distribuzione ed i collegamenti dei sistemi distribuiti
 in modo da trovare la configurazione ottimale per la massimizzazione delle
 prestazioni.
\end_layout

\begin_layout Itemize
\begin_inset Flex Bold
status open

\begin_layout Plain Layout
Modelli di espansione in generale
\end_layout

\end_inset

: per esempio modelli epidemici e tumorali, oppure lo studio della distribuzione
 di informazione o altri campi dove l'espansione di qualche tipo di informazione
 è portata da eventi ben definiti, come il contatto con altre persone, e
 le interazioni con community e grandi gruppi di persone, con la creazione
 di sottogruppi temporali.
\end_layout

\begin_layout Standard
Nella prima sezione si daranno le definizioni utili per definire i problemi
 che si affronteranno, in particolare si vedrà una semplice descrizione
 dei grafi semplici che poi verrà espansa ai grafi temporali.
\end_layout

\begin_layout Standard
Nella seconda parte viene visto il problema principale che verrà trattato,
 cioè il 
\begin_inset Flex Bold
status open

\begin_layout Plain Layout
matching di grafi
\end_layout

\end_inset

 espanso con la 
\begin_inset Flex Bold
status open

\begin_layout Plain Layout
componente temporale
\end_layout

\end_inset

, e verranno presentate le componenti importanti per la risoluzione del
 problema, già accennate nel primo capitolo.
\end_layout

\begin_layout Standard
Verranno infine presentati gli algoritmi che sono stati utilizzati per il
 matching ed il calcolo degli isomorfismi, che verranno descritti e visti
 nel dettaglio in seguito.
\end_layout

\begin_layout Standard
Si vedranno inoltre le conseguenze dell'aggiunta della componente temporale,
 che può risultare semplice ad una prima occhiata, ma nasconde una 
\begin_inset Flex Bold
status open

\begin_layout Plain Layout
complessità
\end_layout

\end_inset

 tipica delle rappresentazioni reali che cercano di incorporare la componente
 temporale e componenti non finite e non prevedibili nella costruzione.
\end_layout

\begin_layout Standard
Infatti costruzione e analisi di una rete temporale sono pratiche che coinvolgon
o diverse discipline, una analisi topologica semplice potrebbe non essere
 abbastanza dato che le informazioni temporali verrebbero perse completamente.
\end_layout

\begin_layout Standard
Da un altro punto di vista, l'analisi pura della componente temporale porta
 alla perdita di informazioni molto importanti di struttura statica che
 potrebbero essere fondamentali (questa contrapposizione di tecniche di
 analisi verrà vista in seguito quando si parlerà delle varie tecniche utilizzab
ili per l'analisi di un grafo temporale).
\end_layout

\begin_layout Standard
Di fondamentale importanza per le reti temporali è la parte della teoria
 che studia i processi e le dinamiche di espansione e propagazione(spreading)
 di fenomeni, modelli compartimentale come suddivisione in stati caratteristici,
 rappresentati dai nodi della rete temporale, cioè ogni nodo appartiene
 ad un compartimento.
\end_layout

\begin_layout Standard
Per esempio nel modello di espansione 
\begin_inset Flex Bold
status open

\begin_layout Plain Layout
SIR
\end_layout

\end_inset

 (
\begin_inset Flex Bold
status open

\begin_layout Plain Layout
susceptible infected recovered
\end_layout

\end_inset

) o 
\begin_inset Flex Bold
status open

\begin_layout Plain Layout
SIS
\end_layout

\end_inset

 (dove si ritorna suscettibili dopo l'infezione)un nodo può appartenere
 a tre compartimenti differenti, suscettibile, infetto e recovered(guarito),
 i passaggi da un compartimento ad un altro avvengono tramite funzioni che
 tengono conto del tempo di contatto tra i vari compartimenti.
\end_layout

\begin_layout Standard
Altri modelli più complicati hanno più compartimenti e modellano ancora
 più dettagliatamente la realtà di situazioni di espansione epidemica.
\end_layout

\begin_layout Standard
La probabilità di infezione e di guarigione(
\begin_inset Flex Bold
status open

\begin_layout Plain Layout
infection rate
\end_layout

\end_inset

 e 
\begin_inset Flex Bold
status open

\begin_layout Plain Layout
recovery rate
\end_layout

\end_inset

) sono importanti parametri per il modello.
 Applicare questo modello significa supporre che tutte le interazioni avvengano
 uniformemente nel tempo, cosa che non è vera la maggior parte delle volte.
 Per esempio l'infezione di un virus avviene anche in base al tempo di contatto
 con l'infetto, stesso discorso può essere fatto sul passaggio da infetto
 a guarito.
\end_layout

\begin_layout Standard
Vaccinazioni diminuiscono la probabilità di essere infettati, possiamo introdurr
e modelli di strategie di vaccinazione e di prevenzione.
 Questo modello, come tutti i modelli che si rifanno a situazioni reali,
 assume durante le varie interazioni e passaggi di compartimento un comportament
o 
\begin_inset Flex Bold
status open

\begin_layout Plain Layout
bursty
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Questo genere di 
\begin_inset Flex Bold
status open

\begin_layout Plain Layout
modelli epidemici
\end_layout

\end_inset

 e di 
\begin_inset Flex Bold
status open

\begin_layout Plain Layout
espansione
\end_layout

\end_inset

 in generale è diventato molto di moda in questo periodo specialmente per
 l'emergenza SARS-CoV-2, quindi di grande rilevanza sia per la modellizzazione
 di soluzioni, sia per l'analisi stessa delle dinamiche di espansione.
\end_layout

\begin_layout Standard
Durante questo studio non verranno trattati nello specifico modelli epidemici,
 anche se verranno aperte delle piccole parentesi riguardanti qualsiasi
 modello di espansione.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Reti temporali
\end_layout

\begin_layout Standard
Di seguito verranno presentate le reti temporali iniziando prima con la
 definizione di grafi semplici per poi aggiungere la componente temporale.
\end_layout

\begin_layout Standard
Un concetto essenziale da capire inizialmente è che ogni link (arco) di
 una rete temporale 
\begin_inset Flex Bold
status open

\begin_layout Plain Layout
trasmette-trasporta informazioni
\end_layout

\end_inset

 solo durante il tempo in cui è attivo, questo 
\begin_inset Flex Bold
status open

\begin_layout Plain Layout
tempo di attivazione
\end_layout

\end_inset

 può essere descritto da un 
\begin_inset Flex Bold
status open

\begin_layout Plain Layout
quanto stabilito
\end_layout

\end_inset

(quindi la rete in un tempo stabilito può essere vista come uno stato) o
 da un 
\begin_inset Flex Bold
status open

\begin_layout Plain Layout
intervallo di tempo
\end_layout

\end_inset

 in cui può avvenire il contatto adottando un approccio reale.
\end_layout

\begin_layout Standard
Si usano quanti di tempo ben definiti quando, più che un approccio temporale
 puro, si deve studiare-rappresentare un 
\begin_inset Flex Bold
status open

\begin_layout Plain Layout
approccio a stati
\end_layout

\end_inset

 con passaggio da stato a stato in tempi ben definiti ( unici).
 Si usano intervalli di tempo in quasi tutte le situazioni che coinvolgono
 interazioni reali .
\end_layout

\begin_layout Standard
Solitamente si studiano reti reali basate su intervalli, ma le reti dinamiche
 basate su contatti sono più semplici da utilizzare ed analizzare, anche
 grazie alla immensa letteratura che riguarda le reti statiche, che sono
 abbastanza adattabili ad alcuni approcci utilizzati nell'analisi di reti
 dinamiche.
 Durante questo studio, verranno utilizzate delle reti temporali a contatti
 singoli(solo un tempo per arco), perché l'implementazione è risultata abbastanz
a ostica per reti temporali a più contatti per arco e per reti temporali
 ad intervalli, ma i ragionamenti che vengono fatti in tutti i capitoli
 sono assolutamente generali per tutti i tipi di reti temporali, solo l'implemen
tazione e gli algoritmi utilizzati cambiano.
\end_layout

\begin_layout Standard
Non verranno trattati nel dettaglio algoritmi specifici per funzionalità
 poco comuni ma verranno visti algoritmi di utilità generale che serviranno
 poi anche per gli isomorfismi tra grafi temporali.
\end_layout

\begin_layout Standard
Altre definizioni formali specifiche per il graph isomorphism verranno viste
 in seguito e solo accennate, quindi verranno visti i componenti delle reti
 temporali utili al fine ultimo del calcolo degli isomorfismi.
\end_layout

\begin_layout Standard
Molte definizioni utili per altri problemi sono state tralasciate anche
 perché di poca rilevanza per il problema del graph matching che utilizza
 misure di ottimalità locale per la ricerca della soluzione globale, e molte
 delle misure descritte in 
\begin_inset CommandInset citation
LatexCommand cite
key "holme2019temporal"
literal "false"

\end_inset

 utilizzano misure globali o che utilizzano una buona parte del grafico
 e che, alla fine, non hanno trovato utilità per il problema di graph matching,
 quindi fare riferimento a quel testo per altre possibilità.
\end_layout

\begin_layout Standard
Molte delle definizioni inoltre sono state create per aiutare la definizione
 di graph matching per reti temporali, per esempio la definizione di 
\begin_inset Flex Emphasize
status open

\begin_layout Plain Layout
propagazione
\end_layout

\end_inset

 con la classificazione è stata creata per descrivere la struttura temporale
 di un nodo del grafo, e questa struttura temporale è stata utilizzata per
 descrivere il problema globale di graph matching, che altri autori hanno
 affidato alla definizione di time-respecting-path.
\end_layout

\begin_layout Standard
Si considerano singoli contatti o singoli intervalli per arco, ma durante
 le definizioni ci saranno delle piccole parentesi per espandere i concetti
 a più contatti o più intervalli per singoli archi.
\end_layout

\begin_layout Standard
Sulla definizione di temporal graph matching si vedranno le varie definizioni
 date dai vari autori
\begin_inset CommandInset citation
LatexCommand cite
key "paranjape2017motifs,redmond2016subgraph,Kovanen_2011"
literal "false"

\end_inset

 con le conseguenti problematiche che si presentano e la poca generalità
 di alcune.
\end_layout

\begin_layout Standard
Verranno inoltre visti i problemi che affiorano dall'utilizzo delle reti
 temporali a contatti e ad intervalli, con delle conseguenti scelte e tradeoff.
\end_layout

\begin_layout Standard
Una parentesi importante sarà data da caratteristiche interessanti delle
 reti temporali, per esempio la distribuzione dei contatti o il comportamento
 di certe reti reali, che influenzeranno la costruzione dei modelli e del
 problema di temporal graph matching andando a delineare i contorni delle
 varie applicazioni delle reti temporali con delle soluzioni ai problemi
 che riescano a racchiudere la maggior parte dei problemi più rilevanti.
\end_layout

\begin_layout Standard
Per vedere altre caratteristiche importanti dei grafi temporali (come relazioni
 ed eventi uno a uno, molti a molti, uno a molti, oppure se i contatti avvengono
 in modo sincrono o asincrono, o quali strategie utilizzare nel caso in
 cui non si voglia lavorare direttamente sulla rete temporale ma su surrogati
 che perdono alcune caratteristiche o temporali o topologiche) leggere attentame
nte 
\begin_inset CommandInset citation
LatexCommand cite
key "holme2019temporal"
literal "false"

\end_inset

 dato che è il testo più aggiornato e che racchiude molta intuizione utile
 per la definizione dei singoli problemi.
\end_layout

\begin_layout Standard
Vengono considerati grafi temporali direzionati dove gli archi hanno una
 sola direzione, ma i risultati possono essere espansi a grafi indirezionati
 molto semplicemente.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
Durante tutto il percorso di definizioni e problemi verrà utilizzata la
 seguente rete temporale a contatti:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
usetikzlibrary{arrows.meta}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}     
\end_layout

\begin_layout Plain Layout

	
\backslash
node[shape=circle,draw=black] (0) at (0,0) {0};     
\end_layout

\begin_layout Plain Layout

	
\backslash
node[shape=circle,draw=black] (1) at (0,3) {1};     
\end_layout

\begin_layout Plain Layout

	
\backslash
node[shape=circle,draw=black] (2) at (2.5,4) {2};     
\end_layout

\begin_layout Plain Layout

	
\backslash
node[shape=circle,draw=black] (3) at (2.5,1) {3};     
\end_layout

\begin_layout Plain Layout

	
\backslash
node[shape=circle,draw=black] (4) at (2.5,-3) {4};     
\end_layout

\begin_layout Plain Layout

	
\backslash
node[shape=circle,draw=black] (5) at (5,0) {5} ;
\end_layout

\begin_layout Plain Layout

	
\backslash
node[shape=circle,draw=black] (6) at (6,4) {6} ;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout


\backslash
begin{scope}[>={Stealth[black]},
\end_layout

\begin_layout Plain Layout

			  every node/.style={fill=white,circle},
\end_layout

\begin_layout Plain Layout

              every edge/.style={draw=black,very thick}]
\end_layout

\begin_layout Plain Layout

    
\backslash
path [->] (0) edge node {$1$} (1);     
\end_layout

\begin_layout Plain Layout

	
\backslash
path [->](1) edge node {$3$} (2);     
\end_layout

\begin_layout Plain Layout

	
\backslash
path [->](0) edge node {$4$} (3);     
\end_layout

\begin_layout Plain Layout

	
\backslash
path [->](3) edge node {$3$} (2);
\end_layout

\begin_layout Plain Layout

    
\backslash
path [->](0) edge node {$3$} (4);
\end_layout

\begin_layout Plain Layout

    
\backslash
path [->](3) edge node {$3$} (4);
\end_layout

\begin_layout Plain Layout

    
\backslash
path [->](3) edge node {$33$} (5);
\end_layout

\begin_layout Plain Layout

    
\backslash
path [->](2) edge node {$42$} (5);
\end_layout

\begin_layout Plain Layout

    
\backslash
path [->](4) edge node {$8$} (5); 
\end_layout

\begin_layout Plain Layout

    
\backslash
path [->](6) edge node {$14$} (5); 
\end_layout

\begin_layout Plain Layout

    
\backslash
path [->](6) edge node {$8$} (2); 
\end_layout

\begin_layout Plain Layout


\backslash
end{scope}  
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Definizioni formali
\end_layout

\begin_layout Standard
Prima di tutto si dà una definizione di grafo statico ed altre definizioni
 basilari per introdurre i concetti di base che verranno in seguito espansi:
\end_layout

\begin_layout Definition
(Grafo statico).
 Si dice Grafo Statico 
\begin_inset Formula $G$
\end_inset

 una coppia ordinata 
\begin_inset Formula $(V,E)$
\end_inset

 di insiemi, dove l'insieme 
\begin_inset Formula $V$
\end_inset

è l'insieme dei nodi ed 
\begin_inset Formula $E\subseteq V^{2}$
\end_inset

 è l'insieme degli archi tra due nodi .
\end_layout

\begin_deeper
\begin_layout Standard
Questa definizione è la più basilare che si può avere, non contiene elementi
 complessi come attributi multipli per arco, pesi degli archi, etichette
 associate ai nodi o possibilità di archi di diverso tipo tra gli stessi
 due nodi.
\end_layout

\end_deeper
\begin_layout Definition
Per espandere questa definizione con componenti aggiuntive come la componente
 temporale oppure il tipo di ogni arco e la possibilità di vari attributi
 si possono aggiungere queste caratteristiche direttamente negli archi tra
 i vari nodi.
 assegnando ad ogni arco componenti aggiuntive come liste o insiemi, oppure
 mantenendo delle strutture esterne che associano ad elementi del grafo
 statico caratteristiche aggiuntive.
 Nel caso di multigrafi l'insieme degli archi diventa un multiinsieme.
\end_layout

\begin_layout Definition
A fine sezione si vedrà come l'aggiunta della componente temporale aggiunga
 una complessità notevole a tutti i problemi collegati ai grafi.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Comment
status open

\begin_layout Plain Layout
(Arco orientato).
 Un arco viene identificato con la coppia formata dai suoi estremi 
\begin_inset Formula $(u,v)$
\end_inset

, un arco è diretto se 
\begin_inset Formula $(u,v)\notin E\nRightarrow(v,u)\notin E$
\end_inset

, indiretto altrimenti.
 
\end_layout

\end_inset


\end_layout

\begin_layout Definition
(Grafo diretto e indiretto).
 Se 
\begin_inset Formula $E$
\end_inset

 è una relazione simmetrica allora si dice che il grafo è non orientato
 (o indiretto), altrimenti si dice che è orientato (o diretto).
\end_layout

\begin_deeper
\begin_layout Standard
Nel caso di grafo statico, il concetto di direzione è opzionale, ma molto
 spesso nei grafi temporali la direzione è mandatoria, anche perché per
 i cammini Time-Respecting non valgono le proprietà transitiva e simmetrica,
 quindi i cammini possono essere visti come unidirezionali.
\end_layout

\end_deeper
\begin_layout Standard
Di seguito verranno date delle definizioni di base per l'introduzione dei
 concetti che servono per la descrizione dei sistemi temporali, quindi si
 parte con la definizione di contatto temporale per poi finire con la definizion
e di struttura temporale, che verrà usata totalmente durante la definizione
 del problema di temporal graph matching.
\end_layout

\begin_layout Definition
(Contatto temporale).
 Un contatto è una tripla 
\begin_inset Formula $(source,destination,time)\in V^{2}\times\mathbb{R}$
\end_inset

 che definisce una interazione tra un nodo sorgente ed un nodo destinazione
 in un un certo attimo temporale.
\end_layout

\begin_deeper
\begin_layout Standard
Questa definizione di contatto temporale esprime un singolo momento in cui
 l'evento può accadere, nel caso di intervalli si parla di 
\begin_inset Flex Emphasize
status open

\begin_layout Plain Layout
intervallo di contatto
\end_layout

\end_inset

, anche se solitamente il momento in cui avviene la propagazione è comunque
 un singolo momento, ma dipende comunque dalle esigenze e dalle descrizioni
 singole dei problemi che si stanno tentando di simulare o risolvere.
\end_layout

\end_deeper
\begin_layout Standard
Nonostante si possa definire un grafo temporale senza l'aiuto della definizione
 di contatti, la medesima è molto utile durante molte definizioni formali
 e nella descrizione dei vari algoritmi (che utilizzano infatti il concetto
 di contatto attivamente).
\end_layout

\begin_layout Definition
(Grafo temporale per contatti).
 Si dice Grafo Temporale per contatti 
\begin_inset Formula $G_{T}$
\end_inset

 una coppia ordinata 
\begin_inset Formula $(V,E)$
\end_inset

 di insiemi, dove l'insieme 
\begin_inset Formula $V$
\end_inset

è l'insieme dei nodi (che è possibile identificare tramite funzioni aggiuntive
 che associano ad ogni nodo un id univoco) ed 
\begin_inset Formula $E\subseteq V^{2}\times\mathbb{R}$
\end_inset

 è l'insieme degli archi tra due nodi dove la componente temporale è un
 singolo numero che esprime il momento del contatto .
\end_layout

\begin_deeper
\begin_layout Standard
Ad un grafo temporale possono essere associate altre componenti, dipendenti
 dalle strutture sia topologica che temporale, per esempio si può associare
 la struttura statica come infrastruttura ed utilizzare delle misure e metriche
 derivate dalle componenti temporali per descrivere il grafo temporale tramite
 caratteristiche globali e locali.
\end_layout

\end_deeper
\begin_layout Definition
Nel caso di più contatti per nodo, questi possono essere visti come singole
 associazioni per il singolo arco oppure come archi a se stanti.
\end_layout

\begin_layout Definition
Tra le caratteristiche locali che serviranno in seguito per la definizione
 di Matching su reti temporali verrà visto il concetto di 
\begin_inset Flex Emphasize
status open

\begin_layout Plain Layout
propagazione
\end_layout

\end_inset

 e 
\begin_inset Flex Emphasize
status open

\begin_layout Plain Layout
struttura temporale
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Definition
(Grafo temporale per intervalli di contatto).
 Si dice Grafo Temporale per contatti 
\begin_inset Formula $G_{T}$
\end_inset

 una coppia ordinata 
\begin_inset Formula $(V,E)$
\end_inset

 di insiemi, dove l'insieme 
\begin_inset Formula $V$
\end_inset

è l'insieme dei nodi ed 
\begin_inset Formula $E\subseteq V^{2}\times\mathbb{I}|\forall e\in E;a,b\in\mathbb{R},a\leq b,e.interval=[a,b]\subseteq\mathbb{R}$
\end_inset

 è l'insieme degli archi tra due nodi dove la componente temporale è un
 intervallo identificato da due numeri reali che sono gli estremi che esprime
 il tempo in cui l'arco era attivo per mandare informazione .
\end_layout

\begin_deeper
\begin_layout Standard
Durante l'attivazione di un arco nell'intervallo di tempo specificato l'informaz
ione si propaga di nodo in nodo, quindi può passare da un nodo all'altro
 solo durante gli intervalli di tempo stabiliti, non prima e non dopo.
\end_layout

\end_deeper
\begin_layout Definition
Stesso discorso per più intervalli per nodo, che possono essere visti e
 definiti come associati al singolo arco oppure indipendenti l'uno dal l'altro.
\end_layout

\begin_layout Definition
È importante specificare questo concetto anche perché nel caso di contatti
 si aveva il 
\begin_inset Formula $\delta$
\end_inset

 aggiuntivo rispetto ai singoli contatti che permetteva la trasmissione
 tra un nodo ed un altro solo se venivano rispettati i vincoli temporali.
\end_layout

\begin_layout Definition
Per il caso di Grafo Temporale ad intervalli vale più o meno lo stesso ragioname
nto, anche se la complessità aumenta considerevolmente in tecnicismi abbastanza
 poco rilevanti nel caso di contatti, ma che assumono grande importanza
 nel caso di definizione di intervalli di propagazione che verranno visti
 in seguito.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Definition
(Cammino Time-respecting).
 Si dice cammino time respecting una sequenza di contatti con tempi non-decresce
nti, più formalmente : 
\end_layout

\begin_layout Definition
Data una sequenza di archi 
\begin_inset Formula $\{e_{1},\ldots,e_{n}\}$
\end_inset

, questa sequenza forma un time-respecting path se e solo se 
\begin_inset Formula $r\in[1,n[\subseteq\mathbb{N},e_{r}=(s_{r},d_{r},t_{r})\in E_{G},d_{r}=s_{r+1},t_{r}<t_{r+1}$
\end_inset

Cioè un cammino time-respecting deve avere delle interazioni tra i vari
 nodi che rispettino il normale scorrere del tempo.
\end_layout

\begin_deeper
\begin_layout Standard
Nel caso di contatti multipli per singolo arco, questa definizione non cambia.
\end_layout

\end_deeper
\begin_layout Definition
Un discorso diverso deve essere fatto nel caso di intervalli di contatto,
 che complicano leggermente la definizione dato che gli intervalli si portano
 dietro il minimo delle intersezioni tra gli intervalli dell'arco entrante
 e dell'arco uscente.
\end_layout

\begin_layout Definition
La definizione è comunque dipendente dalle condizioni singolari di ogni
 caso, quindi non si daranno definizioni aggiuntive, ma verranno accennate
 le intuizioni utili per la definizione di problemi in caso di Grafo Temporale
 ad intervalli.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Definition
(Connessione tra due nodi 
\begin_inset Formula $i,j$
\end_inset

).
 Si dice che due nodi siano connessi se esiste un cammino Time-Respecting
 tra i due nodi
\end_layout

\begin_deeper
\begin_layout Standard
Questa definizione definisce la connessione tra i due nodi come l'esistenza
 di un cammino che colleghi questi due che rispetta l'ordinamento temporale.
\end_layout

\end_deeper
\begin_layout Standard
Si può notare come se due nodi 
\begin_inset Formula $(i,j)$
\end_inset

 sono connessi tra di loro e 
\begin_inset Formula $(j,t)$
\end_inset

 anche, non è detto che esista un cammino Time-Respecting tra 
\begin_inset Formula $i$
\end_inset

 e 
\begin_inset Formula $t$
\end_inset

, quindi non vale la proprietà transitiva
\end_layout

\begin_layout Standard
Un altro fattore importante da notare è il fatto che anche le connessioni
 sono temporali, in quanto se due nodi sono connessi ad un tempo definito,
 non è detto che lo siano all'istante successivo, quindi bisogna riportare
 anche degli attributi temporali per la connessione per non perdere tempo.
\end_layout

\begin_layout Standard
Un altro grafo importante che è possibile ricavare dalle connessioni è il
 reachability graph.
 In un reachability graph un nodo ha un arco orientato verso un altro nodo
 se e solo se è il primo è connesso con il secondo.
 Ovviamente l'arco è orientato perché un cammino da un nodo 
\begin_inset Formula $a$
\end_inset

 ad un nodo 
\begin_inset Formula $b$
\end_inset

 che è Time-Respecting non può essere utilizzato all'inverso dato che i
 tempi di contatto saranno tutti decrescenti.
 
\end_layout

\begin_layout Standard
Durante i prossimi capitoli e la sezione in cui vengono visitate le varie
 possibilità di graph matching vengono viste altre possibilità di rappresentazio
ne di Grafi Temporali che semplificano o arricchiscono il modello da analizzare.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Definition
(Propagazione tra due nodi 
\begin_inset Formula $(i,j)$
\end_inset

 attraverso un nodo 
\begin_inset Formula $t$
\end_inset

).
 Si dice propagazione 
\begin_inset Formula $p_{itj}\in E\times E$
\end_inset

 come la coppia ordinata di archi 
\begin_inset Formula $(e_{r},e_{s}),e_{r},e_{s}\in E|e_{r}.destination=e_{s}.source$
\end_inset

 
\end_layout

\begin_deeper
\begin_layout Standard
Ad una propagazione vengono associati altre caratteristiche come il nodo
 centrale di propagazione (nel caso di 
\begin_inset Formula $p_{itj}$
\end_inset

 ,
\begin_inset Formula $p_{itj}.node=t$
\end_inset

), latenza di propagazione (che si vedrà nella prossima definizione) e,
 nel caso di intervalli temporali, l'intervallo di propagazione che viene
 ottenuto nel seguente modo:
\end_layout

\end_deeper
\begin_layout Definition

\end_layout

\begin_layout Definition
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
scriptsize
\end_layout

\begin_layout Plain Layout


\backslash
begin{equation}
\end_layout

\begin_layout Plain Layout

p_{itj}.intersect = p_{itj}.e_{s}.interval 
\backslash
cap p_{itj}.e_{r}.interval
\end_layout

\begin_layout Plain Layout


\backslash
end{equation}
\end_layout

\begin_layout Plain Layout


\backslash
begin{equation}
\end_layout

\begin_layout Plain Layout

p_{itj}.propInterval = 
\backslash
begin{cases} 
\end_layout

\begin_layout Plain Layout

	[min(p_{itj}.intersect),max(p_{itj}.e_{s}.interval)] 
\backslash
indent 
\backslash
text{if } p_{itj}.intersect 
\backslash
ne 
\backslash
emptyset 
\end_layout

\begin_layout Plain Layout


\backslash

\backslash
 
\end_layout

\begin_layout Plain Layout

	
\backslash
emptyset 
\backslash
indent 
\backslash
text{if } 
\end_layout

\begin_layout Plain Layout

		p_{itj}.intersect = 
\backslash
emptyset
\end_layout

\begin_layout Plain Layout


\backslash
end{cases}
\end_layout

\begin_layout Plain Layout


\backslash
end{equation}
\end_layout

\begin_layout Plain Layout


\backslash
normalsize
\end_layout

\end_inset


\end_layout

\begin_layout Definition

\end_layout

\begin_layout Definition
Si può notare come nel caso di contatti il primo tempo è sempre quello dell'arco
 uscente, e l'ultimo tempo dell'intervallo viene dato dal 
\begin_inset Formula $\delta$
\end_inset

 definito, anche se il fine ultimo è abbastanza differente ed alcune risultati
 non coinciderebbero effettivamente.
\end_layout

\begin_layout Standard
Nel caso di contatti multipli, si deve fare una distinzione aggiuntiva delle
 propagazioni con gli stessi archi entranti ed uscenti, se si considerano
 i contatti (o gli intervalli) singoli come archi a sé stanti, cioè triple,
 la distinzione è automatica, ma la notazione deve essere cambiata leggermente
 (mettendo in apice i tempi di contatto entrante ed uscente), oppure definendo
 degli insiemi di propagazioni per un arco entrante ed uno uscente per ogni
 combinazione di contatti-intervalli.
\end_layout

\begin_layout Standard
Per esempio, la notazione dovrebbe essere cambiata in 
\begin_inset Formula $p_{itj}^{t_{1}t_{2}}$
\end_inset

 per esprimere una propagazione formata dai due archi che hanno tempi multipli,
 e quindi devono essere individuati univocamente, mettendo in apice i tempi.
 Oppure la notazione può rimanere la stessa, ma una propagazione non sarebbe
 più la coppia ordinata 
\begin_inset Formula $(e_{r},e_{s}),e_{r},e_{s}\in E|e_{r}.destination=e_{s}.source$
\end_inset

 ma l'insieme delle coppie ordinate 
\begin_inset Formula $\{(e_{r},e_{s}),e_{r},e_{s}\in E|e_{r}.destination=e_{s}.source\}$
\end_inset

 dove possono esistere propagazioni con stessi archi entranti ed uscenti,
 ma con tempi-intervalli differenti.
\end_layout

\begin_layout Standard
Il caso di contatti-intervalli multipli verrà rivisitato più volte in seguito
 anche perché rappresenta la generalizzazione del problema per eccellenza,
 oltre a portare con se delle tecnicità notevoli sia in fattore logico-deduttivo
, sia nelle performance degli algoritmi che si vedranno, che dovranno confrontar
e una quantità fattorialmente maggiore (per le combinazioni ottenibili tra
 i vari contatti di ogni arco).
 
\end_layout

\begin_layout Definition
(Latenza di propagazione per contatti).
 Ad ogni propagazione viene associato un numero che rappresenta l'intervallo
 temporale tra il tempo di contatto dell'arco entrante e quello dell'arco
 uscente, più formalmente:
\end_layout

\begin_layout Definition
Data 
\begin_inset Formula $p_{itj}$
\end_inset

, si dice latenza 
\begin_inset Formula $\Delta(p_{itj})=p_{itj}.e_{s}.time-p_{itj}.e_{r}.time$
\end_inset

, per limitare la ridondanza la latenza verrà direttamente associata ad
 ogni propagazione come attributo.
\end_layout

\begin_deeper
\begin_layout Standard
Il concetto di latenza si può ampliare anche per altre vie per esempio definendo
 una 
\begin_inset Flex Emphasize
status open

\begin_layout Plain Layout
information latency
\end_layout

\end_inset

 come l'intervallo di tempo tra la trasmissione di una informazione da un
 nodo ed il suo arrivo ad un altro nodo, ma questa definizione non ci serve
 per il problema che verrà trattato in seguito sul matching dato che questo
 tipo di informazione è globale ed ha pochi risvolti nella risoluzione del
 matching.
 Per approfondimenti riguardanti altre misure utilizzabili per la creazione
 dei modelli guardare 
\begin_inset CommandInset citation
LatexCommand cite
key "holme2019temporal"
literal "false"

\end_inset

.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Definition
(Insieme delle propagazioni 
\begin_inset Formula $P_{t}$
\end_inset

di un nodo 
\begin_inset Formula $t$
\end_inset

).
 Si definisce l'insieme di tutte le propagazioni di un nodo l'insieme formato
 da tutte le propagazioni che passano dal nodo 
\begin_inset Formula $t$
\end_inset

, più formalmente 
\begin_inset Formula $P_{t}=\{p_{iqj}|p_{iqj}.node=t\}$
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Questa definizione stabilisce una buona base da dove derivare altre definizioni
 significative per molti problemi, ma include effettivamente soltanto grafi
 per contatti ed intervalli singoli per ogni arco.
\end_layout

\end_deeper
\begin_layout Definition
Nel caso di contatti o intervalli molteplici per arco, bisogna effettivamente
 scegliere due strade intuibili già accennate precedentemente, cioè considerare
 i contatti come archi indipendenti oppure appartenenti ad un insieme associato
 all'arco.
\end_layout

\begin_layout Definition
Nel primo caso, la definizione non cambia, e quindi l'insieme sarebbe sostanzial
mente lo stesso con le dovute distinzioni per le propagazioni, che dovranno
 tenere conto dei tempi diversi, quindi utilizzando la notazione già definita
 precedentemente 
\begin_inset Formula $p_{itj}^{t_{1}t_{2}}$
\end_inset

 che tiene conto pure dei tempi di contatto oltre agli archi entranti ed
 uscenti.
\end_layout

\begin_layout Definition
Nel secondo caso si può fare riferimento alla definizione di propagazione
 come insieme di coppie ordinate di archi.
 Quindi costruire la definizione di insieme delle propagazioni come insieme
 di insiemi, ognuno formato dalle combinazioni dei singoli insiemi contenuti
 nella propagazione corrispondente, la seguente definizione formale è abbastanza
 ostica e non saprei descrivere la sua accuratezza.
\end_layout

\begin_layout Definition
Sia 
\begin_inset Formula $prop_{a_{i}tb_{i}}[i]$
\end_inset

 l'i-esima propagazione (come insieme di coppie ordinate) associata al nodo
 t e aventi sorgente e destinazione 
\begin_inset Formula $a_{i}$
\end_inset

 e 
\begin_inset Formula $b_{i}$
\end_inset

rispettivamente, con 
\begin_inset Formula $i\in\mathbb{N}|0<i<inDeg(t)*outDeg(t)$
\end_inset

,
\end_layout

\begin_layout Definition
allora 
\begin_inset Formula $P_{t}=\{\{(a_{1},a_{2}),(a_{3},a_{4}),...(a_{Deg(t)*2-1},a_{Deg(t)*2})|$
\end_inset


\end_layout

\begin_layout Definition
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{math}
\end_layout

\begin_layout Plain Layout

$
\backslash
indent$
\end_layout

\begin_layout Plain Layout


\backslash
end{math}
\end_layout

\end_inset


\begin_inset Formula $(a_{1},a_{2})\in prop_{atb}[1]\wedge$
\end_inset


\end_layout

\begin_layout Definition
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{math}
\end_layout

\begin_layout Plain Layout

$
\backslash
indent$
\end_layout

\begin_layout Plain Layout


\backslash
end{math}
\end_layout

\end_inset


\begin_inset Formula $(a_{3},a_{4})\in prop_{atb}[2]\wedge$
\end_inset


\end_layout

\begin_layout Definition
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{math}
\end_layout

\begin_layout Plain Layout

$
\backslash
indent$
\end_layout

\begin_layout Plain Layout


\backslash
end{math}
\end_layout

\end_inset


\begin_inset Formula $...\wedge(a_{inDeg(t)*outDeg(t)-1},a_{inDeg(t)*outDeg(t)*2})\in prop_{atb}[Deg(t)]\}|$
\end_inset


\end_layout

\begin_layout Definition
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{math}
\end_layout

\begin_layout Plain Layout

$
\backslash
indent$
\end_layout

\begin_layout Plain Layout


\backslash
end{math}
\end_layout

\end_inset


\begin_inset Formula $p_{atb}.node=t\}$
\end_inset


\end_layout

\begin_layout Example
(Insieme delle propagazioni in un grafo temporale con contatti multipli
 per arco).
 Dato un grafo temporale 
\begin_inset Formula $G_{t}$
\end_inset

 con i seguenti due insiemi di propagazioni associate ad un nodo :
\end_layout

\begin_layout Example
\begin_inset Formula $p_{123}=\{((1,2,1),(2,3,4)),((1,2,3),(2,3,4))\},p_{428}=\{((4,2,6),(2,8,10)),((4,2,11),(2,8,10))\}$
\end_inset


\end_layout

\begin_layout Example
L'insieme di propagazioni associate al nodo 2 è il seguente:
\end_layout

\begin_layout Example
\begin_inset Formula $P_{2}=\{\{((1,2,1),(2,3,4)),((4,2,6),(2,8,10))\},$
\end_inset


\end_layout

\begin_layout Example
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{math}
\end_layout

\begin_layout Plain Layout

$
\backslash
indent
\backslash
indent$
\end_layout

\begin_layout Plain Layout


\backslash
end{math}
\end_layout

\end_inset


\begin_inset Formula $\{((1,2,1),(2,3,4)),((4,2,11),(2,8,10))\},$
\end_inset


\end_layout

\begin_layout Example
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{math}
\end_layout

\begin_layout Plain Layout

$
\backslash
indent
\backslash
indent$
\end_layout

\begin_layout Plain Layout


\backslash
end{math}
\end_layout

\end_inset


\begin_inset Formula $\{((1,2,3),(2,3,4)),((4,2,6),(2,8,10))\},$
\end_inset


\end_layout

\begin_layout Example
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{math}
\end_layout

\begin_layout Plain Layout

$
\backslash
indent
\backslash
indent$
\end_layout

\begin_layout Plain Layout


\backslash
end{math}
\end_layout

\end_inset


\begin_inset Formula $\{((1,2,3),(2,3,4)),((4,2,11),(2,8,10))\}\}$
\end_inset


\end_layout

\begin_layout Example
Notare come la cardinalità dell'insieme risultante sia 
\begin_inset Formula $|p_{123}|*|p_{428}|=4$
\end_inset

, quindi 4 strutture temporali diverse associate ad un singolo nodo, che
 sono le combinazioni dei contatti dell'arco 
\begin_inset Formula $1\rightarrow2$
\end_inset

 con i possibili tempi di contatto dell'arco 
\begin_inset Formula $4\rightarrow2$
\end_inset

, quindi l'insieme risultante avrà cardinalità uguale a quella del prodotto
 cartesiano degli insiemi delle propagazioni associati al nodo.
\end_layout

\begin_layout Standard
Si definisce l'insieme di tutte le propagazioni appartenenti ad un grafo
 temporale come 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{math} Propagations = 
\backslash
bigcup
\backslash
limits_{i}^{n} P_{i} 
\backslash
end{math}
\end_layout

\end_inset


\end_layout

\begin_layout Definition
(classificazione di una propagazione ).
 Una propagazione 
\begin_inset Formula $p_{itj}$
\end_inset

può essere di due tipi diversi:
\end_layout

\begin_layout Definition
Nel caso di contatti:
\end_layout

\begin_deeper
\begin_layout Enumerate
(propagazione Time-respecting).
 Una propagazione 
\begin_inset Formula $p_{itj}$
\end_inset

 viene detta Time-Respecting se 
\begin_inset Formula $p_{itj}.e_{s}.time>p_{itj}.e_{r}.time$
\end_inset

, a sua volta si divide in altri due sotto tipi:
\end_layout

\begin_deeper
\begin_layout Enumerate
(propagazione 
\begin_inset Formula $\delta$
\end_inset

-time-respecting).
 Una propagazione 
\begin_inset Formula $p_{itj}$
\end_inset

 viene detta 
\begin_inset Formula $\delta$
\end_inset

-Time-Respecting se 
\begin_inset Formula $p_{itj}.e_{s}.time-p_{itj}.e_{r}.time<\delta$
\end_inset


\end_layout

\begin_layout Enumerate
(propagazione non 
\begin_inset Formula $\delta$
\end_inset

-time-respecting).
 Una propagazione 
\begin_inset Formula $p_{itj}$
\end_inset

 viene detta non 
\begin_inset Formula $\delta$
\end_inset

-Time-Respecting se 
\begin_inset Formula $p_{itj}.e_{s}.time-p_{itj}.e_{r}.time\geq\delta$
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
(propagazione non Time-respecting).
 Una propagazione 
\begin_inset Formula $p_{itj}$
\end_inset

viene detta non Time-Respecting se 
\begin_inset Formula $p_{itj}.e_{s}.time\leq p_{itj}.e_{r}.time$
\end_inset


\end_layout

\end_deeper
\begin_layout Definition
Nel caso di intervalli:
\end_layout

\begin_deeper
\begin_layout Enumerate
(propagazione Time-respecting).
 Una propagazione 
\begin_inset Formula $p_{itj}$
\end_inset

 viene detta Time-Respecting se 
\begin_inset Formula $p_{itj}.e_{s}.interval\cap p_{itj}.e_{r}.interval\ne\emptyset$
\end_inset


\end_layout

\begin_layout Enumerate
(propagazione non Time-respecting).
 Una propagazione 
\begin_inset Formula $p_{itj}$
\end_inset

 viene detta non Time-Respecting se 
\begin_inset Formula $p_{itj}.e_{s}.interval\cap p_{itj}.e_{r}.interval=\emptyset$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
Come si può facilmente intuire, il caso di propagazione su intervalli generalizz
a quello su contatti, anche perché la definizione del 
\begin_inset Formula $\delta$
\end_inset

 può essere vista come un intervallo che inizia al tempo stabilito e finisce
 dopo un certo tempo (
\begin_inset Formula $[e_{r}.time,e_{r}.time+\delta[$
\end_inset

), ma in realtà la funzione del 
\begin_inset Formula $\delta$
\end_inset

 è molto spesso differente, quindi si manterrà la distinzione.
\end_layout

\begin_layout Standard
L'insieme delle classi possibili (che possono essere stringhe o enumerazioni)
 di una propagazione è il seguente 
\begin_inset Formula $PropType=\{TimeRespecting,NotTimeRespecting\}$
\end_inset

, eventualmente è possibile associare altre classi come per esempio la classe
 
\begin_inset Formula $deltaTimeRespecting$
\end_inset

 ma comunque dipende dalle esigenze del singolo problema.
\end_layout

\begin_layout Standard
La funzione che associa ad ogni propagazione la sua classe specifica è:
\end_layout

\begin_layout Standard
\begin_inset Formula $classProp:Propagations\rightarrow PropType$
\end_inset


\end_layout

\begin_layout Standard
Secondo la seguente legge:
\end_layout

\begin_layout Standard
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
scriptsize
\end_layout

\begin_layout Plain Layout

(caso contatti)
\end_layout

\begin_layout Plain Layout


\backslash
begin{equation}
\end_layout

\begin_layout Plain Layout

classProp(prop) = 
\backslash
begin{cases} 
\end_layout

\begin_layout Plain Layout

	TimeRespecting 
\backslash
indent 
\backslash
text{if } 0<p_{itj}.e_{s}.time-p_{itj}.e_{r}.time<
\backslash
delta
\end_layout

\begin_layout Plain Layout


\backslash

\backslash
 
\end_layout

\begin_layout Plain Layout

	NotTimeRespecting 
\backslash
indent 
\backslash
text{if } 0<p_{itj}.e_{s}.time-p_{itj}.e_{r}.time
\backslash
geq
\backslash
delta
\end_layout

\begin_layout Plain Layout


\backslash
end{cases}
\end_layout

\begin_layout Plain Layout


\backslash
end{equation}
\end_layout

\begin_layout Plain Layout


\backslash
indent (caso intervalli)
\end_layout

\begin_layout Plain Layout


\backslash
begin{equation}
\end_layout

\begin_layout Plain Layout

classProp(prop) = 
\backslash
begin{cases} 
\end_layout

\begin_layout Plain Layout

	TimeRespecting 
\backslash
indent 
\backslash
text{if } p_{itj}.intersect 
\backslash
ne 
\backslash
emptyset 
\end_layout

\begin_layout Plain Layout


\backslash

\backslash
 
\end_layout

\begin_layout Plain Layout

	NotTimeRespecting 
\backslash
indent 
\backslash
text{if } 
\end_layout

\begin_layout Plain Layout

		p_{itj}.intersect = 
\backslash
emptyset
\end_layout

\begin_layout Plain Layout


\backslash
end{cases}
\end_layout

\begin_layout Plain Layout


\backslash
end{equation}
\end_layout

\begin_layout Plain Layout


\backslash
normalsize
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Come già detto si poteva generalizzare tutto considerando il delta per la
 definizione di intervallo, ma la definizione si è lasciata separata per
 far capire che il 
\begin_inset Formula $\delta$
\end_inset

 è un parametro globale, e anche perché l'intersezione di certi intervalli
 (contatto entrante minore di un contatto uscente, quindi l'intersezione
 tra gli intervalli risultanti sarebbe non nulla, quindi ambigua e contraddittor
ia rispetto alla definizione di contatti e di time-respecting path per contatti)
 risulterebbe in propagazioni Time-Respecting quando non dovrebbero esserlo.
\end_layout

\begin_layout Standard
Nel caso di grafi con più contatti o intervalli per arco, si può utilizzare
 una delle due definizioni date precedentemente, cambiando l'equazione sopra
 descritta considerando ogni singolo elemento della propagazione, e restituendo
 l'insieme delle classi associate, oppure utilizzando sempre la stessa funzione,
 ma andando a lavorare sui singoli elementi della propagazione.
\end_layout

\begin_layout Definition

\end_layout

\begin_layout Definition
Il multiinsieme ordinato formato da tutti i tipi di propagazioni di un nodo
 
\begin_inset Formula $s$
\end_inset

 è chiamato impronta(o carattere) temporale e viene definito nel seguente
 modo:
\end_layout

\begin_layout Definition
\begin_inset Formula $impronta_{s}=(PropType,classProp)$
\end_inset


\end_layout

\begin_layout Definition
\begin_inset Formula $\indent impronta_{s}=\{\forall prop_{s}\in P_{s}|prop{}_{s}^{classProp(prop)}\}$
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Questo multiinsieme è formato dalle classi delle propagazioni del nodo 
\begin_inset Formula $s$
\end_inset

 insieme alle molteplicità dei singoli elementi.
\end_layout

\end_deeper
\begin_layout Definition
Nel caso di intervalli la definizione non cambia dato che le classi sono
 ben definite e si può costruire una impronta univoca del nodo.
\end_layout

\begin_layout Definition
Per più contatti o intervalli per arco la situazione cambia maggiormente,
 ma utilizzando le definizioni di propagazione come insieme di contatti
 o intervalli, è possibile definire l'impronta come un insieme di sottoimpronte,
 associate all'insieme delle propagazioni del nodo (cioè 
\begin_inset Formula $P_{t}$
\end_inset

), quindi costruendo delle sotto-impronte per ogni insieme contenuto in
 
\begin_inset Formula $P_{t}$
\end_inset

.
\end_layout

\begin_layout Definition
In questo modo si può svolgere i confronti che si vedranno in futuro e che
 sono essenziali per il calcolo della similarità senza problemi di ambiguità
 associati al primo approccio nel caso di più contatti, dove le propagazioni
 erano tutte indipendenti, dato che l'impronta risultante in quel caso sarebbe
 stata unica, ma i casi non sarebbero stati scindibili l'uno dall'altro,
 e la struttura temporale effettiva poteva portare a falsi positivi nel
 confronto.
\end_layout

\begin_layout Definition
Questo argomento verrà espanso prossimamente.
\end_layout

\begin_layout Example
\begin_inset Formula $impronta_{3}=\{(TimeRespecting,2),(NotTimeRespecting,1)\}$
\end_inset


\end_layout

\begin_layout Standard
Questo esempio considera il nodo 3 del grafo visto nella sezione 1, vengono
 considerate tutte le propagazioni, e tra di loro 2 risultano Time-Respecting
 ed 1 non Time-Respecting
\end_layout

\begin_layout Example
(impronta nel caso di più contatti per arco).
 Prendendo l'esempio già discusso durante la definizione di insieme di propagazi
oni per più contatti associati ad un arco, l'impronta risultante sarà la
 seguente:
\end_layout

\begin_layout Example
\begin_inset Formula $impronta_{2}=\{(\{(TimeRespecting,2),(NotTimeRespecting,0)\},2),$
\end_inset


\end_layout

\begin_layout Example
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{math}
\end_layout

\begin_layout Plain Layout

$
\backslash
indent
\backslash
indent
\backslash
indent
\backslash
indent$
\end_layout

\begin_layout Plain Layout


\backslash
end{math}
\end_layout

\end_inset


\begin_inset Formula $(\{(TimeRespecting,1),(NotTimeRespecting,1)\},2)\}$
\end_inset


\end_layout

\begin_layout Definition
(struttura temporale di un nodo 
\begin_inset Formula $t$
\end_inset

).
 Si dice struttura temporale di un nodo 
\begin_inset Formula $t$
\end_inset

 e si segna come 
\begin_inset Formula $ST_{t}$
\end_inset

 come la coppia 
\begin_inset Formula $(P_{t},impronta_{s})$
\end_inset

 la struttura temporale di un nodo formata dal suo insieme di propagazioni
 e dall'impronta stessa
\end_layout

\begin_deeper
\begin_layout Standard
Avere dei contatti o degli intervalli multipli per singolo arco potrebbe
 sembrare una sciocchezza rispetto alla definizione del problema principale,
 ma in realtà nascondono una complessita aggiuntiva immensa, specialmente
 durante la fase di implementazione.
\end_layout

\begin_layout Standard
Per esempio, per controllare la struttura temporale di un nodo, si dovrebbero
 vedere tutte le possibili combinazioni tra i vari contatti di ogni arco
 e gli altri archi che condividono una quantità di contatti-intervalli maggiore
 di 1.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Definition
Due nodi hanno la stessa struttura temporale se hanno la stessa impronta.
 Più formalmente:
\end_layout

\begin_layout Definition
\begin_inset Formula $j\equiv s\iff impronta_{j}=impronta_{s}$
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Stesso discorso fatto precedentemente per più contatti-intervalli ad arco
 si applica anche in questo caso, la cardinalità dell'impronta aumenta esponenzi
almente alla quantità di contatti-intervalli multipli per arco nel caso
 in cui tutta l'impronta sia considerata per tutte le possibili propagazioni,
 altrimenti è possibile costruire più impronte in base a tutte le combinazioni
 di contatti e definire la stessa struttura temporale se tutte le impronte
 hanno un corrispondente, non per forza diverso.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Corollary
Il confronto tra strutture temporali è una relazione di equivalenza
\end_layout

\begin_layout Corollary

\end_layout

\begin_deeper
\begin_layout Proof
(equivalenza di strutture temporali) Il confronto tra strutture temporali
 è una relazione di equivalenza dato che valgono le proprietà simmetrica,
 transitiva e riflessiva.
\end_layout

\begin_deeper
\begin_layout Itemize
(simmetrica).
 
\begin_inset Formula $\forall j,s\in V|j\equiv s\iff s\equiv j$
\end_inset


\end_layout

\begin_layout Itemize
(riflessiva).
 
\begin_inset Formula $\forall j\in V|j\equiv j$
\end_inset


\end_layout

\begin_layout Itemize
(transitiva).
 
\begin_inset Formula $\forall a,b,c\in V|a\equiv b\cap b\equiv c\implies a\equiv c$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Definition
Due nodi sono simili temporalmente se da un sottoinsieme delle propagazioni
 di un nodo si ricava la stessa impronta dell'altro nodo, formalmente:
\end_layout

\begin_layout Definition
\begin_inset Formula $J$
\end_inset

 è simile ad 
\begin_inset Formula $S(J\simeq S)$
\end_inset

 
\begin_inset Formula $\Longleftrightarrow J\in V,P_{subJ}\subseteq P_{J}\Rightarrow impronta_{subJ}=impronta_{S}$
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Si può notare come questa relazione non sia simmetrica ma antisimmetrica,
 cioè se 
\begin_inset Formula $J$
\end_inset

 è simile ad 
\begin_inset Formula $S$
\end_inset

, non è detto il contrario, e questo fattore è molto importante per le definizio
ni di Temporal Graph Matching nella prossima sezione.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Corollary
La similarità di due nodi è una relazione d'ordine (parziale perché non
 vale la 
\begin_inset Flex Bold
status open

\begin_layout Plain Layout
connex
\end_layout

\end_inset

, quindi non è totale)
\end_layout

\begin_layout Corollary

\end_layout

\begin_deeper
\begin_layout Proof
(similarità come relazione d'ordine) La similarità tra due nodi è una relazione
 d'ordine dato che valgono le proprietà antisimmetrica, transitiva e riflessiva.
\end_layout

\begin_deeper
\begin_layout Itemize
(antisimmetrica).
 
\begin_inset Formula $\forall j,s\in V|j\simeq s\cap s\simeq j\iff j\equiv s$
\end_inset


\end_layout

\begin_layout Itemize
(riflessiva).
 
\begin_inset Formula $\forall j\in V|j\simeq j$
\end_inset


\end_layout

\begin_layout Itemize
(transitiva).
 
\begin_inset Formula $\forall a,b,c\in V|a\simeq b\cap b\simeq c\implies a\simeq c$
\end_inset


\end_layout

\begin_layout Itemize
(no connex).
 
\begin_inset Formula $\forall a,b\in Va\not\simeq b\nRightarrow b\simeq a$
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Corollary
Più semplicemente 
\begin_inset Formula $j$
\end_inset

 è simile ad 
\begin_inset Formula $s$
\end_inset

 se e solo se 
\begin_inset Formula $impronta_{j}\subseteq impronta_{s}$
\end_inset


\end_layout

\begin_layout Corollary

\end_layout

\begin_deeper
\begin_layout Proof
(similarità per sottoinsiemi delle impronte) Se J è simile ad S, tra i possibili
 sottoinsiemi di propagazioni dei nodi considerati ci sarà uno dei quali
 avrà una impronta che sarà uguale a quella del nodo S 
\end_layout

\end_deeper
\begin_layout Standard
La similarità di un nodo ad un altro è stata definita perché sarà centrale
 durante la definizione di Temporal Graph Matching.
\end_layout

\begin_layout Corollary
Se j ed s hanno la stessa struttura temporale allora sono simili.
 Formalmente 
\begin_inset Formula $J\equiv S\Rightarrow J\simeq S$
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Subsubsection
Grafi di flusso (Stream Graphs)
\end_layout

\begin_layout Standard
Una parentesi di rilevanza non trascurabile deve essere portata per i grafi
 di flusso, dato che sono un tentativo della generalizzazione di definizione
 formale per le reti temporali.
\end_layout

\begin_layout Standard
Nonostante la malleabilità e l'adattabilità delle reti temporali ai singoli
 casi (che adattano sia le definizioni che l'implementazione per il caso
 specifico di problema da affrontare), si è tentato di definire un framework
 generale di lavoro formale che si vuole ricollegare alla teoria dei grafi
 ed ampliarla tramite la componente temporale.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename /home/josura/Pictures/fluxGraph.png
	scale 35

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
Figura 1 : Un esempio di grafo di flusso:
\begin_inset Formula $S=(T,V,W,E)$
\end_inset

 con 
\begin_inset Formula $T=[0,10]⊆R,V={a,b,c,d},W=[0,10]×{a}∪([0,4]∪[5,10])×{b}∪[4,9]×{c}∪[1,3]×{d}$
\end_inset

, ed 
\begin_inset Formula $E=([1,3]∪[7,8])×{ab}∪[4.5,7.5]×{ac}∪[6,9]×{bc}∪[2,3]×{bd}$
\end_inset

.
 In altre parole, 
\begin_inset Formula $T_{a}=[0,10],T_{b}=[0,4]∪[5,10],T_{c}=[4,9],Td=[1,3],T_{ab}=[1,3]∪[7,8],T_{ac}=[4.5,7.5],T_{bc}=[6,9],T_{bd}=[2,3]$
\end_inset

, and 
\begin_inset Formula $T_{ad}=T_{cd}=\emptyset$
\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Definition
(grafo di flusso).
 Un grafo di flusso 
\begin_inset Formula $S$
\end_inset

 è definito come la tupla 
\begin_inset Formula $(T,V,W,E)$
\end_inset

, dove 
\begin_inset Formula $T$
\end_inset

 è l'insieme temporale , 
\begin_inset Formula $V$
\end_inset

 è l'insieme dei nodi , 
\begin_inset Formula $W⊆T×V$
\end_inset

 è un insieme di nodi temporali ed 
\begin_inset Formula $E⊆T×V⊗V$
\end_inset

 è un insieme di archi temporali .
\end_layout

\begin_deeper
\begin_layout Standard
Una definizione relativamente più complessa a quelle viste precedentemente,
 che aggiunge la componente temporale anche ai nodi, oltre ad aggiungere
 dei limiti alla componente temporale.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Definition
(tempi di presenza di un nodo).
 Ogni nodo 
\begin_inset Formula $v∈V$
\end_inset

 ha un insieme di tempi di presenza 
\begin_inset Formula $T_{v}={t,(t,v)∈W}$
\end_inset

.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Definition
(tempi di presenza di un arco).
 
\begin_inset Formula $T_{uv}={t,(t,uv)∈E}$
\end_inset

 è l'insieme di tempi di presenza di un arco 
\begin_inset Formula $u\rightarrow v$
\end_inset

.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Definition
(insieme dei nodi e degli archi derivati).
 
\begin_inset Formula $V_{t}={v,(t,v)∈W}$
\end_inset

 e 
\begin_inset Formula $E_{t}={uv,(t,uv)∈E}$
\end_inset

 sono i nodi e gli archi associati ad un tempo o ad un intervallo, grazie
 al quale è possibile definire 
\begin_inset Formula $G_{t}=(V_{t},G_{t})$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Standard
Questo è il grafo indotto temporalmente molto simile ad uno snapshot, anche
 se in realtà 
\begin_inset Formula $t$
\end_inset

 sarebbe un intervallo, quindi può essere visto come un insieme di layer
 del grafo.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
È possibile derivare anche altre misure e metriche (come per esempio grado
 temporale medio di un nodo oppure la densità di un grafo di flusso che
 è la probabilità per cui, quando si sceglie a caso un istante di tempo
 e due nodi presenti in quel momento, questi due nodi siano collegati insieme
 in quel momento).
\end_layout

\begin_layout Standard
È possibile definire anche i concetti di grafo bipartito (sfruttando anche
 le componenti temporali), pesato (con funzioni che cambiano con il tempo
 in base al momento in cui si trova l'intervallo di contatto, molto utili
 per molti casi) e diretto, ma non sono utili per il fine ultimo di questo
 studio, per approfondimenti vedere 
\begin_inset CommandInset citation
LatexCommand cite
key "latapy2018stream,holme2019temporal"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename /home/josura/Pictures/fluxWeigthedGraph.png
	scale 40

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
Figura 2: Un esempio di grafo di flusso pesato, come si può vedere, i pesi
 sono delle funzioni che variano con il tempo dell'intervallo, solo gli
 archi sono pesati.
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Durante questo studio però non verranno utilizzati anche perché non aggiungono
 nulla di particolarmente utile al problema che si affronta principalmente,
 che è quello del Temporal Graph Matching, e la formalizzazione di definizioni
 utili per la descrizione del problema è già stata fatta precedentemente.
\end_layout

\begin_layout Subsection
Caratteristiche significative delle reti temporali
\end_layout

\begin_layout Standard
Vi sono molte caratteristiche che possono essere rilevanti e significative
 durante una analisi, per il graph matching sono di fondamentale rilevanza
 delle misure di identificazione e similarità locale per riuscire ad identificar
e le stesse caratteristiche di certi nodi e confrontare la similarità degli
 stessi per vedere se è possibile trovare delle funzioni di map per attuare
 gli isomorfismi e gli endomorfismi nello stesso grafo (nella sezione di
 graph matching si vedrà che servirà il calcolo degli endomorfismi per la
 rottura delle simmetrie nel grafo query).
\end_layout

\begin_layout Standard
Altre misure che descrivono le caratteristiche di una rete temporale sono
 la distribuzione dei gradi e dei tempi di contatto, molto utili per vedere
 se la rete segue una normale distribuzione di poisson, oppure la più frequente
 per reti temporali 
\begin_inset Flex Emphasize
status open

\begin_layout Plain Layout
Burstiness
\end_layout

\end_inset

 che descrive molti contatti in brevi tratti temporali.
\end_layout

\begin_layout Standard
Una parte importante da definire e da modificare in base alle esigenze del
 caso è il concetto di sincronia e asincronia delle interazioni tra i nodi
 del grafo (gli agenti del sistema), che possono richiedere particolare
 attenzione durante la costruzione della struttura dei modelli e degli algoritmi
, in quanto queste caratteristiche influenzano attivamente l'infrastruttura
 di base e la definizione del problema.
\end_layout

\begin_layout Standard
Stesso discorso può essere fatto sui tipi di relazioni, cioè uno a uno,
 uno a molti e molti a molti, che potrebbero diminuire significativamente
 le prestazioni di qualsiasi algoritmo che lavora sulle componenti temporali
 e topologiche.
\end_layout

\begin_layout Standard
Una considerazione aggiuntiva può essere fatta sui contatti che avvengono
 in un intervallo temporale molto vicino cioè, andando a definire un intorno
 temporale per la propagazione sincronizzata dallo stesso nodo, si possono
 considerare delle propagazioni non Time-Respecting delle differenze tra
 i contatti o tra gli intervalli relativamente piccole, magari causate dalle
 latenze degli strumenti di misura utilizzati per la cattura del sistema
 di base.
\end_layout

\begin_layout Standard
Altre condizioni aggiuntive che possono essere aggiunte per il controllo
 della similarità tra nodi riguardano la valenza di un nodo rispetto a tutto
 il grafo, o misure di similarità che sfruttano una sotto-struttura del
 grafo temporale.
\end_layout

\begin_layout Standard
Caratteristiche aggiuntive possono essere ottenute utilizzando la trasformazione
 del grafo dinamico in altre forme e strutture, come per esempio grafi statici
 speciali o derivati dalla rete temporale, oppure utilizzando strutture
 come liste o min-heap per derivare proprietà aggiuntive.
\end_layout

\begin_layout Standard
Anche se rappresentare i dati come una rete temporale significa che alcune
 informazioni devono essere scartate per motivi di semplificazione e di
 digitalizzazione della componente temporale, questo spesso non è sufficiente
 per ottenere una rappresentazione su larga scala del sistema comprensibile
 ed analizzabile con tecniche comuni.
\end_layout

\begin_layout Standard
Forse il modo più ovvio di semplificare una rete temporale è trasformarla
 in una rete statica utilizzando delle tecniche che mantengano qualche forma
 di temporalità tra le caratteristiche del grafo.
 Nella prossima sottosezione verranno visti dei modi per ottenere delle
 reti statiche dalla rete dinamica di base.
\end_layout

\begin_layout Standard
Come si può intuire facilmente, i grafi temporali trovano molti punti in
 comune con modelli statistici a stati come i modelli di Markov e simili,
 infatti in alcune implementazioni i grafi temporali vengono solitamente
 accompagnati da modelli di Markov costruiti sui compartimenti di base e
 sulle classi dei singoli nodi.
\end_layout

\begin_layout Standard
Metriche globali per i grafi temporali sono principalmente derivate dalla
 struttura topologica del grafo, con integrazioni minime della componente
 temporale.
\end_layout

\begin_layout Standard
Alcune metriche temporali possono essere la distribuzione dei tempi per
 ogni nodo, la distribuzione dei tempi di ogni cammino Time-Respecting,
 ed i parametri derivati da queste distribuzioni ed i fit alle distribuzioni
 più conosciute.
\end_layout

\begin_layout Standard
Altre metriche sono derivabili dai grafi di flusso brevemente descritti
 precedentemente, per approfondimenti riferirsi sempre alla bibliografia
 
\begin_inset CommandInset citation
LatexCommand cite
key "holme2019temporal,latapy2018stream"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
Di grande importanza per molti sono le strutture e caratteristiche 
\begin_inset Flex Bold
status open

\begin_layout Plain Layout
mesoscopiche
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
Il termine mesoscopico si riferisce alla scala tra macroscopico e microscopico.
 Nella network science, ciò significherebbe strutture più grandi dei nodi
 ma più piccole dell'intera rete e, in effetti, il termine è spesso usato
 nei contesti in cui vi è una esigenza di raggruppare i nodi in classi in
 base a come sono collegati tra loro e al resto della rete.
 L'esempio principale di strutture mesoscopiche è la struttura della comunità
 in cui alcune reti hanno gruppi di nodi che sono fortemente connessi all'intern
o del gruppo e debolmente collegati tra loro.
\end_layout

\begin_layout Standard
Insiemi importanti durante molte analisi sono l'
\begin_inset Flex Bold
status open

\begin_layout Plain Layout
insieme di influenza
\end_layout

\end_inset

 e l'
\begin_inset Flex Bold
status open

\begin_layout Plain Layout
insieme di origine dell'informazione
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
Si definisce l’insieme di influenza come l’insieme dei nodi raggiungibili
 dal nodo sorgente.
 
\end_layout

\begin_layout Standard
Alternativamente si può definire l’insieme di origine dell'informazione
 come l'insieme di tutti i nodi sorgente da cui è possibile raggiungere
 il nodo considerato.
 
\end_layout

\begin_layout Standard
Questi due insiemi possono essere visti come il passato ed il futuro del
 nodo e dell'informazione condivisa nella rete.
\end_layout

\begin_layout Standard
Di seguito verranno presentate varie definizioni per metriche e misure sui
 grafi temporali a contatti ma le definizioni possono essere ampliate ad
 intervalli:
\end_layout

\begin_layout Definition
(distanza).
 La definizione di distanza è la stessa delle reti statiche adattata utilizzando
 i cammini Time-Respecting e le definizioni di base che dipendono dal problema
 da trattare, formalmente:
\end_layout

\begin_layout Definition
La distanza è una misura di ottimalità sui cammini che dipende da quello
 che si vuole ottimizzare, per esempio il numero di archi o i pesi degli
 archi.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Definition
(durata temporale).
 Viene introdotta una nuova grandezza che è la durata, definita in un cammino
 come la differenza del tempo di arrivo dell’informazione e del tempo di
 inizio trasmissione dell’informazione, formalmente:
\end_layout

\begin_layout Definition
avendo 
\begin_inset Formula $i$
\end_inset

 e 
\begin_inset Formula $j$
\end_inset

 il nodo iniziale ed il nodo finale di un cammino Time-Respecting, ed 
\begin_inset Formula $i^{>}$
\end_inset

 ed 
\begin_inset Formula $j^{<}$
\end_inset

 i nodi appartenenti al cammino Time-Respecting che collega 
\begin_inset Formula $i$
\end_inset

 e 
\begin_inset Formula $j$
\end_inset

 tale che 
\begin_inset Formula $i^{>}\in i.Adj\cap j^{<}\in j.Adj$
\end_inset

 , viene chiamata distanza il numero 
\begin_inset Formula $e_{jj^{<}}.time-e_{ii^{>}}.time$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Standard
Nel caso di intervalli bisogna tenere conto del primo contatto con il nodo
 nell'intervallo tra il primo ed il secondo nodo del path, e del primo contatto
 tra il penultimo ed ultimo nodo del path.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Definition
(latenza temporale).
 La latenza è la durata minima tra tutti i tempi impiegati nel percorrere
 cammini tra due nodi .
\end_layout

\begin_deeper
\begin_layout Standard
Questa definizione è parallela a quella di distanza minima tra due nodi,
 infatti tutte e due si basano sulla minimizzazione di una caratteristica
 associata a due nodi.
\end_layout

\end_deeper
\begin_layout Definition
Considerazioni algoritmiche sulla ricerca della latenza temporale sono molto
 simili alla ricerca dei cammini minimi, quindi come problema dinamico scomponib
ile in sottoproblemi con soluzioni ottimali.
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Definition
Si definisce la quantità 
\begin_inset Formula $φ_{i,t}(j)$
\end_inset

 come l’ultimo tempo prima di t in cui l’informazione partita da j sia arrivata
 a I 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Definition
(latenza di informazione).
 Viene chiamata information latency la funzione 
\begin_inset Formula $λ_{i,t}(j)=t−φ_{i,t}(j)$
\end_inset

 , che misura di quanto è vecchia l’informazione.
 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Definition
(vector clock).
 Definiamo inoltre 
\begin_inset Formula $[φ_{i,t}(1),...,φ_{i,t}(N)]$
\end_inset

 come il vector clock , cioè il vettore delle latenze di informazione che
 fa vedere tutta la freschezza delle informazioni che arrivano al nodo da
 altri nodi.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Definition
(Closeness Centrality).
 La closeness centrality è definita secondo la seguente legge:
\end_layout

\begin_layout Definition
\begin_inset Formula $C_{c}(i)=\frac{N-1}{\mathop{\sum\limits _{i,j\neq i}^{n}λ_{i,t}(j)}}$
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
dove N è il numero di nodi nel grafo
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Definition
(Betweeness Centrality).
 La betweeness centrality è definita secondo la seguente legge:
\end_layout

\begin_layout Definition
\begin_inset Formula $C_{B}(i)=\frac{\sum\limits _{i,k\neq j\neq i}^{n}v_{i}(j,k)}{\mathop{\sum\limits _{i,k\neq j\neq i}^{n}v(j,k)}}$
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Dove 
\begin_inset Formula $ν_{i}(j,k)$
\end_inset

 è il numero di cammini minimi che passano per i e 
\begin_inset Formula $ν(j,k)$
\end_inset

 è il numero totale di cammini minimi tra j e k
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
Esistono altre misure di centralità ed altri modi di interpretare le varie
 metriche che vengono usate per calcolarle( Path lengths, correlations,
 and centrality ) ma non verranno viste dato che sono molto situazionali.
\end_layout

\begin_layout Standard
Altre misure sono importanti per la creazione di modelli random utili per
 la creazione di reti temporali randomiche.
\end_layout

\begin_layout Standard
La creazione della rete temporale randomica parte da una ipotesi iniziale
 (da questo il modello prende il nome di null model dato che dell'ipotesi
 viene costruita l'infrastruttura a partire dall'ipotesi arbitraria), che
 può essere per esempio il grado medio di ogni nodo, la distribuzione di
 intervalli medi di attivazione degli archi, o la probabilità di effettuare
 contatti tra nodi in certi intervalli temporali.
\end_layout

\begin_layout Standard
Non esiste un modello generalizzato di reti temporali randomizzate, data
 la natura arbitraria dei null models, piuttosto si possono o seguire delle
 linee guida sapendo la struttura base della rete che si vuole analizzare
 e modellare, oppure si può seguire un approccio di forza bruta fino ad
 esaurimento delle possibilità, cioè provare diversi null models e vedere
 quale tra questi restituisce i risultati più soddisfacenti.
 Seguendo una struttura di base, si può prendere ad esempio come infrastruttura
 un grafo temporale con certe proprietà e seguire strutture topologiche
 e temporali.
\end_layout

\begin_layout Standard
Randomized edges (RE) è un modello randomico per la creazione di grafi temporali
, dove cambiamo le destinazioni con probabilità 
\begin_inset Formula $p$
\end_inset

.
\end_layout

\begin_layout Standard
Randomly permutated times è la controparte temporale, la struttura statica
 viene mantenuta, i tempi di contatto rimangono lo stesso numero ma vengono
 permutati tra i vari archi, la cardinalità dei tempi di contatto rimane
 uguale.
\end_layout

\begin_layout Standard
RP conserva l'insieme dei tempi di contatto, ma distrugge il comportamento
 tipico delle reti temporali di burstiness, un altro modello che distrugge
 ancora di più questi pattern di comportamento è il random times(RT) dove
 vengono scelti tempi randomici per ogni contatto, ovviamente la generazione
 dei tempi random non deve seguire per forza una distribuzione uniforme.
\end_layout

\begin_layout Standard
RE +RP è un ibrido tra i due modelli.
 
\end_layout

\begin_layout Standard
Random contacts(RC) mantiene la topologia e ridistribuisce i contatti.
 
\end_layout

\begin_layout Standard
Equal weight edge randomization(EWER) dove archi con lo stesso numero di
 contatti possono essere sostituiti.
 Questo modello mantiene la burstiness, ma ha bisogno di una rete abbastanza
 grande da avere abbastanza contatti.
 
\end_layout

\begin_layout Standard
Edge randomization(ER) è la generalizzazione in cui si può scambiare qualsiasi
 arco.
 La topologia della rete viene distrutta con questo modello, ma la temporalità
 relativamente conservata.
 
\end_layout

\begin_layout Standard
Time reversal(TR) con tempi inversi, cioè si percorrono i contatti in senso
 inverso, si cercano correlazioni tra la rete normale e quella inversa.
 
\end_layout

\begin_layout Standard
Euristico ed empirico è principalmente quasi tutto il procedimento di ricerca
 e di costruzione dei null models, ogni modello favorisce qualche caratteristica
 e distrugge le altre, solitamente si fa un analisi sfruttando un gruppo
 di questi modelli in modo da analizzare una buona parte delle caratteristiche
 della rete temporale, oppure si sfruttano ibridi(e.g.
 RE + RP) che permettano di mantenere un equilibrio tra prevedibilità e
 casualità.
 
\end_layout

\begin_layout Standard
Per grafi con molti contatti il risultato nell'utilizzo di EWER è abbastanza
 soddisfacente, alternato con altri modelli risulta come uno dei “migliori”
 metodi adottati nella creazione dei grafi temporali randomici.
\end_layout

\begin_layout Subsection
Considerazioni sull'implementazione di reti temporali
\end_layout

\begin_layout Standard
Durante le definizioni si sono utilizzati i nodi come identificativi, ma
 solitamente nella realtà si hanno delle etichette associate ad interi che
 sono le entry delle varie liste di adiacenza, quindi bisogna non cadere
 in inganno con la teoria.
\end_layout

\begin_layout Standard
La rappresentazione di una rete temporale per contatti è molto spesso vantaggios
a.
\end_layout

\begin_layout Standard
Questo tipo di approccio favorisce la visione della rete temporale come
 una serie di diapositive (snapshot) della rete in certi tempi, in modo
 da vedere la rete temporale come una sequenza di reti statiche, ma vi sono
 anche altri tipi di rappresentazioni che vengono favorite dai contatti,
 per approfondimenti vedere 
\begin_inset CommandInset citation
LatexCommand cite
key "holme2019temporal"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
Nel caso di reti a contatti più che definire una sequenza di reti statiche
 si può piuttosto definire una matrice di adiacenza tridimensionale dove
 la terza dimensione è il tempo(se i contatti appartengono all’insieme 
\begin_inset Formula $\mathbb{N}$
\end_inset

 ovviamente, magari denormalizzando i valori oppure, nel caso di intervalli,
 trasformare i numeri in interi, e segnare tutte i posti di una matrice
 che appartengono all'insieme ottenuto 
\begin_inset Formula $interval\subset\mathbb{N}\times\mathbb{N}$
\end_inset

), e lavorare su questa matrice, tramite questa definizione è possibile
 .
\end_layout

\begin_layout Standard
Questa matrice di adiacenza viene definita nel seguente modo:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
indent 
\backslash
text{caso contatti}
\end_layout

\begin_layout Plain Layout


\backslash
begin{equation}
\end_layout

\begin_layout Plain Layout

TemporalAdj(i,j,t) = 
\backslash
begin{cases} 
\end_layout

\begin_layout Plain Layout

	1 
\backslash
indent 
\backslash
text{if there is an edge from } $i$ 
\backslash
rightarrow $j$ 
\backslash
text{ at time t}
\end_layout

\begin_layout Plain Layout


\backslash

\backslash
 
\end_layout

\begin_layout Plain Layout

	0 
\backslash
indent 
\backslash
text{otherwise} 
\end_layout

\begin_layout Plain Layout


\backslash
end{cases}
\end_layout

\begin_layout Plain Layout


\backslash
end{equation}
\end_layout

\begin_layout Plain Layout


\backslash
indent 
\backslash
text{caso intervalli}
\end_layout

\begin_layout Plain Layout


\backslash
begin{equation}
\end_layout

\begin_layout Plain Layout

TemporalAdj(i,j,t) = 
\backslash
begin{cases} 
\end_layout

\begin_layout Plain Layout

	1 
\backslash
indent 
\backslash
text{if there is an edge from } $i$ 
\backslash
rightarrow $j$ 
\backslash
cap 
\backslash
text{t} 
\backslash
in e_{ij}.interval
\end_layout

\begin_layout Plain Layout


\backslash

\backslash
 
\end_layout

\begin_layout Plain Layout

	0 
\backslash
indent 
\backslash
text{otherwise} 
\end_layout

\begin_layout Plain Layout


\backslash
end{cases}
\end_layout

\begin_layout Plain Layout


\backslash
end{equation}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nel caso di liste di adiacenza, bisogna semplicemente tenere conto dei contatti
 nel caso in cui si vogliano mantenere singoli contatti per arco come diversi,
 altrimenti si possono tenere degli insiemi associati ad ogni arco che tengono
 conto dei tempi di contatto dell'arco a cui sono associati.
\end_layout

\begin_layout Standard
Come già accennato precedentemente, le reti temporali possono avere altre
 rappresentazioni (trasmission graph, line graph, reachability graph).
\end_layout

\begin_layout Standard
Le reti statiche più semplici che codificano veramente alcuni effetti temporali
 sono i grafi di raggiungibilità (
\begin_inset Flex Emphasize
status open

\begin_layout Plain Layout
reachability graph
\end_layout

\end_inset

).
 Questi grafi hanno un arco diretto (i, j) se un evento può raggiungere
 j da i attraverso un percorso Time-Respecting.
 Infatti, grazie a questi grafi di raggiungibilità, è possibile stabilire
 delle metriche abbastanza rilevanti per il calcolo di varie statistiche
 e per la modellizzazione dei grafi temporali, per esempio si può definire
 una specie di betweeness sulla base del grado di un nodo.
\end_layout

\begin_layout Standard
Si può dimostrare che per ogni rete temporale si possono costruire uno o
 più reachability graph, e si può dimostrare che per ogni reachability graph
 si può costruire una rete temporale che lo rispetti.
\end_layout

\begin_layout Standard
Un modo più elaborato di ridurre le reti temporali a quelle statiche è l'estrazi
one di dorsali specificatamente adattate rispetto ai processi di diffusione
 su reti temporali, per esempio utilizzando le propagazioni Time-respecting
 da nodo a nodo, e costruendo una rete in cui tutti i nodi siano raggiungibili
 in qualche modo da un nodo a scelta, e quindi costruire i modelli sulla
 base di questo nuovo grafo statico facilmente utilizzabile.
\end_layout

\begin_layout Standard
Altro modo di rappresentare le reti dinamiche come reti statiche usa il
 concetto di line graph, dove il ruolo dei nodi e degli archi viene invertito.
 Viene costruito quindi un trasmission graph, che incorpora nella definizione
 dei nodi e degli archi del line graph anche la componente temporale(sia
 del momento del contatto, sia per quanto tempo avviene).
\end_layout

\begin_layout Standard
Un approccio comune che può essere interpretato come proiezione a reti statiche
 consiste nell'utilizzare reti multistrato (multilayer), utilizzando degli
 snapshot ad intervalli secondo il seguente ragionamento: il tempo viene
 suddiviso in intervalli conseguenti e gli strati di una rete multistrato
 corrispondono alle reti aggregate per ciascun intervallo.
 Una volta accoppiati gli strati si possono quindi applicare al sistema
 metodi di modellizzazione e mining per reti (statiche) multistrato.
 È importante sottolineare che gli strati in tale proiezione sono ordinati
 per tempo.
\end_layout

\begin_layout Standard
Invece di ridurre i dati della rete temporale in reti statiche, si può provare
 a conservare alcune ma non tutte le componenti temporali.
\end_layout

\begin_layout Standard
Un esempio sono le statistiche dei tempi tra i contatti.
 È stato riconosciuto già dai primi studi che spesso i tempi tra gli eventi,
 sia per i nodi che per i collegamenti, hanno distribuzioni heavy-tailed
 (bursty come già accennato precedentemente).
 Quindi basta riconoscere e simulare questa proprietà senza tenere conto
 di altre caratteristiche temporali per avere una rete temporale che simuli
 bene la maggior parte delle situazioni che si vorrebbero studiare e modellare.
\end_layout

\begin_layout Standard
Un altro modo di semplificare le reti temporali è ignorare le dinamiche
 dei contatti e pensare semplicemente ai collegamenti presenti tra la prima
 e l'ultima osservazione di un contatto nei dati e ignorare il preciso tempismo
 delle interazioni temporali.
 Rispetto alla semplificazione del sistema sotto forma di dinamiche bursty
 su reti statiche, questa tecnica enfatizza strutture temporali più durature
 come la crescita generale e il declino dell'attività nei dati.
\end_layout

\begin_layout Standard
Esistono anche altri tipi di rappresentazione( per esempio si può aggiungere
 il fatto per cui l’attraversamento di un arco comporta un tempo ben definito,
 e costruire la rete e gli algoritmi di conseguenza) che si basano su altre
 proprietà, ma non verranno viste nel dettaglio dato che lo scopo di questo
 studio è la costruzione di un framework utile nella maggior parte dei casi
 e particolarmente dettagliato per il graph matching.
\end_layout

\begin_layout Standard
Per la rappresentazione utilizzata durante il graph matching, viene utilizzato
 una rappresentazione standard arricchita di contatti tra i vari nodi tramite
 un hashset per avere delle buone prestazioni nel controllo dell'adiacenza.
 vengono utilizzati grafi con singoli contatti per arco ma gli algoritmi
 utilizzati dovrebbero essere generali per più contatti ad arco.
\end_layout

\begin_layout Standard
Il caso ad intervalli non è stato implementato ma i ragionamenti di base
 sono sempre gli stessi (cambia solo il modo di classificare le propagazioni
 ed il problema dei tempi di contatto iniziali dell'intervallo che si vedrà
 nella prossima sottosezione)
\end_layout

\begin_layout Standard
Come si può intuire, è abbastanza semplice aggiungere la componente temporale
 a partire da un grafo statico, ma non si deve cadere nella banalità superficial
e del problema, dato che nasconde una quantità non indifferente di problemi
 legati a molte strutture reali, come per esempio la consistenza interna
 di altre strutture di supporto che dipendono dalla componente temporale,
 magari ricorsivamente, e che quindi richiedono una complessità rilevante
 all'analisi di grafi di grandi dimensioni (e.g.
 la durata di un cammino, le latenze di informazioni, o altre misure che
 dipendono da più contatti-intervalli).
\end_layout

\begin_layout Standard
Alternativa all'implementazione diretta nel grafo statico e nella sua struttura
 è la creazione di una rappresentazione completamente basata sulle componenti
 temporali, per esempio che sfrutta contatti e propagazioni per il modello
 che è stato definito durante questo studio, oppure che implementa tutte
 le possibilità offerte dai grafi di flusso descritti brevemente nelle sezioni
 precedenti.
\end_layout

\begin_layout Standard
Nonostante l'importanza delle propagazioni nella definizione e comprensione
 del problema che si affronta e verrà affrontato nel dettaglio successivamente,
 cioè il graph matching, molto spesso le informazioni che posseggono sono
 ridondanti e derivabili da alcune componenti del grafo temporale semplice,
 anche perché l'integrazione delle componenti temporali è stata fatta direttamen
te su una rappresentazione statica di un grafo quindi non si può ottenere
 vantaggio sul tenere delle strutture per le propagazioni.
\end_layout

\begin_layout Standard
Questa parentesi sulla utilità bassa delle propagazioni (solo in questo
 caso dato che si doveva riutilizzare altro codice ed adattarlo per la ricerca
 di isomorfismi su grafi temporali) non toglie la loro indeterminabile importanz
a per la definizione di molti problemi che considerano una struttura locale
 per la ricerca di qualcosa, come ricerca di clique, motifs, communities,
 ed altre strutture legate ad una visione microscopica e mesoscopica del
 grafo temporale.
\end_layout

\begin_layout Standard
Una possibile ottimizzazione al continuo calcolo delle strutture e delle
 impronte digitali sta nel tenere una struttura interna per ogni nodo che
 cambia all'aggiunta di archi tra nodi (ovviamente correlati di tempo di
 contatto o intervallo di contatto), anche se di fondo questo calcolo di
 struttura è fatto soltanto per il calcolo dei domini di compatibilità che
 si vedranno in seguito.
\end_layout

\begin_layout Subsection
Problemi tipici delle reti temporali
\end_layout

\begin_layout Standard
La maggior parte dei problemi che potrebbero risaltare durante la costruzione
 di una rete temporale e dell'analisi della stessa sono solitamente collegati
 con il problema di base che si cerca di analizzare.
\end_layout

\begin_layout Standard
Per esempio la trasposizione di una rete di eventi come modelli epidemici
 o metabolici comporta innumerevoli caratteristiche aggiuntive da tenere
 conto durante l'analisi sia temporale che topologica.
\end_layout

\begin_layout Standard
Altre possibili complicazioni che possono venire a galla vengono dalla banalità
 di analisi e comprensione con cui si tratta il problema di base, che solitament
e non dipende soltanto dalla componente temporale o dalla topologica della
 rete con cui viene rappresentato, ma da molti altri fattori che influenzano
 i comportamenti all'interno della rete.
\end_layout

\begin_layout Standard
Quindi, più si tenta di rappresentare una realtà effettiva, più problemi
 si incontreranno durante il percorso di costruzione, implementazione ed
 analisi.
\end_layout

\begin_layout Standard
Per esempio, nel caso di intervalli temporali, che sembra non aggiungano
 complessità aggiuntiva, si può facilmente notare che nel momento della
 propagazione bisogna tenere conto dell'intervallo in cui è avvenuta la
 propagazione precedente, quindi fare iniziare l'intervallo della nuova
 propagazione in un range di quella precedente o, per semplificare, dal
 minimo dell'intervallo risultante (questa considerazione del minimo dell'inters
ezione è stata già fatta nella definizione del propInterval di una propagazione).
\end_layout

\begin_layout Definition
Dati 
\begin_inset Formula $p_{itj}$
\end_inset

 e 
\begin_inset Formula $p_{tje}$
\end_inset

 due propagazioni, l'intervallo della propagazione 
\begin_inset Formula $p_{tje}.e_{s}.interval=p_{itj}.propInterval$
\end_inset

 e non l'intervallo di propagazione dell'arco 
\begin_inset Formula $tj$
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
Questa definizione fa risalire molti problemi dato che definire l'intervallo
 secondo una specifica propagazione da altre propagazioni dei nodi precedenti
 allo stesso è molto ambiguo, quindi non isolato come problema, che invece
 nasconde una ricorsione interna per il calcolo effettivo di questi intervalli,
 ricorsione dipendente dal cammino che si sta prendento.
\end_layout

\begin_layout Standard
Nell'implementazione questo problema è stato evitato grazie a dei controlli
 aggiuntivi molto simili a quelli dell'impronta, ma che utilizzano il singolo
 arco da mappare (o l'intervallo nel caso di grafo ad intervalli) per vedere
 la fattibilità del mapping effettivo.
 
\end_layout

\begin_layout Standard
Prima e durante la costruzione di reti temporali, bisogna tenere conto di
 quante informazioni si perdono e quanto valga la pena costruire una rete
 temporale, cioè considerare la fattibilità, l’accuratezza e la manutenzione
 della rete, svolgendo una analisi dei rischi effettiva, dato che la costruzione
 di una rete, correlata dalla costruzione dei modelli associati, non è qualcosa
 da prendere sottogamba.
\end_layout

\begin_layout Standard
Nella costruzione di reti temporali randomiche considerazioni sono state
 già fatte sulla base di modelli randomici, che comunque non tenevano conto
 di alcune caratteristiche o metriche utilizzabili, ma che utilizzavano
 degli approcci 
\begin_inset Flex Bold
status open

\begin_layout Plain Layout
\begin_inset Flex Emphasize
status open

\begin_layout Plain Layout
trial and error
\end_layout

\end_inset


\end_layout

\end_inset

, abbastanza poco performanti.
\end_layout

\begin_layout Standard
Molto spesso inoltre vi sono dei problemi di scalabilità, in quanto se i
 cambiamenti di una rete statica sono minimi temporalmente (troppo lenti
 o troppo veloci), ma abbastanza topologicamente (aggiunta di nodi o archi
 aggiuntivi), la costruzione dell'infrastruttura temporale diventa tediosa
 ed inutile a lungo termine, quindi bisogna svolgere un confronto della
 rapidità di cambiamento della rete statica e temporale prima di continuare
 con la costruzione di una rete.
\end_layout

\begin_layout Standard
Sempre riguardante la scalabilità è la dimensione stessa della rete ed il
 tipo, come si è visto durante la definizione dei vari problemi, nel caso
 di più contatti o intervalli, le soluzioni sono molto pesanti computazionalment
e dato che si visitano tutte le possibilità possibili, quindi si aumenta
 fattorialmente la complessità asintotica temporale dei possibili algoritmi
 che si potrebbero utilizzare.
\end_layout

\begin_layout Standard
Questi problemi possono essere comunque evitati tenendo delle strutture
 aggiuntive, sacrificando lo spazio per il tempo, e diminuendo le ridondanze
 di computazione ripetuta per il calcolo delle strutture temporali delle
 componenti di un grafo.
\end_layout

\begin_layout Standard
Alla banalità della costruzione superficiale di una rete temporale non contribui
sce neanche la visualizzazione e rappresentazione di una rete, che potrebbero
 comprometterne sia la complessità che l’interpretazione, specialmente ad
 occhi di terzi che non hanno molta esperienza sulla infrastruttura temporale
 su cui dovrebbero lavorare.
\end_layout

\begin_layout Standard
Uno dei problemi più importanti e che preclude l'usufruizione di molte tecniche
 basata su di essa è l'intransitività, caratteristica basilare di molti
 algoritmi che lavorano sui grafi, come per esempio la ricerca di cammini
 ottimali oppure la ricerca di componenti connesse.
 
\end_layout

\begin_layout Standard
Nonostante la letteratura scientifica sulle reti temporali stia crescendo
 con gli ultimi anni, non è ancora per nulla paragonabile alla letteratura
 sulle reti statiche, quindi la maggior parte degli argomenti è ancora territori
o inesplorato.
 
\end_layout

\begin_layout Standard
La letteratura sulle reti temporali è molto sparsa, vi sono molte ambiguità
 durante lo studio dell’argomento e la costruzione di una rete specifica
 per un singolo caso particolare, e solitamente si lascia la libertà di
 scelta ed interpretazione.
 Tentativi di standardizzazione e formalizzazione sono stati fatti con i
 grafi di flusso 
\begin_inset CommandInset citation
LatexCommand cite
key "latapy2018stream,holme2019temporal"
literal "false"

\end_inset

citati precedentemente, ma ancora non sono stati testati totalmente per
 qualsiasi caso data la loro giovinezza.
\end_layout

\begin_layout Standard
Le reti temporali sono sistemi complessi particolarmente delicati e ingannevoli,
 anche perché la componente temporale non è un semplice numero o intervallo,
 lo scorrere del tempo in qualche modo è qualcosa di complesso e non semplice
 da studiare.
 
\end_layout

\begin_layout Standard
Nel caso di modelli randomici, per essere significativa la costruzione ed
 analisi della rete bisogna avere delle interazioni binarie, cioè tra due
 nodi, in modo da mantenere sia un certo livello di prevedibilità, sia una
 certa randomicità nel comportamento della rete, in modo che simuli bene
 i sistemi reali.
 Inoltre le reti temporali costruite non dovrebbero essere né troppo casuali
 né troppo regolari per non allontanarsi troppo dalla rete statica a cui
 sono state interfacciate.
 
\end_layout

\begin_layout Standard
Bisogna tenere particolare attenzione alla velocità dei contatti rispetto
 alla velocità di cambiamento del sistema dinamico della rete.
 Essendo un sistema dinamico, la rete temporale è particolarmente difficile
 da analizzare, nodi possono rientrare ed uscire, archi possono non essere
 percorsi, bisogna tenere conto di molte variabili ed alcune potrebbero
 non essere intuibili.
\end_layout

\begin_layout Standard
Nella ricerca di motifs, cliques, community, e altri tipi di pattern che
 hanno una certa regolarità esistono diverse interpretazioni, come per il
 problema trattato in questo studio che è quello del Temporal Graph Matching,
 dove molti autori danno definizioni completamente diverse o non chiare,
 che molte volte lasciano casi abbastanza semplici ed utili in molte applicazion
i, questo tipo di problemi verrà visto nella prossima sezione.
 
\end_layout

\begin_layout Standard
Importanti nell’analisi di reti temporali non sono soltanto le cause topologiche
 o pratiche per cui avvengano certe interazioni, non vi sono solo interpretazion
i ed analisi differenti della natura temporale ma, molto spesso, vi è una
 ricerca anche delle origini delle interazioni tra i vari agenti, per esempio
 lo studio del contatto tra due nodi che, come già detto, assume un comportament
o bursty più che seguire una distribuzione conosciuta (e.g.
 poisson).
\end_layout

\begin_layout Standard
Lo studio delle reti temporali potrebbe giovare di molti studi che vengono
 fatti sulle reti statiche(come per esempio la colorazione dei grafi, o
 la grande quantità di metodi utili per la ricerca dei cammini minimi, per
 la ricerca delle chiusure transitive), ma dato che il soggetto è abbastanza
 giovane, nonostante degli studi sono stati fatti fin dagli anni novanta
 in modo approssimativo, vi è la necessità di espandere molte delle ricerche
 che vengono fatte su grafi, multigrafi, etc.
 anche ai grafi temporali.
\end_layout

\begin_layout Standard
Si è accennata alla modellizzazione e generazione di reti temporali con
 caratteristiche particolari, in questo campo di studio vi sono dei metodi
 molto simili a quelli delle reti statiche, con opportune modifiche che
 variano da caso a caso e che vedono di particolare rilevanza la componente
 temporale, quindi costruiscono delle reti sulla base di quello che si vorrebbe
 ottenere, magari adottando metodi unici e non standardizzabili, quindi
 poco generali.
\end_layout

\begin_layout Standard
Durante tutto questo studio si è data particolare attenzione a dei descrittori
 di struttura temporale, come l'impronta temporale definita precedentemente,
 si potrebbe giovare comunque di altri tipi di strutture che rispecchino
 la vera natura della componente temporale, che siano create e studiate
 per essere utili nella analisi delle reti dinamiche, e che riescano a descriver
e proprietà globali o mesoscopiche in modo da poter trovare delle similarità
 tra le varie reti temporali.
\end_layout

\begin_layout Standard
Le reti temporali a contatti restano comunque lo state of the art di molti
 studi (quasi tutti gli studi utilizzano singoli contatti).
 Questo anche perché riescono a rappresentare delle situazioni abbastanza
 normali e non troppo banali senza intaccare pesantemente la complessità
 del sistema di base.
 Resta il fatto che singoli momenti non rappresentano molte delle situazioni
 reali più importanti, che invece hanno degli agenti che agiscono per intervalli.
\end_layout

\begin_layout Standard
Per altri problemi riguardanti il singolo sistema da voler rappresentare
 vedere 
\begin_inset CommandInset citation
LatexCommand cite
key "holme2019temporal"
literal "false"

\end_inset

 che fa un lavoro immenso nelle possibilità di rappresentazione di sistemi
 che contengono ed incorporano la componente temporale in qualche modo.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Isomorfismi di grafi
\end_layout

\begin_layout Standard
La ricerca di isomorfismi e pattern ripetuti all'interno della struttura
 di un grafo è qualcosa che ha prodotto una quantità immensa di materiale
 scientifico, anche per il fatto che i risultati sono molto spesso rilevanti
 in molti campi e fanno luce su certe meccaniche che non si potrebbero apprender
e in sistemi complessi, come comportamenti emergenti o agenti che svolgono
 ruoli diversi ma che, alla fine, comunicano molto spesso tra di loro scambiando
si messaggi e informazioni.
\end_layout

\begin_layout Standard
In modo molto approssimativo e generale, la ricerca di isomorfismi in grafi
 si riduce alla ricerca delle strutture che rispettano le condizioni stabilite
 in base al caso ed al tipo di struttura che si sta analizzando.
\end_layout

\begin_layout Standard
Nel caso dei grafi temporali, la ricerca di isomorfismi è importantissima
 in molti campi, e spesso molto differente in base al problema di base che
 si cerca di risolvere.
\end_layout

\begin_layout Standard
Infatti , come si vedrà nelle prossime sottosezioni, molti autori non sembrano
 concordare su un framework unico da utilizzare e sulle definizioni da sfruttare
 per la descrizione del problema di base, nonostante i problemi che trattano
 sono molto spesso molto simili ed indipendenti dal problema di base.
\end_layout

\begin_layout Standard
Per esempio, da un lato si ha una ricerca di motif temporali che adotta
 una ricerca edge-driven, che tiene conto solo di una singola definizione
 abbastanza stretta anche per il fatto che l'algoritmo vero e proprio è
 incentrato sull'ottimizzazione per la ricerca ed il conteggio di piccole
 query-pattern(tre nodi per query, si vedrà in seguito)
\begin_inset CommandInset citation
LatexCommand cite
key "paranjape2017motifs"
literal "false"

\end_inset

 e dall'altro una definizione più generica ma che riguarda soltanto una
 serie di sotto-problemi e dipende da condizioni semplici che non espongono
 realmente la complessità del problema
\begin_inset CommandInset citation
LatexCommand cite
key "redmond2016subgraph"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
Il problema sembra quindi non essere stato affrontato ancora nel dettaglio
 ed un framework effettivamente utilizzabile non è stato ancora trovato
 (o almeno non è stato trovato durante le ricerche, magari un ricercatore
 sconosciuto ci ha già pensato ma non sta ricevendo l'attenzione che gli
 spetta ed i motori di ricerca non aiutano).
\end_layout

\begin_layout Standard
Durante tutto questo studio, sono state date delle definizioni che saranno
 chiave per la definizione del problema di base, e quindi necessario non
 dimenticare quello che è stato detto precedentemente e rivedere le definizioni
 nel caso in cui ci siano dei dubbi.
\end_layout

\begin_layout Standard
Le definizioni date precedentemente e prossimamente non sono comunque totalmente
 generali, dato che esisterà quasi sicuramente un caso che ha delle condizioni
 diverse, anche se tutto il framework descritto è stato costruito per essere
 il più generale possibile, grazie alle definizione di classi delle propagazioni
 che è facilmente espandibile con altre classi.
\end_layout

\begin_layout Standard
Di seguito verrà mostrato il graph matching su grafi statici per presentare
 l'algoritmo che si utilizzerà durante il matching e le sue modifiche, non
 si scenderà troppo sui dettagli per il Sub-Graph Isomorphism per i grafi
 statici ma verranno presentate le idee di base, dato che verrà sviscerato
 il concetto durante la discussione delle possibili modifiche apportabili
 al sistema di base di strutture e algoritmi per l'adattamento ai grafi
 temporali.
\end_layout

\begin_layout Standard
Verso la fine verranno presentati gli algoritmi utilizzati e le descrizioni
 di tali algoritmi al fine di una comprensione completa.
\end_layout

\begin_layout Standard
Infine, verranno visti e discussi dei problemi riguardanti l'isomorfismo
 su grafi e possibili soluzioni , questi problemi sono molto rilevanti dato
 che chiariscono ancora una volta il collegamento delle definizioni di grafi
 temporali e isomorfismi alla casistica del problema.
\end_layout

\begin_layout Subsection
Graph matching per grafi statici
\end_layout

\begin_layout Standard
Il problema del graph matching su grafi statici è stato smembrato in molti
 modi già dall'inizio degli studi sulla teoria dei grafi.
 
\end_layout

\begin_layout Standard
Gli studi sono innumerevoli, le soluzioni spaziano dalle soluzioni semplici
 di visita di tutte le possibili soluzioni alle più complesse, che utilizzano
 le proprietà parallele della computazione della ricerca dei sotto-grafi
 in modo da dividere il problema e ottimizzare l'uso della singola macchina(util
izzando la GPU integrata o la discreta, il multithreading ed altre tecnologie
 che permettono la parallelizzazione della computazione), oltre all'utilizzo
 di euristiche aggiuntive per la diminuzione dello spazio di ricerca, anche
 perché il problema della ricerca degli isomorfismi in grafi è NP-hard come
 minimo, mentre la ricerca di isomorfismi su sotto-grafi è NP-completo,
 quindi delle soluzioni che diminuiscano il tempo di calcolo e la complessità
 asintotica in generale sono assolutamente ben accette.
\end_layout

\begin_layout Standard
Tra le implementazioni che fanno un controllo di isomorfismo su singolo
 grafo vi sono principalmente algoritmi che attuano una trasformazione del
 grafo in una forma canonica univoca che è possibile identificare e confrontare
 per vedere se le condizioni di isomorfismo sono soddisfatte (tra questi
 algoritmi risaltano 
\begin_inset Flex Bold
status open

\begin_layout Plain Layout
Bliss, Saucy, Conauto e Traces
\end_layout

\end_inset

).
\end_layout

\begin_layout Standard
La ricerca della forma canonica non è un problema semplice, ma esistono
 molti studi a riguardo.
\end_layout

\begin_layout Standard
Per il problema riguardante ricerca di isomorfismi su sotto-grafi esistono
 quindi altrettante soluzioni, dato che il problema è una generalizzazione
 della ricerca di isomorfismi tra grafi.
\end_layout

\begin_layout Standard
Queste soluzioni del Sub-Graph isomorfism non verranno viste tutte, ma verranno
 solo accennate approssimativamente nelle componenti più importanti che
 influenzano direttamente le prestazioni ed i ragionamenti logici per la
 ricerca di soluzioni ottimali.
\end_layout

\begin_layout Standard
Verrà visto invece nel dettaglio l'algoritmo per la ricerca di isomorfismi
 su sotto-grafi 
\begin_inset Flex Bold
status open

\begin_layout Plain Layout
RI
\end_layout

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "bonnici2013subgraph,micale2020multiri"
literal "false"

\end_inset

, che incorpora molte euristiche di altri algoritmi, e favorisce la velocità
 dell'algoritmo e la diminuzione dello spazio di ricerca delle soluzioni.
 
\end_layout

\begin_layout Standard
Un semplice algoritmo di enumerazione per trovare tutti gli isomorfismi
 del sotto-grafo (cioè le occorrenze) di un grafo di pattern in un grafo
 target funziona come segue: si generano tutte le possibili corrispondenze
 tra i vertici dei due grafi e si controlla se qualsiasi corrispondenza
 generata è un isomorfismo di sotto-grafo (che verrà chiamato match).
 Considerando che questo algoritmo è totalmente inefficiente se implementato
 in modo ingenuo, oltre ad essere una vera e propria forza bruta, serve
 come punto di partenza.
 
\end_layout

\begin_layout Standard
Tutte le corrispondenze possono essere rappresentate utilizzando un albero
 dello spazio di ricerca.
 
\end_layout

\begin_layout Standard
L'albero ha una radice fittizia.
 Ogni nodo rappresenta una possibile corrispondenza tra qualche vertice
 u del grafo query G e qualche vertice u’ del grafo target G’.
 Il percorso dalla radice a un dato nodo rappresenta una corrispondenza
 parziale tra G e G'.
 Solo alcuni percorsi dalla radice alle foglie corrispondono agli isomorfismi
 del sotto-grafo tra il grafo query e il grafo target, ed è proprio quelli
 che si devono cercare primariamente in modo da avere un matching veloce.
\end_layout

\begin_layout Standard
Trovare una soluzione per il problema dell'isomorfismo del sottografo è
 intrinsecamente difficile e quindi l'efficienza di qualsiasi software che
 utilizza algoritmi di isomorfismo del sottografo dipende in gran parte
 da 
\end_layout

\begin_layout Enumerate
trovare euristiche efficienti per rendere gli algoritmi di isomorfismo più
 veloci, quindi utilizzarle in modo ibrido così da avere le migliori caratterist
iche possibili; 
\end_layout

\begin_layout Enumerate
ridurre il numero di chiamate di isomorfismo del sottografo, quindi diminuire
 sommariamente il tempo di esecuzione;
\end_layout

\begin_layout Enumerate
diminuire e rendere semplici e veloci le condizioni di isomorfismo, in modo
 da avere una base solida e che non abbia troppo carico sul sistema.
\end_layout

\begin_layout Standard
Molti algoritmi funzionano svolgendo dei confronti locali rispetto al nodo,
 attuando delle regole di lookahead per il controllo delle condizioni per
 un nodo candidato ed i nodi non ancora mappati collegati al nodo da mappare,
 questa funzione è utile in molti casi (è stata pure implementata nel codice
 di implementazione del grafo temporale una funzione che controlla regole
 di lookahead fino al terzo livello con il nome di 
\begin_inset Flex Bold
status open

\begin_layout Plain Layout
testNodeMapping
\end_layout

\end_inset

, ma non verrà utilizzata nello studio vero e proprio perché RI non utilizza
 regole di lookahead dispendiose) ma è molto costosa nelle performance,
 ed il pruning può essere fatto senza troppi problemi per piccoli intorni
 di un nodo senza spendere troppo tempo a controllare delle condizioni ridondant
i .
 Nel momento in cui un nodo non rispetta le condizioni per essere mappato,
 si ritorna indietro (rollback o backtracking ad un nodo più in alto nell'albero
 di ricerca) e si controllano altri possibili mapping.
\end_layout

\begin_layout Standard
Durante la visita vengono controllate le condizioni di isomorfismo per verificar
e gli abbinamenti parziali.
 Quando le condizioni non sono soddisfatte, l'algoritmo elimina i rami sottostan
ti e torna indietro sui nodi principali dell'albero di ricerca.
 La dimensione dell'albero dello spazio di ricerca aumenta esponenzialmente
 con la dimensione del grafo.
\end_layout

\begin_layout Standard
L'obiettivo principale è eliminare cammini dalla radice alle foglie che
 non sono degli isomorfismi il più velocemente possibile.
\end_layout

\begin_layout Standard
Una caratteristica che influenza molto la strategia di ricerca di soluzioni
 è l'ordinamento dei nodi del grafo query che vengono analizzati durante
 la fase di matching.
\end_layout

\begin_layout Standard
Grazie a questo ordinamento, è possibile diminuire lo spazio di ricerca
 molto velocemente, e trovare le soluzioni è conseguentemente più veloce.
\end_layout

\begin_layout Standard
L'ordinamento dei nodi può essere di due tipi: statico e dinamico.
\end_layout

\begin_layout Standard
Tramite un ordinamento statico, si definisce un ordinamento iniziale che
 è uguale per qualsiasi percorso da radice a foglia.
 Nell'ordinamento dinamico, vi è un ordine per ogni singolo cammino e questi
 ordini sono solitamente stabiliti a tempo di esecuzione.
\end_layout

\begin_layout Standard
Tra gli algoritmi più utilizzati per la ricerca di isomorfismi in sottografi
 al giorno d'oggi vi è VF (con le successive versioni che ottimizzano e
 aumentano le performance, fino ad oggi la versione è VF3).
\end_layout

\begin_layout Standard
VF (acronimo di Vento-Foggia) utilizza una strategia di ricerca dinamica.
 
\end_layout

\begin_layout Standard
Data una soluzione parziale, per prima cosa sceglie i vertici del pattern
 non corrispondenti aventi archi che hanno sorgente vertici della soluzione
 parziale; quindi sceglie quei vertici non corrispondenti che hanno archi
 con destinazione in vertici della soluzione parziale.
 Per ridurre lo spazio di ricerca, l'approccio utilizza le seguenti due
 euristiche di lookahead.
 Una coppia di mappatura (u, u '), dove u ed u' sono rispettivamente dei
 vertici dei grafi query e target, è considerata una corrispondenza valida
 se soddisfa le seguenti regole: 
\end_layout

\begin_layout Enumerate
u ed u' sono entrambi vicini dei vertici che sono stati già mappati; 
\end_layout

\begin_layout Enumerate
il numero di vertici del pattern non abbinati che sono vicini ai vertici
 abbinati e sono collegati con u deve essere minore o uguale al numero di
 vertici del target non abbinati che sono vicini ai vertici abbinati e sono
 collegati con u' .
 
\end_layout

\begin_layout Standard
La regola (ii) è suddivisa in quattro casi a seconda della direzione dei
 bordi coinvolti tra i vicini di u e l'insieme in (i).
 
\end_layout

\begin_layout Standard
Vi era inoltre un altra regola di lookahead che considerava tutti i nodi
 connessi, ma non viene descritta dato che viene utilizzata solo per sottografi
 indotti.
\end_layout

\begin_layout Standard
Si distinguono comunque due grandi famiglie di algoritmi di ricerca di isomorfis
mi : algoritmi Tree Search (TS) e algoritmi Constraint Propagation (CP).
 
\end_layout

\begin_layout Standard
Gli algoritmi di ricerca ad albero (Tree Search) formulano il problema di
 corrispondenza in termini di una rappresentazione State Space Representation
 (SSR), che consiste nell'esplorazione di un albero dello spazio di ricerca.
 Ogni stato dell'SSR corrisponde a una soluzione parziale.
 Lo spazio di ricerca viene visitato in un primo ordine profondo e l'euristica
 è concepita per evitare di esplorare parti dello spazio di ricerca utilizzando
 regole aggiuntive.
 Gli algoritmi di questa classe includono l'algoritmo di Ullmann, VF2, VF3,
 RI e RI-DS.
 
\end_layout

\begin_layout Standard
Nei metodi di propagazione dei vincoli (Constraint Propagation), il problema
 di corrispondenza dei sottografi è rappresentato come un problema di soddisfazi
one dei vincoli (Constraint Satisfaction Problem).
 I nodi del grafo query sono rappresentati come variabili ed i nodi del
 grafo destinazione rappresentano i valori che possono essere assegnati
 a tali variabili.
 Gli archi vengono tradotti in vincoli che devono essere soddisfatti.
 
\end_layout

\begin_layout Standard
Gli algoritmi CP calcolano prima un dominio di compatibilità per ogni nodo
 del grafo pattern-query e quindi propagano iterativamente i vincoli per
 ridurre tali domini e filtrare i nodi candidati per la corrispondenza.
 I metodi CP più famosi sono nRF +, Focus-Search e LAD.
\end_layout

\begin_layout Standard
Diverse tecniche di filtraggio, come il forward-checking (controllo a priori),
 eliminano i rami dell'albero di ricerca propagando i vincoli per rimuovere
 i valori dai potenziali domini di compatibilità.
 Un ramo viene eliminato quando un dominio diventa vuoto.
 
\end_layout

\begin_layout Standard
Nel forward-checking, prima viene assegnata una variabile, quindi tutti
 i vincoli che coinvolgono tali variabili vengono propagati per rimuovere
 i valori da altri domini che non sono coerenti con l'assegnazione corrente
 (inferenza).
 
\end_layout

\begin_layout Standard
I metodi basati sull'inferenza, che propagano i vincoli fino alla convergenza
 (ad esempio LAD), riducono al massimo il tempo di ricerca.
 Sfortunatamente, tale inferenza viene fatta al prezzo di un maggiore costo
 computazionale e di preprocessing.
 D'altra parte, quando la verifica dei vincoli viene applicata solo localmente
 (ad esempio, l'inferenza locale utilizzata da FocusSearch e le regole di
 pruning di VFlib), è fondamentale definire una strategia di ricerca che
 cerchi di sfoltire lo spazio di ricerca in modo ottimale ed il più presto
 possibile a basso costo.
\end_layout

\begin_layout Standard
Le caratteristiche più importanti per le performance di un algoritmo descritte
 precedentemente vengono, per la maggior parte, implementati in 
\begin_inset Flex Bold
status open

\begin_layout Plain Layout
RI
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
RI adotta una strategia di ricerca basata solo sulla topologia del grafo
 query.
 L'ordine viene scelto per creare i vincoli il prima possibile nella fase
 di matching.
 Approssimativamente, i vertici che hanno alta valenza e che sono altamente
 connessi con i vertici precedentemente presenti nell'ordinamento tendono
 a venire prima nell'ordinamento finale delle variabili.
 Durante la fase di abbinamento, RI non applica regole di pruning o inferenza
 onerose per il calcolo e per la computazione.
 Un potente ordinamento dei vertici del grafo query insieme alla verifica
 di vincoli non troppo onerosi, è più efficiente di una procedura di inferenza
 locale o globale.
\end_layout

\begin_layout Standard
L'algoritmo RI si divide in quattro fasi principali:
\end_layout

\begin_layout Enumerate
La prima fase di RI calcola i domini di compatibilità 
\begin_inset Formula $Dom(q)$
\end_inset

 per ogni nodo del grafo query 
\begin_inset Formula $q$
\end_inset

 , questo dominio è l'insieme di nodi nel grafo target che possono essere
 mappati ad uno dei nodi del grafo query in base a condizioni topologiche
 come il grado del nodo ed altre metriche o strutture confrontabili(poi
 si vedrà quali condizioni aggiungere per integrare la componente temporale)
 .
 Questa fase aumenta le performance proprio perchè solo i nodi del grafo
 target nel dominio di q saranno considerati come possibili candidati per
 il match di un nodo durante la fase di ricerca dell'isomorfismo.
 Formalmente, sia 
\begin_inset Formula $Q=(V_{Q},E_{Q})$
\end_inset

 un grafo chiamato query e 
\begin_inset Formula $T=(V_{T},E_{T})$
\end_inset

 un grafo chiamato target.
 Un nodo 
\begin_inset Formula $t∈V_{T}$
\end_inset

 è compatibile con un nodo 
\begin_inset Formula $q∈V_{Q}$
\end_inset

 se la seguente condizione è soddisfatta:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $deg(q)≤deg(t)$
\end_inset


\end_layout

\begin_layout Standard
Dopo il calcolo dei domini di compatibilità, una tecnica di Arc Consistency
 (AC) viene applicata per togliere possibili candidati che non rispettano
 i requisiti minimi.
 La procedura AC afferma ce se esiste un arco tra due nodi del target, q
 e q', allora per ogni nodo target tra quelli compatibili (Dom(q) come sorgente
 e Dom(q') come destinazione) deve esistere un arco tra i nodi del dominio
 del nodo sorgente ed almeno un nodo tra quelli del nodo destinazione e
 viceversa.
 Ciò implica che se un nodo di destinazione t appartiene al dominio di un
 nodo di query q ma non soddisfa la condizione AC, può essere rimosso da
 Dom (q).
\begin_inset Separator plain
\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
La seconda fase riguarda l'ordinamento dei nodi del grafo query dove RI
 calcola l'ordine in cui i nodi del grafo query saranno processati durante
 la fase di matching.
 La base dell'algoritmo è quella di definire un possibile ordine all'elaborazion
e dei nodi della query.
 In RI, i nodi di query che hanno entrambi un grado elevato e sono altamente
 connessi ai nodi già presenti nell'ordinamento parziale vengono prima nell'ordi
namento finale.
 Formalmente, sia 
\begin_inset Formula $n$
\end_inset

 il numero di nodi nel grafo query e 
\begin_inset Formula $\mu^{i-1}=(q_{1},q_{2},...,q_{i−1})$
\end_inset

 l'ordinamento parziale fino a (i − 1)-esimo nodo, con i < n.
 Viene anche definito un insieme 
\begin_inset Formula $U^{i−1}$
\end_inset

 di nodi non ancora nell'ordinamento.Per scegliere il nodo successivo dell'ordina
mento, vengono definiti, per ogni nodo del grafo query candidato q, tre
 insiemi:
\end_layout

\begin_deeper
\begin_layout Enumerate
\begin_inset Formula $V_{q,vis}$
\end_inset

 : L'insieme dei nodi in 
\begin_inset Formula $μ^{i−1}$
\end_inset

 e adiacenti a q;
\end_layout

\begin_layout Enumerate
\begin_inset Formula $V_{q,neig}$
\end_inset

 : L'insieme dei nodi in 
\begin_inset Formula $μ^{i−1}$
\end_inset

 che sono adiacenti ad almeno un nodo in 
\begin_inset Formula $U^{i−1}$
\end_inset

 e connessi a q; 
\end_layout

\begin_layout Enumerate
\begin_inset Formula $V_{q,unv}$
\end_inset

 : L'insieme dei nodi adiacenti a q che non sono in 
\begin_inset Formula $μ^{i−1}$
\end_inset

 e non sono adiacenti a nodi in 
\begin_inset Formula $μ^{i−1}$
\end_inset

 .
\end_layout

\begin_layout Standard
Il prossimo nodo nell'ordinamento è quello che rispetta le seguenti condizioni:
 (i) ha il maggior valore di 
\begin_inset Formula $|V_{q,vis}|$
\end_inset

, (ii) nel caso in cui vi siano più match in (i), quello che ha il valore
 maggiore in 
\begin_inset Formula $|V_{q,neig}|$
\end_inset

, (iii) nel caso in cui vi siano più match in (ii), il nodo che ha il valore
 maggiore in 
\begin_inset Formula $|V_{q,unv}|$
\end_inset

.
 Nel caso di più candidati in ogni condizione, il nodo è scelto arbitrariamente.
 Questa definizione può essere espansa con altre condizioni dipendenti dal
 singolo problema, ma in realtà questa fase non verrà modificata dato che
 lo scopo della riduzione dell'albero di ricerca è già pienamente implementata
 anche nel caso di grafi temporali con questa definizione.
\end_layout

\end_deeper
\begin_layout Enumerate
Un problema che sorge nel calcolo degli isomorfismi in sotto-grafi è che
 il processo di corrispondenza può produrre occorrenze ridondanti.
 Al fine di escludere occorrenze ridondanti durante il processo di ricerca
 delle soluzioni e potare l'albero dello spazio di ricerca dalle soluzioni
 ridondanti, RI definisce condizioni di rottura della simmetria in base
 agli identificatori dei nodi del grafo della query.
 Le condizioni di rottura delle simmetrie sono collegati ai concetti di
 automorfismi ed orbite di un grafo query (definiti nella sezione 2.3).
\end_layout

\begin_deeper
\begin_layout Standard
Dati due nodi di query 
\begin_inset Formula $q$
\end_inset

 e 
\begin_inset Formula $q_{0}$
\end_inset

 appartenenti alla stessa orbita, con 
\begin_inset Formula $id(q)<id(q_{0})$
\end_inset

, una condizione di rottura della simmetria è una disuguaglianza della forma
 
\begin_inset Formula $q≺q_{0}$
\end_inset

, indicando che il nodo q deve precedere il nodo 
\begin_inset Formula $q_{0}$
\end_inset

.
 In altre parole, una condizione di rottura della simmetria è una condizione
 che impone un ordine relativo tra due nodi della query appartenenti alla
 stessa orbita.
 
\end_layout

\end_deeper
\begin_layout Enumerate
Ultima e più importante fase è la fase di matching.
 Seguendo l'ordine definito in precedenza dei nodi del grafo query, RI avvia
 il processo di matching per trovare le occorrenze della query all'interno
 del grafo target, utilizzando le condizioni di rottura delle simmetrie
 per l'eliminazione delle ridondondanze man mano che procede.
 La corrispondenza viene eseguita costruendo una funzione di mappatura 
\begin_inset Formula $f:V_{Q}→V_{T}$
\end_inset

 (inizialmente non definita per tutti i nodi di query) ed il match M corrisponde
nte, che inizialmente è vuoto.
 Ogni volta che viene trovata una nuova corrispondenza tra un nodo di query
 q e un nodo di destinazione t, la coppia (q, t) viene aggiunta a M.
 Quando tutti i nodi del grafo query sono stati abbinati, M costituisce
 una nuova corrispondenza di Q in T, quindi può essere aggiunto all'elenco
 delle corrispondenze trovate.
\end_layout

\begin_layout Subsection
Graph matching per grafi temporali
\end_layout

\begin_layout Standard
Durante questo studio verrà fatto un matching su grafi temporali a singoli
 contatti per arco, questo è sia per semplificare la comprensione del problema
 di base che può essere facilmente espanso, sia per stabilire una base solida
 da poter far evolvere in base alle proprie esigenze.
\end_layout

\begin_layout Standard
La parte teorica resterà comunque generale rispetto ad ogni tipo di grafo
 temporale, e considerazioni aggiuntive per più contatti o intervalli per
 arco saranno fate durante le definizioni formali del problema.
\end_layout

\begin_layout Standard
Si deve comunque tenere a mente che l'algoritmo implementato considera soltanto
 grafi con singoli contatti per arco (che è comunque facilmente espandibile
 dal problema di base per più contatti singoli, non così tanto semplice
 da implementare per troppi contatti e per intervalli in generale).
\end_layout

\begin_layout Standard
Si sono utilizzati inoltre singoli contatti perché la maggior parte dei
 lavori visti in campo Temporal Graph Matching utilizzavano o singoli contatti,
 oppure stabilivano delle condizioni molto debilitanti che verranno viste
 di seguito in alcune definizioni date da alcuni autori
\begin_inset CommandInset citation
LatexCommand cite
key "paranjape2017motifs,redmond2016subgraph,Mackey2018"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
In un altro studio per la ricerca di motif su grafi temporali 
\begin_inset CommandInset citation
LatexCommand cite
key "paranjape2017motifs"
literal "false"

\end_inset

, lo studio si concentra principalmente sul definire un processo di conteggio
 basato su confronti edge-driven, cioè confrontando gruppi di archi che
 rispettino una condizione definita nella definizione di temporal motif,
 ma questa definizione è molto simile a quella di cammino, e non lascia
 molto spazio per l'espansione con altri concetti, restando quindi una definizio
ne singola e specifica rispetto al problema del conteggio di motif in un
 grafo (lo studio inoltre si concentra su motif con 3 nodi -3 archi, dedicando
 una piccolissima parte al problema generale).
 
\end_layout

\begin_layout Standard
La definizione di motif data in 
\begin_inset CommandInset citation
LatexCommand cite
key "paranjape2017motifs"
literal "false"

\end_inset

 non permette contatti che possono avere gli stessi tempi, quindi precludendo
 la maggior parte delle reti temporali esistenti che si appoggiano su questa
 caratteristica.
 L'algoritmo utilizzato ordina gli archi e svolge un confronto edge-driven,
 ottimizzato per la ricerca di motif con 3 archi e 3 nodi.
 Il problema generale è veramente poco definito e non sembra essere neanche
 abbastanza generale per essere utilizzato in pratica.
\end_layout

\begin_layout Standard
Per la definizione di isomorfismi su sottografi, 
\begin_inset CommandInset citation
LatexCommand cite
key "redmond2016subgraph"
literal "false"

\end_inset

 non ha dato una definizione concreta, concentrandosi sulla definizione
 di sottografo temporale che rispetti la proprietà di time-respecting, ed
 ha tralasciato la generalizzazione del problema andando direttamente alla
 soluzione adatta al problema che voleva risolvere (quindi considerando
 i sottografi nel grafo target che rispettassero la definizione di time-respecti
ng subgraph, dove ogni cammino doveva essere Time-Respecting, quindi non
 si potevano definire altri tipi di grafi query se non quelli che rispettassero
 questa proprietà).
\end_layout

\begin_layout Standard
La definizione di sub-graph isomorphism su grafi temporali data in 
\begin_inset CommandInset citation
LatexCommand cite
key "redmond2016subgraph"
literal "false"

\end_inset

 si poggia sulla definizione di cammini Time-Respecting, non definendo delle
 strutture temporali effettive da poter utilizzare per i confronti e le
 condizioni utilizzabili durante il matching, mantenendo così la definizione
 abbastanza ambigua e poco generale.
\end_layout

\begin_layout Standard
Ci possono essere tre possibilità per la ricerca di isomorfismi su sotto-grafi
 temporali:
\end_layout

\begin_layout Itemize
Time before topology: estrarre i sotto-grafi temporali che rispettano le
 ipotesi di time-respecting, poi procedere con il matching dei sottografi
 topologico semplice.
 Questo approccio è particolarmente pesante come prestazioni, anche perché
 possono presentarsi ridondanze non trascurabili.
\end_layout

\begin_layout Itemize
Topology before time: svolgere il matching direttamente sulla topologia
 statica del grafo, e poi svolgere delle operazioni sulle componenti temporali
 dei grafi ottenuti, quindi pruning sui sottografi temporali effettivi che
 rispettino le ipotesi, questa è la strategia più semplice, anche perché
 si possono utilizzare direttamente algoritmi di subgraph matching noti,
 per poi gestire come si vuole i risultati ottenuti.
\end_layout

\begin_layout Itemize
Time and topology together: Il controllo temporale ed il matching vengono
 fatti nello stesso momento e quindi, prendendo come esempio un algoritmo
 di Ullman semplice, viene fatto un controllo sul matching di ogni nodo
 e di ogni edge, facendo pruning di soluzioni che non rispettino le ipotesi
 di time-respecting match.
\end_layout

\begin_layout Standard
Di particolare importanza per la definizione di isomorfismi su sotto-grafi
 temporali è la definizione di grafo query e target nel caso temporale,
 dato che questa definizione solitamente non viene data formalmente o dettagliat
amente dagli autori, e quindi molto spesso lascia molti dubbi.
\end_layout

\begin_layout Standard
In questo studio, viene visto il grafo temporale query come un pattern temporale
 da ricercare.
 Questo significa che i tempi dei contatti non sono importanti, ma i tipi
 di propagazioni che producono con le conseguenti impronte temporali sono
 al centro della ricerca degli isomorfismi.
\end_layout

\begin_layout Standard
Per la definizione sono state scelte solo due classi possibili per la classifica
zione di una propagazione, però durante l'implementazione reale sono state
 utilizzate 3 classi (o più durante il confronto degli archi), dipendenti
 dalla latenza della propagazione (minore di 0, maggiore di 0 ma minore
 del 
\begin_inset Formula $\delta$
\end_inset

, maggiore del delta).
\end_layout

\begin_layout Standard
Durante la ricerca di possibilità utilizzabili per effettuare il matching
 in modo consistente con il problema, si sono trovati due metodi principali
 da cui è possibile derivare altre metodologie più articolate:
\end_layout

\begin_layout Itemize
Utilizzare una trasformazione del grafo temporale query in un grafo statico,
 sempre secondo i pattern di trasformazione che sono state definite e verranno
 approfondite praticamente nel prossimo capitolo, e poi utilizzare questo
 grafo statico per il submatching sul grafo temporale target.
\end_layout

\begin_layout Itemize
svolgere dei confronti e un matching basato su confronti complessi, alternando
 e parallelizzando confronti e computazione sia sulla struttura statica
 che temporale di ogni nodo e dell'insieme.
\end_layout

\begin_layout Standard
Per implementare la strategia di 
\begin_inset Flex Emphasize
status open

\begin_layout Plain Layout
topology before time
\end_layout

\end_inset

 bisogna semplicemente fare il matching sulla struttura statica del grafo
 target e poi fare il controllo sulla struttura dinamica, per esempio svolgendo
 un controllo sui nodi mappati e sui tempi di contatto di ogni nodo, in
 modo che rispettino le regole di time-respecting path definite.
\end_layout

\begin_layout Standard
Per implementare la strategia di 
\begin_inset Flex Emphasize
status open

\begin_layout Plain Layout
Time and topology together
\end_layout

\end_inset

, il ragionamento dovrebbe essere abbastanza semplice e si concentrerebbe
 principalmente sulla fase di matching vera e propria (prendendo ad esempio
 Ullman).
\end_layout

\begin_layout Standard
Dopo la definizione del problema e dei punti chiave sul matching di grafi
 temporali, non dovrebbe essere difficile utilizzare le ipotesi di time-respecti
ng path e contatti per ampliare e implementare regole di look-ahead e rollback.
\end_layout

\begin_layout Standard
Una possilbilità di risoluzione per gli algoritmi di subgraph matching di
 grafi temporali utilizzata da altri autori 
\begin_inset CommandInset citation
LatexCommand cite
key "paranjape2017motifs,Mackey2018"
literal "false"

\end_inset

 è la conversione del grafo temporale in una o più forme statiche indotte
 che permettano il matching statico della rete, in particolare le strategie
 utilizzate introducono dei metodi molto semplici nella conversione, che
 contano semplicemente gli archi che rispettino una o più condizioni temporali,
 di seguito un possibile algoritmo di conversione abbastanza semplice:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithm} 	
\end_layout

\begin_layout Plain Layout

	
\backslash
caption{InducedStaticGraphFromTemporal(G)}
\end_layout

\begin_layout Plain Layout

	
\backslash
begin{algorithmic}[1]
\end_layout

\begin_layout Plain Layout

		
\backslash
Function{InducedStaticGraphFromTemporal}{$G$,$
\backslash
delta$}
\end_layout

\begin_layout Plain Layout

		
\backslash
State edges sorted in sequence, select a node that have the less time of
 contact
\end_layout

\begin_layout Plain Layout

		
\backslash
State BFS modified with control over temporal attribute and $
\backslash
delta$, add edge to Gtemp if conditions are satisfied
\end_layout

\begin_layout Plain Layout

		
\backslash
For {$tedge 
\backslash
in E_{Gtemp}$}
\end_layout

\begin_layout Plain Layout

		
\backslash
State SG.addedge(tedge.s,tedge.d)
\end_layout

\begin_layout Plain Layout

		
\backslash
EndFor
\end_layout

\begin_layout Plain Layout

		
\backslash
State 
\backslash
Return SG
\end_layout

\begin_layout Plain Layout

		
\backslash
EndFunction
\end_layout

\begin_layout Plain Layout

	
\backslash
end{algorithmic}  	
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
e sotto un esempio di conversione di grafo temporale a più contatti:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
usetikzlibrary{arrows.meta}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}     
\end_layout

\begin_layout Plain Layout

	
\backslash
node[shape=circle,draw=black] (A) at (0,0) {A};     
\end_layout

\begin_layout Plain Layout

	
\backslash
node[shape=circle,draw=black] (B) at (0,3) {B};     
\end_layout

\begin_layout Plain Layout

	
\backslash
node[shape=circle,draw=black] (C) at (2.5,4) {C};     
\end_layout

\begin_layout Plain Layout

	
\backslash
node[shape=circle,draw=black] (D) at (2.5,1) {D};     
\end_layout

\begin_layout Plain Layout

	
\backslash
node[shape=circle,draw=black] (E) at (2.5,-3) {E};     
\end_layout

\begin_layout Plain Layout

	
\backslash
node[shape=circle,draw=black] (F) at (5,3) {F} ;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout


\backslash
begin{scope}[>={Stealth[black]},
\end_layout

\begin_layout Plain Layout

			  every node/.style={fill=white,circle},
\end_layout

\begin_layout Plain Layout

              every edge/.style={draw=black,very thick}]
\end_layout

\begin_layout Plain Layout

    
\backslash
path [->] (A) edge node {$1$,$5$,$7$} (B);     
\end_layout

\begin_layout Plain Layout

	
\backslash
path [->](B) edge node {$3$} (C);     
\end_layout

\begin_layout Plain Layout

	
\backslash
path [->](A) edge node {$4$} (D);     
\end_layout

\begin_layout Plain Layout

	
\backslash
path [->](D) edge node {$3$,$7$,$11$} (C);
\end_layout

\begin_layout Plain Layout

    
\backslash
path [->](A) edge node {$3$} (E);
\end_layout

\begin_layout Plain Layout

    
\backslash
path [->](D) edge node {$3$} (E);
\end_layout

\begin_layout Plain Layout

    
\backslash
path [->](D) edge node {$33$} (F);
\end_layout

\begin_layout Plain Layout

    
\backslash
path [->](C) edge node {$42$,$50$} (F);
\end_layout

\begin_layout Plain Layout

    
\backslash
path [->](E) edge node {$8$,$50$} (F); 
\end_layout

\begin_layout Plain Layout


\backslash
end{scope}  
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (Am) at (7,0) {Am};     
\end_layout

\begin_layout Plain Layout

	
\backslash
node[shape=circle,draw=black] (Bm) at (7,3) {Bm};     
\end_layout

\begin_layout Plain Layout

	
\backslash
node[shape=circle,draw=black] (Cm) at (9.5,4) {Cm};     
\end_layout

\begin_layout Plain Layout

	
\backslash
node[shape=circle,draw=black] (Dm) at (9.5,1) {Dm};     
\end_layout

\begin_layout Plain Layout

	
\backslash
node[shape=circle,draw=black] (Em) at (9.5,-3) {Em};     
\end_layout

\begin_layout Plain Layout

	
\backslash
node[shape=circle,draw=black] (Fm) at (12,3) {Fm} ;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout


\backslash
begin{scope}[>={Stealth[black]},
\end_layout

\begin_layout Plain Layout

			  every node/.style={fill=white,circle},
\end_layout

\begin_layout Plain Layout

              every edge/.style={draw=black,very thick}]
\end_layout

\begin_layout Plain Layout

    
\backslash
path [->] (Am) edge  (Bm);     
\end_layout

\begin_layout Plain Layout

	
\backslash
path [->](Bm) edge (Cm);     
\end_layout

\begin_layout Plain Layout

	
\backslash
path [->](Am) edge  (Dm);     
\end_layout

\begin_layout Plain Layout

	
\backslash
path [->](Dm) edge  (Cm);
\end_layout

\begin_layout Plain Layout

    
\backslash
path [->](Am) edge  (Em);
\end_layout

\begin_layout Plain Layout

    
\backslash
path [->](Dm) edge  (Em);
\end_layout

\begin_layout Plain Layout

    
\backslash
path [->](Em) edge (Fm); 
\end_layout

\begin_layout Plain Layout


\backslash
end{scope} 
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Si è scelto un intervallo temporale di attivazione 
\begin_inset Formula $\delta=10$
\end_inset

.
 Come si può facilmente notare, si è ottenuto un solo grafo statico, questa
 non è sempre la situazione, specialmente quando si ha il bisogno di tenere
 conto di tutti i pattern di attivazione che avvengono nel grafo temporale,
 quindi la soluzione presentata è abbastanza temporanea e non porterebbe
 risultati concreti (il problema resta comunque il caso di archi con più
 contatti).
\end_layout

\begin_layout Standard
Alla fine viene comunque utilizzato un approccio ibrido di 
\begin_inset Flex Emphasize
status open

\begin_layout Plain Layout
Time and Topology Together
\end_layout

\end_inset

, dove il controllo temporale è fatto dinamicamente insieme al controllo
 di struttura topologica.
\end_layout

\begin_layout Standard
Viene utilizzato un algoritmo che non si serve di regole di look-ahead troppo
 complicate che andrebbero a confrontare una quantità di strutture temporali
 non indifferente che è RI esposto precedentemente modificato per il controllo
 della similarità tra nodi e delle strutture temporali per nodo durante
 varie fasi.
\end_layout

\begin_layout Standard
È possibile comunque espandere altri concetti, come per esempio le fasi
 di preprocessing di RI di calcolo dei compatibility domains e dell'ordine
 dei nodi del grafo query per la fase di matching 
\begin_inset CommandInset citation
LatexCommand cite
key "micale2020multiri,bonnici2013subgraph"
literal "false"

\end_inset

, sempre utilizzando le definizioni definite precedentemente.
\end_layout

\begin_layout Standard
Per esempio, per il calcolo dei compatibility domains, si può fare comunque
 un controllo sul grado del nodo, e si può alternare ad un controllo sui
 tempi di contatto per ogni arco uscente dal nodo, o direttamente un controllo
 dell'impronta del nodo da analizzare.
\end_layout

\begin_layout Standard
Infatti è questa la soluzione che è stata adottata, in aggiunta a vari controlli
 sul grado e sulle simmetrie, vi è stato aggiunto un controllo per la compatibil
ità di un nodo del grafo temporale target con uno del grafo query, sfruttando
 le impronte dei due e vedendo se 
\begin_inset Formula $v_{query}\simeq v_{target}$
\end_inset

, e quindi procedendo all'aggiunta del nodo tra i nodi candidati per il
 mapping.
\end_layout

\begin_layout Standard
Per il calcolo dell'ordinamento dei nodi del grafo query, si potrebbe fare
 un ordinamento locale (rispetto al grado dei nodi) ed in seguito un ordinamento
 sul numero di contatti per arco (potrebbero sorgere dei problemi che verranno
 visti nel prossimo capitolo).
\end_layout

\begin_layout Standard
Nella implementazione effettiva il calcolo dell'ordinamento non è stato
 modificato, anche perché potrebbe portare a comportamenti particolari e
 poco prevedibili (nodo con molti contatti entranti e pochi uscenti), quindi
 si è voluto lasciare inalterato l'algoritmo di base basato sul grado di
 un nodo.
\end_layout

\begin_layout Standard
Una parte importantissima che è stata cambiata è la fase del controllo degli
 archi di un possibile nodo da mappare, a cui è stato aggiunto un controllo
 aggiuntivo su alcune caratteristiche derivate dall'arco (molto simile al
 calcolo della struttura temporale, ma in realtà più incentrato alla struttura
 dei singoli archi rispetto a quello preso in input, che dovrebbe essere
 l'arco da mappare, che deve quindi dare lo stesso tipo di struttura temporale
 alternativa derivata), la funzionalità da cambiare per il controllo degli
 archi (
\begin_inset Flex Emphasize
status open

\begin_layout Plain Layout
edgeCheck
\end_layout

\end_inset

) svolge la seguente funzione:
\end_layout

\begin_layout Standard
Sia 
\begin_inset Formula $t\in G_{T}$
\end_inset

 e 
\begin_inset Formula $q\in G_{Q}$
\end_inset

 e si voglia sapere se sia possibile mappare t con q, associandolo al match
 parziale.
 Sia 
\begin_inset Formula $M={(t1,q1),(t2,q2),…,(tk,qk)}$
\end_inset

 il mapping parziale ottenuto fino al momento del controllo del possibile
 mapping tra il nodo 
\begin_inset Formula $q$
\end_inset

 ed il candidato 
\begin_inset Formula $t$
\end_inset

.
\end_layout

\begin_layout Standard
La funzione edgeCheck controlla che nel caso in cui 
\begin_inset Formula $q$
\end_inset

 sia collegato al nodo 
\begin_inset Formula $q_{i}$
\end_inset

 in M, allora anche 
\begin_inset Formula $t$
\end_inset

 deve essere collegato con il nodo 
\begin_inset Formula $t_{i}$
\end_inset

 già contenuto nel mapping parziale e mappato con il nodo del grafo query
 
\begin_inset Formula $q_{i}$
\end_inset

.
 Se questo controllo è vero per tutti i 
\begin_inset Formula $q_{i}$
\end_inset

 già mappati, allora edgeCheck ritorna true, che significa che il nodo t
 può essere mappato al nodo q.
\end_layout

\begin_layout Standard
Quindi, se si vuole aggiungere la componente temporale durante il controllo,
 basta prendere l'arco e controllare che il nodo collegato sia simile al
 nodo nel mapping (quindi confrontando le impronte oppure altre informazioni
 temporali dipendenti dall'arco).
\end_layout

\begin_layout Standard
Le nuove informazioni temporali da confrontare vengono date dall'arco da
 mappare, che ha un singolo tempo, e definisce la struttura completa di
 tutte le informazioni possibili per vedere se l'arco si può effettivamente
 mappare al conseguente candidato (cioè i nodi si possono mappare).
\end_layout

\begin_layout Standard
Non è stato utilizzato un controllo di impronta diretto perchè non stabilisce
 una struttura ben definita temporalmente nel caso in cui vi siano solo
 nodi entranti e solo nodi uscenti.
\end_layout

\begin_layout Standard
Dunque nel controllo sull’arco (q,qi) bisogna verificare che:
\end_layout

\begin_layout Itemize
(t,ti) è un arco del target 
\end_layout

\begin_layout Itemize
I vincoli temporali per (t,ti) sono soddisfatti.
\end_layout

\begin_layout Standard
Le implementazioni di tutto ciò che è stato descritto e di questo controllo
 in particolare sono disponibili online (il codice è disponibile sia in
 Java che in Scala nel mio github 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://github.com/josura/university-sad/tree/master/tesi/realtesi
\end_layout

\end_inset

).
\end_layout

\begin_layout Example
In questo esempio viene vista una istanza di isomorfismi su sottografi temporali
, il grafo query e target sono i seguenti:
\end_layout

\begin_layout Example
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
usetikzlibrary{arrows.meta}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}     
\end_layout

\begin_layout Plain Layout

	
\backslash
node[shape=circle,draw=black] (0) at (0,0) {0};     
\end_layout

\begin_layout Plain Layout

	
\backslash
node[shape=circle,draw=black] (1) at (0,3) {1};     
\end_layout

\begin_layout Plain Layout

	
\backslash
node[shape=circle,draw=black] (2) at (2.5,4) {2};     
\end_layout

\begin_layout Plain Layout

	
\backslash
node[shape=circle,draw=black] (3) at (2.5,1) {3};       
\end_layout

\begin_layout Plain Layout

	
\backslash
node[shape=circle,draw=black] (4) at (5,0) {4} ;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout


\backslash
begin{scope}[>={Stealth[black]},
\end_layout

\begin_layout Plain Layout

			  every node/.style={fill=white,circle},
\end_layout

\begin_layout Plain Layout

              every edge/.style={draw=black,very thick}]
\end_layout

\begin_layout Plain Layout

    
\backslash
path [->] (0) edge node {$12$} (1);     
\end_layout

\begin_layout Plain Layout

	
\backslash
path [->](1) edge node {$13$} (2);     
\end_layout

\begin_layout Plain Layout

	
\backslash
path [->](0) edge node {$14$} (3);     
\end_layout

\begin_layout Plain Layout

	
\backslash
path [->](3) edge node {$13$} (2);
\end_layout

\begin_layout Plain Layout

    
\backslash
path [->](3) edge node {$43$} (4);
\end_layout

\begin_layout Plain Layout


\backslash
end{scope}  
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
node[shape=circle,draw=black] (a) at (7,0) {0};     
\end_layout

\begin_layout Plain Layout

	
\backslash
node[shape=circle,draw=black] (b) at (7,3) {1};     
\end_layout

\begin_layout Plain Layout

	
\backslash
node[shape=circle,draw=black] (c) at (9.5,4) {2};     
\end_layout

\begin_layout Plain Layout

	
\backslash
node[shape=circle,draw=black] (d) at (9.5,1) {3};     
\end_layout

\begin_layout Plain Layout

	
\backslash
node[shape=circle,draw=black] (e) at (9.5,-3) {4};     
\end_layout

\begin_layout Plain Layout

	
\backslash
node[shape=circle,draw=black] (f) at (12,0) {5} ;
\end_layout

\begin_layout Plain Layout

	
\backslash
node[shape=circle,draw=black] (g) at (13,4) {6} ;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout


\backslash
begin{scope}[>={Stealth[black]},
\end_layout

\begin_layout Plain Layout

			  every node/.style={fill=white,circle},
\end_layout

\begin_layout Plain Layout

              every edge/.style={draw=black,very thick}]
\end_layout

\begin_layout Plain Layout

    
\backslash
path [->] (a) edge node {$1$} (b);     
\end_layout

\begin_layout Plain Layout

	
\backslash
path [->](b) edge node {$3$} (c);     
\end_layout

\begin_layout Plain Layout

	
\backslash
path [->](a) edge node {$4$} (d);     
\end_layout

\begin_layout Plain Layout

	
\backslash
path [->](d) edge node {$3$} (c);
\end_layout

\begin_layout Plain Layout

    
\backslash
path [->](a) edge node {$3$} (e);
\end_layout

\begin_layout Plain Layout

    
\backslash
path [->](d) edge node {$3$} (e);
\end_layout

\begin_layout Plain Layout

    
\backslash
path [->](d) edge node {$33$} (f);
\end_layout

\begin_layout Plain Layout

    
\backslash
path [->](c) edge node {$42$} (f);
\end_layout

\begin_layout Plain Layout

    
\backslash
path [->](e) edge node {$8$} (f); 
\end_layout

\begin_layout Plain Layout

    
\backslash
path [->](g) edge node {$14$} (f); 
\end_layout

\begin_layout Plain Layout

    
\backslash
path [->](g) edge node {$8$} (c); 
\end_layout

\begin_layout Plain Layout


\backslash
end{scope}  
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\end_layout

\begin_layout Example
I domini di compatibilità dei nodi della query sono i seguenti:
\end_layout

\begin_layout Example
\begin_inset Formula $Dom(0)=\{0,6\}$
\end_inset


\end_layout

\begin_layout Example
\begin_inset Formula $Dom(1)=\{1,4\}$
\end_inset


\end_layout

\begin_layout Example
\begin_inset Formula $Dom(2)=\{2,4,5\}$
\end_inset


\end_layout

\begin_layout Example
\begin_inset Formula $Dom(3)=\{3,5\}$
\end_inset


\end_layout

\begin_layout Example
\begin_inset Formula $Dom(4)=\{1,2,3,4,5\}$
\end_inset


\end_layout

\begin_layout Example
Si è scelto un 
\begin_inset Formula $\delta=10$
\end_inset

 e sono state definite le classi di appartenenza di una propagazione 
\begin_inset Formula ${notTimeRespecting,\delta-TimeRespecting,\delta-notTimeRespecting}$
\end_inset


\end_layout

\begin_layout Example
Le impronte temporali di ogni nodo del grafo temporale query sono le seguenti:
\end_layout

\begin_layout Example
\begin_inset Formula $impronta_{0}=\{(notTimeRespecting,0),(\delta-TimeRespecting,0),(\delta-notTimeRespecting,0)\}$
\end_inset


\end_layout

\begin_layout Example
\begin_inset Formula $impronta_{1}=\{(notTimeRespecting,0),(\delta-TimeRespecting,1),(\delta-notTimeRespecting,0)\}$
\end_inset


\end_layout

\begin_layout Example
\begin_inset Formula $impronta_{2}=\{(notTimeRespecting,0),(\delta-TimeRespecting,0),(\delta-notTimeRespecting,0)\}$
\end_inset


\end_layout

\begin_layout Example
\begin_inset Formula $impronta_{3}=\{(notTimeRespecting,1),(\delta-TimeRespecting,0),(\delta-notTimeRespecting,1)\}$
\end_inset


\end_layout

\begin_layout Example
\begin_inset Formula $impronta_{4}=\{(notTimeRespecting,0),(\delta-TimeRespecting,0),(\delta-notTimeRespecting,0)\}$
\end_inset


\end_layout

\begin_layout Example
Invece le impronte temporali di ogni nodo del grafo temporale target sono
 le seguenti:
\end_layout

\begin_layout Example
\begin_inset Formula $impronta_{0}=\{(notTimeRespecting,0),(\delta-TimeRespecting,0),(\delta-notTimeRespecting,0)\}$
\end_inset


\end_layout

\begin_layout Example
\begin_inset Formula $impronta_{1}=\{(notTimeRespecting,0),(\delta-TimeRespecting,1),(\delta-notTimeRespecting,0)\}$
\end_inset


\end_layout

\begin_layout Example
\begin_inset Formula $impronta_{2}=\{(notTimeRespecting,0),(\delta-TimeRespecting,0),(\delta-notTimeRespecting,3)\}$
\end_inset


\end_layout

\begin_layout Example
\begin_inset Formula $impronta_{3}=\{(notTimeRespecting,1),(\delta-TimeRespecting,0),(\delta-notTimeRespecting,2)\}$
\end_inset


\end_layout

\begin_layout Example
\begin_inset Formula $impronta_{4}=\{(notTimeRespecting,0),(\delta-TimeRespecting,2),(\delta-notTimeRespecting,0)\}$
\end_inset


\end_layout

\begin_layout Example
\begin_inset Formula $impronta_{5}=\{(notTimeRespecting,0),(\delta-TimeRespecting,0),(\delta-notTimeRespecting,0)\}$
\end_inset


\end_layout

\begin_layout Example
\begin_inset Formula $impronta_{6}=\{(notTimeRespecting,1),(\delta-TimeRespecting,0),(\delta-notTimeRespecting,1)\}$
\end_inset


\end_layout

\begin_layout Example
Durante la fase di matching si passa dai possibili candidat, si controllano
 gli archi e le impronte, e si continua la mappatura fino a quando si sono
 trovate tutte le occorrenze.
\end_layout

\begin_layout Example
Alla fine il numero di occorrenze del grafo query nel grafo target in questo
 caso è 1.
\end_layout

\begin_layout Subsection
Definizioni 
\end_layout

\begin_layout Definition
(Sub Graph matching su grafi statici).
 Un grafo G1 è isomorfo ad un sotto-grafo di un grafo G2 se e solo se esiste
 una corrispondenza uno a uno tra i nodi del sotto-grafo di G2 e G1 che
 preserva l'adiacenza, più formalmente 
\begin_inset Formula $\exists f:V_{G1}\rightarrow V_{G2}|(s,d)\in E_{G1}\implies(f(s),f(d))\in E_{G2}$
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Definition
(Sub Graph matching su grafi temporali a contatti).
 Un grafo Temporale G1 è isomorfo ad un sotto-grafo di un grafo Temporale
 G2 se e solo se esiste una corrispondenza uno a uno tra i nodi del sotto-grafo
 di G2 e G1 che preserva l'adiacenza, più formalmente 
\begin_inset Formula $\exists f:V_{G1}\rightarrow V_{G2}|(s,d)\in E_{G1}\implies(f(s),f(d))\in E_{G2}$
\end_inset

 e se il nodo target da mappare ha la stessa struttura temporale del nodo
 query, formalmente 
\begin_inset Formula $s\equiv f(s)$
\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
Per la definizione è stata sfruttata la relazione di equivalenza di struttura
 temporale perché il sotto-grafo non ha tutti gli archi compresi tra i nodi
 del sottografo, in seguito sarà data una definizione con la similarità
 che toglie questo limite.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Definition
(isomorfismo tra grafi temporali e sotto-grafi temporali).
 Un grafo temporale GT1 è isomorfico ad un sotto-grafo temporale di un grafo
 Temporale GT2 se e solo se esiste una corrispondenza uno a uno tra i nodi
 del sotto-grafo temporale di GT2 e GT1 che preserva l'adiacenza ed il sotto-gra
fo risultante (come sottoinsieme dei nodi e degli archi del grafo target)
 abbia tutti i nodi mappati con la stessa struttura temporale di quelli
 del grafo query a cui vengono mappati, cioè i nodi del grafo query sono
 simili ai nodi del grafo target mappato.
\end_layout

\begin_deeper
\begin_layout Standard
Definendo l'isomorfismo di sotto-grafi tramite similarità è possibile svolgere
 un matching senza troppi problemi semplicemente confrontando le impronte
 dei singoli nodi che sono mappati.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Definition
(automorfismo di un grafo temporale).
 Dato un grafo temporale 
\begin_inset Formula $G_{t}=(V,E)$
\end_inset

, un automorfismo di 
\begin_inset Formula $G_{t}$
\end_inset

 è una permutazione ρ dell'insieme dei nodi di V che rispetta le seguenti
 condizioni:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $∀u,v∈V:(u,v,t)∈E⇔(ρ(u),ρ(v),t')∈E$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $∀u,v∈V:u\equiv v⇔ρ(u)\equivρ(v)$
\end_inset


\end_layout

\begin_layout Standard
In altre parole, un automorfismo è un riarrangiamento dell'insieme di nodi
 che conserva la struttura di un grafo.
 Il risultato dell'applicazione di un automorfismo è un nuovo grafo 
\begin_inset Formula $G_{0}=(V,E)$
\end_inset

, ottenuto da G permutando gli identificatori dei suoi nodi in base a ρ.
 Si dice che 
\begin_inset Formula $G_{0}$
\end_inset

 sia automorfico per G.
 
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Definition
(Matrice degli automorfismi).
 Dato un grafo 
\begin_inset Formula $G=(V,E)$
\end_inset

 with k nodes 
\begin_inset Formula $v_{1},v_{2},...,v_{k}$
\end_inset

 e h automorfismi 
\begin_inset Formula $ρ_{1},ρ_{2},...,ρ_{h}$
\end_inset

 .
 La matrice degli automorfismi A, è una matrice contenente h righe e k colonne,
 dove 
\begin_inset Formula $A[i,j]=ρ_{i}(v_{j})$
\end_inset

.
\end_layout

\begin_deeper
\begin_layout Standard
La definizione è la stessa di grafo statico, dato che la componente temporale
 non inficia direttamente questa definizione.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Definition
(Orbite di un grafo).
 Data una matrice degli automorfismi A, per una certa colonna della matrice,
 
\begin_inset Formula $A[,j]$
\end_inset

, Il suo set di nodi è un orbita di G.
 Si indica con 
\begin_inset Formula $Orb(u)$
\end_inset

 l'orbita a cui appartiene il nodo u.
\end_layout

\begin_deeper
\begin_layout Standard
Questa definizione non cambia per grafi temporali.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Subsection
Problemi con gli isomorfismi e la definizione di grafo query e target
\end_layout

\begin_layout Standard
Come già brevemente descritto precedentemente durante la definizione del
 problema di isomorfismi su sotto-grafi temporali, sorgono problemi non
 indifferenti nell'interpretazione del grafo query, che è stato definito
 come il pattern temporale da trovare nel grafo target.
\end_layout

\begin_layout Standard
Cosa trovare nel caso di più contatti per arco? Come fare il matching e
 come adattarlo in base alle esigenze? Come adattare il modello nel caso
 di intervalli?
\end_layout

\begin_layout Standard
Tutte queste ed altre domande hanno risposte dipendenti dal caso di studio
 che si vuole portare, quindi bisogna adattare il modello di base sulla
 forma del sistema che si sta cercando di catturare o simulare.
 
\end_layout

\begin_layout Standard
Per esempio l'implementazione adottata durante questo studio della ricerca
 degli isomorfismi su grafi temporali trova grafi che abbiano nodi con la
 stessa struttura temporale o che siano simili, inoltre vengono aggiunte
 classi aggiuntive per la classificazione delle propagazioni che non rispettano
 le condizioni e che sono maggiori o minori del tempo di contatto iniziale.
 
\end_layout

\begin_layout Standard
Questa caratteristica può essere fraintendibile e poco consona al significato
 di classificazione di propagazione dato precedentemente che classifica
 soltanto in due categorie, ma in realtà il sistema è stato progettato così
 proprio per fare vedere come l'implementazione non è sempre la stessa in
 base alle condizioni basilari stabilite, e che la maggior parte delle volte
 il framework per il matching si deve adattare per ricoprire bene le esigenze
 del singolo problema, come già detto molte volte.
\end_layout

\begin_layout Standard
Nel caso di soluzione di matching basata su 
\begin_inset Flex Emphasize
status open

\begin_layout Plain Layout
Time and topology together
\end_layout

\end_inset

 , la modifica dell'algoritmo di matching potrebbe portare all'inutilità
 della fase di pre-processing, in particolare l'ordinamento dei nodi della
 query (perchè in alcuni casi ci sarebbe l'obbligo di iniziare dal nodo
 che ha l'edge con il tempo minore), anche se questo rischio è discutibile
 e bisognerebbe provare una implementazione vera e propria.
\end_layout

\begin_layout Standard
Dato che non vi è una definizione univoca e standard del problema di isomorfismi
 su grafi (e di tecniche utilizzabili su grafi temporali in generale), molto
 spesso gli autori non definiscono un framework di base da utilizzare per
 la definizione del problema, ma costruiscono una soluzione specifica del
 singolo problema secondo definizioni abbastanza strette e che lasciano
 poca possibilità di espansione.
\end_layout

\begin_layout Standard
Per la ricerca di pattern temporali il framework definito precedentemente
 potrebbe non essere adatto, dato che trova sotto-grafi con una specifica
 struttura temporale, quindi bisogna sempre adattare la sottostruttura al
 caso unico.
\end_layout

\begin_layout Standard
Nella prossima sezione verranno visti gli algoritmi e le considerazioni
 sull'implementazione per la ricerca di isomorfismi su sotto-grafi temporali.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Algoritmi e implementazione
\end_layout

\begin_layout Standard
Di seguito gli algoritmi utilizzati per il calcolo delle funzioni di base
 che serviranno per il graph matching:
\end_layout

\begin_layout Standard
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithm} 	
\end_layout

\begin_layout Plain Layout

	
\backslash
caption{classifyPropagation(prop,$
\backslash
delta$)}
\end_layout

\begin_layout Plain Layout

	
\backslash
hspace*{
\backslash
algorithmicindent} 
\backslash
textbf{Input: } 
\backslash
text{$prop$: propagation to classify,}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		
\backslash
hspace*{2,1cm}
\backslash
text{$
\backslash
delta$: conditional parameter used to classify propagations}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	
\backslash
hspace*{
\backslash
algorithmicindent} 
\backslash
textbf{Output: } 
\backslash
text{the type of the propagation $prop$}
\end_layout

\begin_layout Plain Layout

	
\backslash
begin{algorithmic}[1]
\end_layout

\begin_layout Plain Layout

		
\backslash
Function{classifyPropagation}{prop,$
\backslash
delta$}
\end_layout

\begin_layout Plain Layout

		
\backslash
If {$0 < $prop$.
\backslash
Delta < 
\backslash
delta$}     
\end_layout

\begin_layout Plain Layout

			
\backslash
State 
\backslash
Return {timeRespecting}
\end_layout

\begin_layout Plain Layout

		
\backslash
Else
\end_layout

\begin_layout Plain Layout

			
\backslash
State 
\backslash
Return {notTimeRespecting}
\end_layout

\begin_layout Plain Layout

		
\backslash
EndIf
\end_layout

\begin_layout Plain Layout

		
\backslash
EndFunction
\end_layout

\begin_layout Plain Layout

	
\backslash
end{algorithmic}  	
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Questa funzione è particolarmente importante ai fini del calcolo delle impronte,
 in quanto classifica le singole propagazioni per farle rientrare nella
 classe a cui dovrebbero appartenere.
\end_layout

\begin_layout Standard
In questo caso, come definito precedentemente, vengono utilizzate solo due
 classi per facilitare la comprensione, ma nel codice le classi definite
 sono tre.
 
\end_layout

\begin_layout Standard
Sostanzialmente per ogni propagazione passata a riga di comando vengono
 controllate le condizioni stabilite dalle possibili classi che si possono
 ottenere, quindi viene ritornato il tipo di classe di appartenenza.
 Per espandere questa funzione con altri casi e classi ben definite, basta
 aggiungere le condizioni ed i condizionali aggiuntivi, implementandoli
 tramite uno switch case, oppure trattando la propagazione come un oggetto
 ed assegnando uno stato (la classe di appartenenza) ogni volta che una
 propagazione venga creata.
\end_layout

\begin_layout Standard
Questa funzione è molto semplice e poteva essere direttamente sostituita
 alle parti di codice che la richiedono, ma si è lasciata indipendente data
 la sua natura dipendente dalle classi definibili e per refattorizzazione
 dato che viene utilizzata anche in altri punti del codice (che non vengono
 visti dato che non vengono utilizzati per il matching effettivo).
\end_layout

\begin_layout Standard
L'ultima possibilità non è stata implementata dato che non si sono utilizzate
 le propagazioni effettive ma coppie di archi, e tenere delle strutture
 aggiuntive comportava spazio extra relativamente ridondante , e dato che
 la classificazione non svolge calcoli complessi ma delle semplici decisioni
 si è lasciata questa scelta che non aggiunge quasi nulla alla complessità
 effettiva del problema.
\end_layout

\begin_layout Standard
Notare che la funzione lavora per contatti, ma non fa distinzione tra più
 contatti di un singolo arco o di archi diversi, quindi è indipendente dal
 grafo temporale a contatti utilizzato.
\end_layout

\begin_layout Standard
Il caso di grafo ad intervalli è leggermente differente, ma i principi sono
 comunque quelli descritti precedentemente durante la definizione del problema.
\end_layout

\begin_layout Standard
Nel caso di grafo temporale ad intervalli l'algoritmo è il seguente:
\end_layout

\begin_layout Standard
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithm} 	
\end_layout

\begin_layout Plain Layout

	
\backslash
caption{classifyPropagationInterval(prop,$
\backslash
delta$)}
\end_layout

\begin_layout Plain Layout

	
\backslash
hspace*{
\backslash
algorithmicindent} 
\backslash
textbf{Input: } 
\backslash
text{$prop$: propagation to classify,}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		
\backslash
hspace*{2,1cm}
\backslash
text{$
\backslash
delta$: conditional parameter used to classify propagations}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	
\backslash
hspace*{
\backslash
algorithmicindent} 
\backslash
textbf{Output: } 
\backslash
text{the type of the propagation $prop$}
\end_layout

\begin_layout Plain Layout

	
\backslash
begin{algorithmic}[1]
\end_layout

\begin_layout Plain Layout

		
\backslash
Function{classifyPropagationInterval}{prop,$
\backslash
delta$}
\end_layout

\begin_layout Plain Layout

		
\backslash
If {$ $prop$.interval 
\backslash
neq 
\backslash
emptyset$}     
\end_layout

\begin_layout Plain Layout

			
\backslash
State 
\backslash
Return {timeRespecting}
\end_layout

\begin_layout Plain Layout

		
\backslash
Else
\end_layout

\begin_layout Plain Layout

			
\backslash
State 
\backslash
Return {notTimeRespecting}
\end_layout

\begin_layout Plain Layout

		
\backslash
EndIf
\end_layout

\begin_layout Plain Layout

		
\backslash
EndFunction
\end_layout

\begin_layout Plain Layout

	
\backslash
end{algorithmic}  	
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Notare come sia possibile fare un confronto semplice con l'insieme vuoto
 per vedere se la propagazione sia effettivamente Time-Respecting o no,
 questo solo grazie alla definizione di 
\begin_inset Flex Emphasize
status open

\begin_layout Plain Layout
interval
\end_layout

\end_inset

 nella propagazione, che ingloba all'interno l'intersezione ricorsiva con
 le propagazioni differenti (che comunque resta ambigua ma questo fattore
 verrà tralasciato dato che questo studio si concentra su un implementazione
 a contatti).
\end_layout

\begin_layout Standard
Di seguito la funzione che utilizza la classificazione di una propagazione
 (per grafo a contatti) per il calcolo dell'impronta temporale di un nodo:
\end_layout

\begin_layout Standard
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithm} 	
\end_layout

\begin_layout Plain Layout

	
\backslash
caption{temporalFingerprint($G_t$,node,$
\backslash
delta$)}
\end_layout

\begin_layout Plain Layout

	
\backslash
hspace*{
\backslash
algorithmicindent} 
\backslash
textbf{Input: } 
\backslash
text{$G_{t}$: Temporal Graph of the node,}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		
\backslash
hspace*{2,1cm}
\backslash
text{$node$: is the node to test, }
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		
\backslash
hspace*{2,1cm}
\backslash
text{$
\backslash
delta$: is the conditional parameter used to classify propagations}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	
\backslash
hspace*{
\backslash
algorithmicindent} 
\backslash
textbf{Output: } 
\backslash
text{the Temporal fingerprint of the node in the Temporal Graph}
\end_layout

\begin_layout Plain Layout

	
\backslash
begin{algorithmic}[1]
\end_layout

\begin_layout Plain Layout

		
\backslash
Function{temporalFingerprint}{$G_t$,node,$
\backslash
delta$}
\end_layout

\begin_layout Plain Layout

		
\backslash
State $fingerprint 
\backslash
gets vector[2]$
\end_layout

\begin_layout Plain Layout

		
\backslash
For {$prop 
\backslash
in G_t.P_{node}$}
\end_layout

\begin_layout Plain Layout

		
\backslash
If {classifyPropagation(prop,$
\backslash
delta$) = timeRespecing}     
\end_layout

\begin_layout Plain Layout

			
\backslash
State fingerprint[1] $
\backslash
gets$ fingerprint[1] +1
\end_layout

\begin_layout Plain Layout

		
\backslash
Else
\end_layout

\begin_layout Plain Layout

			
\backslash
State fingerprint[2] $
\backslash
gets$ fingerprint[2] +1
\end_layout

\begin_layout Plain Layout

		
\backslash
EndIf
\end_layout

\begin_layout Plain Layout

		
\backslash
EndFor
\end_layout

\begin_layout Plain Layout

		
\backslash
State 
\backslash
Return {fingerprint}
\end_layout

\begin_layout Plain Layout

		
\backslash
EndFunction
\end_layout

\begin_layout Plain Layout

	
\backslash
end{algorithmic}  	
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Il codice è sostanzialmente lo stesso sia nel caso di grafo a contatti,
 sia nel caso di intervalli di propagazione.
\end_layout

\begin_layout Standard
Ambiguità potrebbe risalire però nel caso di grafo con più contatti per
 arco, caso già discusso precedentemente, in cui esistono due possibilità:
 o considerare le propagazioni come indipendenti, oppure propagazioni con
 stesso nodo destinazione e nodo sorgente andranno a finire in impronte
 differenti, quindi combinazioni tra le propagazioni uguali e quelle differenti.
\end_layout

\begin_layout Standard
Nel primo caso, potrebbero venire fuori delle ambiguità dato che una singola
 impronta temporale che ingloba informazioni da diversi pattern per gli
 stessi archi potrebbe portare a falsi positivi, cioè nodi cui archi sono
 maggiori rispetto a quelli del nodo query, ma aventi stessa impronta finale.
\end_layout

\begin_layout Standard
Il secondo caso dovrebbe essere quello più sicuro, ma anche il più complesso
 algoritmicamente, dato che bisognerebbe fare le combinazioni tra i vari
 archi in base ai contatti di ogni arco (restituendo un insieme di impronte
 temporali di tutte le combinazioni), quindi confrontare tutte le permutazioni
 possibili e vedere se sono simili.
\end_layout

\begin_layout Standard
Questo caso non verrà trattato dato che lo studio si concentra su singoli
 contatti, ma in futuro si vedranno le possibili implicazioni ed utilizzi
 dei grafi temporali ad intervalli multipli, così da avere più informazioni
 sulle possibili esigenze più comuni che si possono soddisfare con le possibili
 implementazioni e definizioni.
\end_layout

\begin_layout Standard
Per fare il controllo di due strutture temporali e verificare la similarità
 basta fare un operazione vettoriale sulle componenti dell'impronta del
 nodo della query 
\begin_inset Formula $q$
\end_inset

 e del nodo target 
\begin_inset Formula $t$
\end_inset

 , controllando quindi che sia 
\begin_inset Formula $result=temporalFingerprint(q)\stackrel{component-wise}{\leq}temporalFingerprint(t)|\forall i\in[1,result.size],result[i]=true$
\end_inset

, altrimenti la condizione non è verificata ed il nodo non è simile
\end_layout

\begin_layout Standard
Di seguito l'algoritmo che viene chiamato per effettuare il matching tra
 grafi temporali:
\end_layout

\begin_layout Standard
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithm} 	
\end_layout

\begin_layout Plain Layout

	
\backslash
caption{TemporalRI($G_{query}$,$G_{target}$,$
\backslash
delta$)}
\end_layout

\begin_layout Plain Layout

	
\backslash
hspace*{
\backslash
algorithmicindent} 
\backslash
textbf{Input: } 
\backslash
text{$G_{query}$: query Temporal Graph,}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		
\backslash
hspace*{2,1cm}
\backslash
text{$G_{target}$: target Temporal Graph, }
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		
\backslash
hspace*{2,1cm}
\backslash
text{$
\backslash
delta$: is the conditional parameter used to classify propagations}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	
\backslash
hspace*{
\backslash
algorithmicindent} 
\backslash
textbf{Output: } 
\backslash
text{number of occurrences of Query in Target}
\end_layout

\begin_layout Plain Layout

	
\backslash
begin{algorithmic}[1]
\end_layout

\begin_layout Plain Layout

		
\backslash
Function{TemporalRI}{$G_{query}$,$G_{target}$,$
\backslash
delta$}
\end_layout

\begin_layout Plain Layout

		
\backslash
State $Dom 
\backslash
gets$ ComputeDomains($G_{query},G_{target}$,$
\backslash
delta$)
\end_layout

\begin_layout Plain Layout

		
\backslash
State $
\backslash
mu 
\backslash
gets$ OrderQueryNodes($G_{query},Dom$)
\end_layout

\begin_layout Plain Layout

		
\backslash
State $
\backslash
varsigma 
\backslash
gets$ ComputeSimmetryBreakingCond($G_{query}$,$
\backslash
delta$)
\end_layout

\begin_layout Plain Layout

		
\backslash
State $Matches 
\backslash
gets$ SubgraphMatching($G_{query},G_{target},Dom,
\backslash
mu,
\backslash
varsigma,
\backslash
delta$)
\end_layout

\begin_layout Plain Layout

		
\backslash
State 
\backslash
Return {$Matches$}
\end_layout

\begin_layout Plain Layout

		
\backslash
EndFunction
\end_layout

\begin_layout Plain Layout

	
\backslash
end{algorithmic}  	
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Non vengono visti nello specifico tutti gli algoritmi utilizzati (lo pseudocodic
e è disponibile nell'Appendice di
\begin_inset CommandInset citation
LatexCommand cite
key "micale2020multiri"
literal "false"

\end_inset

) dato che le modifiche sono minimali o nulle per molte parti del codice,
 le uniche parti in cui è effettivamente cambiato qualcosa sono i codici
 del calcolo dei domini di compatibilità, il calcolo degli automorfismi
 durante la ricerca delle simmetrie ed una parte del codice durante la fase
 di matching in cui si controllano gli archi tra i nodi già mappati ed un
 candidato (controllando la similarità).
\end_layout

\begin_layout Standard
Quest'ultimo caso non verrà riportato come pseudocodice perché la modifica
 è minima e riguarda un controllo della struttura temporale a partire dall'arco
 che si sta mappando rispetto al candidato ed al nodo già mappato (vi è
 comunque il solito controllo della similarità delle impronte temporali,
 l'algoritmo è già stato descritto).
\end_layout

\begin_layout Standard
Sotto viene invece riportato il codice per il calcolo delle rotture di simmetria
:
\end_layout

\begin_layout Standard
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithm} 	
\end_layout

\begin_layout Plain Layout

	
\backslash
caption{ComputeSimmetryBreakingCond($G_{query}$,$
\backslash
delta$)}
\end_layout

\begin_layout Plain Layout

	
\backslash
hspace*{
\backslash
algorithmicindent} 
\backslash
textbf{Input: } 
\backslash
text{$G_{query}$: query Temporal Graph,}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		
\backslash
hspace*{2,1cm}
\backslash
text{$
\backslash
delta$: is the conditional parameter used to classify propagations}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	
\backslash
hspace*{
\backslash
algorithmicindent} 
\backslash
textbf{Output: } 
\backslash
text{set of symmetry breaking condition of query graph}
\end_layout

\begin_layout Plain Layout

	
\backslash
begin{algorithmic}[1]
\end_layout

\begin_layout Plain Layout

		
\backslash
Function{ComputeSimmetryBreakingCond}{$G_{query}$,$
\backslash
delta$}
\end_layout

\begin_layout Plain Layout

		
\backslash
State $
\backslash
varsigma 
\backslash
gets 
\backslash
emptyset$
\end_layout

\begin_layout Plain Layout

		
\backslash
State $Aut_{|
\backslash
varsigma} 
\backslash
gets$ ComputeAutomorphismMatrix($G_{query}$,$
\backslash
delta$)
\end_layout

\begin_layout Plain Layout

		
\backslash
State $Orb_{|
\backslash
varsigma} 
\backslash
gets$
\end_layout

\begin_layout Plain Layout

ComputeOrbits($Aut_{|
\backslash
varsigma}$)
\end_layout

\begin_layout Plain Layout

		
\backslash
While{$|Aut_{|
\backslash
varsigma}|>1$}
\end_layout

\begin_layout Plain Layout

			
\backslash
State $q' 
\backslash
gets argmin_{q
\backslash
in V_{Q}:|Orb_{|
\backslash
varsigma}|>1} 
\backslash
left
\backslash
{id(q) 
\backslash
right
\backslash
} $
\end_layout

\begin_layout Plain Layout

			
\backslash
For {$q 
\backslash
in V_Q | q 
\backslash
neq q' 
\backslash
cap Orb_{|
\backslash
varsigma}(q) = Orb_{|
\backslash
varsigma}(q')$}
\end_layout

\begin_layout Plain Layout

				
\backslash
State $
\backslash
varsigma 
\backslash
gets 
\backslash
varsigma 
\backslash
cup 
\backslash
left
\backslash
{q' 
\backslash
prec q
\backslash
right
\backslash
}$
\end_layout

\begin_layout Plain Layout

			
\backslash
EndFor
\end_layout

\begin_layout Plain Layout

			
\backslash
State $Aut_{|
\backslash
varsigma} 
\backslash
gets 
\backslash
left
\backslash
{Aut_{|
\backslash
varsigma}[i]|
\backslash
rho_i(q')=q'
\backslash
right
\backslash
}$
\end_layout

\begin_layout Plain Layout

			
\backslash
State $Orb_{|
\backslash
varsigma} 
\backslash
gets$
\end_layout

\begin_layout Plain Layout

ComputeOrbits($Aut_{|
\backslash
varsigma}$)
\end_layout

\begin_layout Plain Layout

		
\backslash
EndWhile
\end_layout

\begin_layout Plain Layout

		
\backslash
State 
\backslash
Return {$
\backslash
varsigma$}
\end_layout

\begin_layout Plain Layout

		
\backslash
EndFunction
\end_layout

\begin_layout Plain Layout

	
\backslash
end{algorithmic}  	
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Ottimizzazione per più contatti o più intervalli per arco, cioè simil-binary
 search e visione della similarità
\end_layout

\begin_layout Standard
L'algoritmo per il calcolo delle condizioni di rottura delle simmetrie si
 basa su un calcolo iterativo degli automorfismi della query e delle orbite
 a partire dall'attuale insieme di condizioni di rottura della simmetria
 scoperte dall'algoritmo.
 Dato un insieme di condizioni di rottura C, indichiamo con 
\begin_inset Formula $Aut_{|\varsigma}$
\end_inset

 e 
\begin_inset Formula $Orb_{|\varsigma}$
\end_inset

 la matrice dell'automorfismo e l'insieme delle orbite che rispettano le
 condizioni di rottura in C.
\end_layout

\begin_layout Standard
Quando C è vuoto, 
\begin_inset Formula $Aut_{|\varsigma}$
\end_inset

 corrisponde alla matrice di automorfismo di Q e 
\begin_inset Formula $Orb_{|\varsigma}$
\end_inset

 è l'insieme di orbite corrispondente.
 Una condizione di rottura 
\begin_inset Formula $q_{0}≺q$
\end_inset

 in C, impedisce che 
\begin_inset Formula $q_{0}$
\end_inset

 venga mappato a q in qualsiasi automorfismo.
 Quindi, 
\begin_inset Formula $Aut_{|\varsigma}$
\end_inset

 diventa la matrice degli automorfismi ottenuta dall'insieme di tutti gli
 automorfismi del grafo query dove 
\begin_inset Formula $q_{0}$
\end_inset

 non è mappato a q, per tutti i nodi 
\begin_inset Formula $q_{0}$
\end_inset

 e q tale che 
\begin_inset Formula $q≺q_{0}∈C$
\end_inset

.
 
\begin_inset Formula $Orb_{|\varsigma}$
\end_inset

 è l'insieme delle orbite relativo ad 
\begin_inset Formula $Aut_{|\varsigma}$
\end_inset

.
 Il primo passo dell'algoritmo è il calcolo della matrice degli automorfismi
 di Q.
\end_layout

\begin_layout Standard
Ciò può essere ottenuto utilizzando qualsiasi algoritmo di matching del
 grafo.
 In seguito, vengono calcolate le orbite di Q e viene calcolato il nodo
 del grafo query 
\begin_inset Formula $q_{0}$
\end_inset

 con id minimo su tutte le orbite con almeno due nodi equivalenti.
 Per ogni nodo 
\begin_inset Formula $q\neq q_{0}$
\end_inset

 appartenente alla stessa orbita di 
\begin_inset Formula $q_{0}$
\end_inset

, viene definita una nuova condizione di rottura della simmetria 
\begin_inset Formula $q_{0}≺q$
\end_inset

 che viene aggiunta all'insieme finale di condizioni.
 Questo passaggio equivale a impedire che il nodo 
\begin_inset Formula $q_{0}$
\end_inset

 venga mappato a qualsiasi altro nodo e a mettere 
\begin_inset Formula $q_{0}$
\end_inset

 in un'orbita separata.
 Per essere coerenti con ciò, dobbiamo mantenere dalla matrice degli automorfism
i corrente solo le righe corrispondenti agli automorfismi che mappano 
\begin_inset Formula $q_{0}$
\end_inset

 a se stesso e aggiornare il relativo set di orbite 
\begin_inset Formula $Orb_{|\varsigma}$
\end_inset

.
\end_layout

\begin_layout Standard
Di seguito viene riportato lo pseudocodice per il calcolo dei domini di
 compatibilità:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithm} 	
\end_layout

\begin_layout Plain Layout

	
\backslash
caption{ComputeDomains(${Q}$,${T}$,$
\backslash
delta$)}
\end_layout

\begin_layout Plain Layout

	
\backslash
hspace*{
\backslash
algorithmicindent} 
\backslash
textbf{Input: } 
\backslash
text{${Q}$: query Temporal Graph,}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		
\backslash
hspace*{2,1cm}
\backslash
text{${T}$: target temporal graph}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		
\backslash
hspace*{2,1cm}
\backslash
text{$
\backslash
delta$: is the conditional parameter used to classify propagations and for
 the similarity}
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	
\backslash
hspace*{
\backslash
algorithmicindent} 
\backslash
textbf{Output: } 
\backslash
text{set of compatibility domains of nodes in $G_{query}$}
\end_layout

\begin_layout Plain Layout

	
\backslash
begin{algorithmic}[1]
\end_layout

\begin_layout Plain Layout

		
\backslash
Function{ComputeDomains}{${Q}$,${T}$,$
\backslash
delta$}
\end_layout

\begin_layout Plain Layout

		
\backslash
For {$q 
\backslash
in V_{Q}$}
\end_layout

\begin_layout Plain Layout

			
\backslash
State $Dom(q) 
\backslash
gets 
\backslash
emptyset$
\end_layout

\begin_layout Plain Layout

		
\backslash
EndFor
\end_layout

\begin_layout Plain Layout

		
\backslash
For {$t 
\backslash
in V_{T}$}
\end_layout

\begin_layout Plain Layout

			
\backslash
For {$q 
\backslash
in V_{Q}$}
\end_layout

\begin_layout Plain Layout

				
\backslash
If {$deg(q) 
\backslash
leq deg(t) 
\backslash
wedge q 
\backslash
simeq t $}
\end_layout

\begin_layout Plain Layout

					
\backslash
State $Dom(q) 
\backslash
gets Dom(q)
\backslash
cup
\backslash
left
\backslash
{t 
\backslash
right
\backslash
}$
\end_layout

\begin_layout Plain Layout

				
\backslash
EndIf
\end_layout

\begin_layout Plain Layout

			
\backslash
EndFor
\end_layout

\begin_layout Plain Layout

		
\backslash
EndFor
\end_layout

\begin_layout Plain Layout

		
\backslash
For {$q' 
\backslash
in V_{Q}$}
\end_layout

\begin_layout Plain Layout

			
\backslash
For {$t' 
\backslash
in Dom{q'}$}
\end_layout

\begin_layout Plain Layout

				
\backslash
For {$q'' 
\backslash
in V_{Q}|(q',q
\begin_inset Quotes frd
\end_inset

)
\backslash
in E_Q$}
\end_layout

\begin_layout Plain Layout

					
\backslash
If {$
\backslash
nexists t'' 
\backslash
in Dom(q'')|(t',t
\begin_inset Quotes frd
\end_inset

)
\backslash
in E_T $}
\end_layout

\begin_layout Plain Layout

						
\backslash
State $Dom(q') 
\backslash
gets Dom(q')
\backslash
backslash
\backslash
left
\backslash
{t' 
\backslash
right
\backslash
}$
\end_layout

\begin_layout Plain Layout

					
\backslash
EndIf
\end_layout

\begin_layout Plain Layout

				
\backslash
EndFor
\end_layout

\begin_layout Plain Layout

			
\backslash
EndFor
\end_layout

\begin_layout Plain Layout

		
\backslash
EndFor
\end_layout

\begin_layout Plain Layout

		
\backslash
State 
\backslash
Return {$Dom$}
\end_layout

\begin_layout Plain Layout

		
\backslash
EndFunction
\end_layout

\begin_layout Plain Layout

	
\backslash
end{algorithmic}  	
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Come si può facilmente vedere, un nodo del grafo target entra nel dominio
 dei candidati di un nodo del grafo query solo e soltanto se ha lo stesso
 grado e se il nodo query è simile al nodo target.
\end_layout

\begin_layout Standard
Viene inoltre visto il requisito minimo già descritto della Arc Consistency,
 viene quindi visto se tra due nodi del grafo query esiste un arco, allora
 per ogni nodo del dominio della sorgente si controlla se esiste almeno
 un arco verso i nodi nel dominio della destinazione.
\end_layout

\begin_layout Standard
Il parametro 
\begin_inset Formula $\delta$
\end_inset

 sembra non venire utilizzato, ma in realtà viene utilizzato durante il
 calcolo della similarità tra i due nodi (per la computazione delle impronte).
\end_layout

\begin_layout Standard
Di seguito viene descritto brevemente l'algoritmo di Match modificato per
 integrare la componente temporale.
\end_layout

\begin_layout Standard
Il nucleo dell'algoritmo di matching è la procedura MATCH ricorsiva.
 Sia M la corrispondenza parziale trovata e q un nodo del grafo temporale
 query che non è stato ancora mappato.
 Se 
\begin_inset Formula $q_{0}$
\end_inset

 è il nodo che precede 
\begin_inset Formula $q$
\end_inset

 nell'ordine 
\begin_inset Formula $μ$
\end_inset

, l'insieme 
\begin_inset Formula $Cand(q)$
\end_inset

 di nodi target candidati da abbinare a 
\begin_inset Formula $q$
\end_inset

 è dato da 
\begin_inset Formula $Neigh(f(q_{0}))∩Dom(q)$
\end_inset

, cioè l'insieme di nodi che sono adiacenti del nodo destinazione che è
 già stato abbinato a 
\begin_inset Formula $q_{0}$
\end_inset

 e sono nel dominio di compatibilità di 
\begin_inset Formula $q$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Flex Alert
status open

\begin_layout Plain Layout
da rivedere
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Se q è il primo nodo in 
\begin_inset Formula $μ$
\end_inset

, l'insieme di nodi candidati è solo il dominio di compatibilità di 
\begin_inset Formula $q$
\end_inset

.
 Se alcune regole di fattibilità sono soddisfatte (tra cui la similarità
 tra i nodi e il controllo aggiuntivo sugli archi associati), RI aggiunge
 la coppia 
\begin_inset Formula $(q,t)$
\end_inset

 alla corrispondenza parziale M e aggiorna la funzione di mappatura 
\begin_inset Formula $f$
\end_inset

.
 Quando tutti i nodi della query sono stati mappati, viene trovata una nuova
 occorrenza di Q in T e la corrispondenza corrispondente viene aggiunta
 all'elenco delle corrispondenze trovate.
 Ogni volta che tutti i nodi del grafo temporale query sono stati mappati
 o non è stata trovata alcuna corrispondenza per un nodo del grafo query,
 l'algoritmo esegue il backtracking e continua la ricerca dall'ultimo nodo
 abbinato (precedentemente).
 Il backtracking implica la rimozione dell'ultima coppia di query corrispondenti
 e dei nodi di destinazione da M e la mappatura tra tali nodi utilizzando
 
\begin_inset Formula $f$
\end_inset

.
 Quando non è possibile creare altre corrispondenze per alcun nodo della
 query, TemporalRI si interrompe.
 Alla fine del processo di corrispondenza, l'algoritmo restituisce l'elenco
 di tutte le corrispondenze trovate.
\end_layout

\begin_layout Subsection
Analisi complessità
\end_layout

\begin_layout Standard
Vengono analizzate le complessità spaziale e temporale, iniziando dall'analisi
 degli algoritmi ed esplorando alternative sia come cambiamento di codice
 e funzionalità, sia come utilizzo differente di strutture aggiuntive, per
 esempio aggiungendo dei parametri alla definizione di grafo temporale.
\end_layout

\begin_layout Standard
Sia 
\begin_inset Formula $n_{Q}$
\end_inset

 il numero di nodi del grafo temporale query, ed 
\begin_inset Formula $n_{T}$
\end_inset

 il numero di nodi della destinazione.
 Il primo passo di TemporalRI è il calcolo dei domini di compatibilità.
 La costruzione di domini richiede 
\begin_inset Formula $O(n_{Q}n_{T})$
\end_inset

, mentre la procedura AC richiede 
\begin_inset Formula $O(n_{Q}^{2}n_{T}^{2}$
\end_inset

) perché, nel peggiore dei casi, per ogni arco in uscita della query da
 
\begin_inset Formula $q_{0}$
\end_inset

 bisogna controllare tutti gli archi in uscita da nodi di destinazione in
 
\begin_inset Formula $Dom(q'')$
\end_inset

.
 Quindi, il calcolo dei domini di compatibilità richiede sommariamente 
\begin_inset Formula $O(n_{Q}^{2}n_{T}^{2})$
\end_inset

.
 Quindi, TemporalRI calcola l'ordinamento dei nodi del grafo query per il
 processo di corrispondenza.
 La parte importante di questo passaggio è la costruzione degli insiemi
 
\begin_inset Formula $V_{q,vis}$
\end_inset

,
\begin_inset Formula $V_{q,neig}$
\end_inset

 e 
\begin_inset Formula $V_{q,unv}$
\end_inset

, che richiede 
\begin_inset Formula $O(n_{Q}^{2})$
\end_inset

.
\end_layout

\begin_layout Standard
La terza fase di TemporalRI è il calcolo delle condizioni di rottura della
 simmetria.
 Il calcolo della matrice di automorfismo per la query è difficile almeno
 quanto la risoluzione dell'isomorfismo del grafo e la sua complessità è
 limitata da 
\begin_inset Formula $O(2^{n_{Q}})$
\end_inset

.
 Le orbite vengono calcolate scansionando colonna per colonna la matrice
 dell'automorfismo.
 Poiché il numero di automorfismi di un grafo con 
\begin_inset Formula $n$
\end_inset

 nodi è al massimo 
\begin_inset Formula $n!$
\end_inset

 (nel caso in cui il grafico sia completo), il calcolo delle orbite richiede
 
\begin_inset Formula $O(n_{Q}!n_{Q})$
\end_inset

.
 Nel peggiore dei casi ad ogni passo del ciclo while il numero di automorfismi
 diminuisce solo di uno e il ciclo viene eseguito 
\begin_inset Formula $n_{Q}!$
\end_inset

 volte.
 Quindi, il calcolo delle condizioni di rottura richiede 
\begin_inset Formula $O(n_{Q}!2n_{Q})$
\end_inset

.
 
\end_layout

\begin_layout Standard
Il processo di matching non verrà commentato nello specifico, ma basta sapere
 che il calcolo delle similarità tra nodi non aggiunge nulla nell'analisi
 asintotica, che resta comunque la stessa rispetto a quella già descritta
 in 
\begin_inset CommandInset citation
LatexCommand cite
key "bonnici2013subgraph,micale2020multiri"
literal "false"

\end_inset

, inoltre se si tengono le strutture temporali dei singoli nodi direttamente
 come struttura aggiornata, il controllo diventa un semplice confronto.
\end_layout

\begin_layout Standard
Per quanto riguarda la complessità spaziale di TemporalRI, data la possibilità
 di avere un contatto per ogni arco, il grafo temporale query e target richiedon
o 
\begin_inset Formula $O((2n_{Q})^{2})$
\end_inset

 e 
\begin_inset Formula $O((2n_{T})^{2})$
\end_inset

 spazio nel peggiore dei casi, rispettivamente, quindi restano sempre nell'ordin
e del quadratico di RI.
 Le strutture dati aggiuntive utilizzate dall'algoritmo durante la ricerca
 includono l'insieme di domini di compatibilità per ogni nodo di query (spazio
 
\begin_inset Formula $O(n_{Q}n_{T})$
\end_inset

 nel caso peggiore), l'insieme di condizioni di rottura della simmetria
 per la query 
\begin_inset Formula $O(n_{Q}^{2})$
\end_inset

 spazio), la mappatura e la corrispondenza parziale (entrambe richiedono
 uno spazio 
\begin_inset Formula $O(n_{Q})$
\end_inset

) e l'insieme di nodi di destinazione candidati per la corrispondenza per
 ciascun nodo di query 
\begin_inset Formula $O(n_{Q}n_{T})$
\end_inset

.
 Pertanto, la complessità spaziale totale di TemporalRI è 
\begin_inset Formula $O((2n_{Q})^{2})+O((2n_{T})^{2})+2*O(n_{Q}))+2*O(n_{Q}n_{T})+O(n_{Q}^{2})$
\end_inset

.
 Dato che molto spesso il grafo query è molto più piccolo del grafo target
 (
\begin_inset Formula $n_{Q}<<n_{T}$
\end_inset

), la complessità risultante asintoticamente sarà dominata da 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $O(n_{T}^{2})$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\xout default
\uuline default
\uwave default
\noun default
\color inherit
, cioè lo spazio necessario per memorizzare il grafo temporale target
\end_layout

\begin_layout Standard
Possono essere aggiunte comunque delle strutture o variabili aggiuntive
 come per esempio l'insieme delle propagazioni che aggiungerebbe una complessità
 spaziale aggiuntiva di (
\begin_inset Formula $O(|inedges(Q)|*|outedges(Q)|)+O(|inedges(T)|*|outedges(T)|)$
\end_inset

) che non conviene assolutamente tenere data la sua situazionalità e facile
 derivabilità, oppure l'impronta (o l'insieme di impronte nel caso di più
 contatti per arco) del singolo nodo, che viene aggiornata ad ogni aggiunta
 di arco entrante o uscente da un nodo (
\begin_inset Formula $O(n_{T})+O(n_{Q})$
\end_inset

), e grazie al quale è possibile evitare il calcolo continuo delle impronte
 per effettuare un controllo diretto sulle strutture ausiliarie.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Conclusioni
\end_layout

\begin_layout Standard
Lo sviluppo delle reti temporali è particolarmente difficile perché o ci
 mancano le misure di base e le nozioni necessarie a modellare reti reali,
 o semplifichiamo troppo l’analisi stessa.
 Nel momento in cui avremo stabilito delle convenzioni comuni che siano
 di notevole importanza per abbastanza reti reali potremmo riuscire a simulare
 la realtà in modo più accurato.
 Il problema finale resta comunque quello di minimizzare l’entropia e massimizza
re l’informazione.
\end_layout

\begin_layout Standard
Nel momento in cui avremo stabilito delle convenzioni comuni che siano di
 notevole importanza per abbastanza reti reali potremmo riuscire a simulare
 la realtà in modo più accurato.
 Il problema finale resta comunque quello di minimizzare l’entropia e massimizza
re l’informazione.
\end_layout

\begin_layout Standard
Come si è visto più volte, molto spesso il problema delle reti temporali
 è quello di adattare l'infrastruttura al caso singolo, in base alle esigenze.
 
\end_layout

\begin_layout Standard
Molto spesso questo viene sfruttato da altri autori per creare le proprie
 soluzioni al problema, quindi creando delle infrastrutture molto selettive
 e poco generali.
\end_layout

\begin_layout Standard
Anche grazie a questa tendenza, molti autori finiscono per prendere ad esempio
 le singole soluzioni specifiche per il singolo problema in modo superficiale,
 adattando la soluzione vista e spiegata in altri studi per il proprio caso,
 riuscendo così a definire un infrastruttura abbastanza confusa rispetto
 all'obiettivo finale a cui si voleva arrivare.
\end_layout

\begin_layout Standard
Alcuni autori invece si sono concentrati su una definizione di framework
 generale ed utilizzabile in molti contesti, senza essere pesantemente influenza
ti da bias verso i singoli casi, ma prendendo le descrizioni e soluzioni
 adottate da altri studi ed integrando una spiegazione generale capace di
 permettere la costruzione di un framework generale ed adattabile al singolo
 caso 
\begin_inset CommandInset citation
LatexCommand cite
key "holme2019temporal"
literal "false"

\end_inset

.
\end_layout

\begin_layout Standard
In questo studio si è deciso di adottare lo stesso approccio, non concentrandosi
 su un singolo problema, ma definendo prima una struttura di base flessibile,
 e poi adattarla per la definizione del problema (che in questo caso era
 il Temporal Sub-Graph Isomorphism), in modo da portare un esempio reale
 di modellazione di una soluzione a partire da definizioni chiare e concretament
e utili nella maggior parte dei casi.
\end_layout

\begin_layout Standard
Dopo la definizione del framework di base, si è definito il problema del
 Temporal Sub-Graph Isomorphism introducendolo prima con una descrizione
 del problema di base nei grafi statici con una possibile soluzione che
 utilizza un algoritmo veloce basato su euristiche utili per la riduzione
 dello spazio di ricerca (
\begin_inset Flex Bold
status open

\begin_layout Plain Layout
RI
\end_layout

\end_inset

), ed espandendo il concetto ai grafi temporali in modo da avere una base
 solida espandibile in modo semplice grazie anche alle definizioni create
 durante la descrizione della struttura di base e delle operazioni nelle
 reti temporali.
\end_layout

\begin_layout Standard
Si sono visti dei problemi di definizione nella descrizione di grafo temporale
 query e target, dato che la ricerca della struttura è totalmente dipendente
 dal problema che si sta cercando di risolvere, cioè il tipo di struttura
 che si stà cercando.
\end_layout

\begin_layout Standard
Si è effettuata una analisi della complessità che ha fatto vedere come effettiva
mente il problema di base non sia di semplice soluzione ed allo stesso tempo
 molto dipendente dalle variabili che vengono passate (cioè grafo query
 e target), e si vedrà in dati sperimentali come questa affermazione sia
 sostanzialmente vera dato che i tempi di esecuzione dipendono molto spesso
 dalla struttura di base dei grafi temporali utilizzati come variabili.
 
\end_layout

\begin_layout Standard
Si vedrà nella prossima sottosezione come l'andamento dell'esecuzione dipenda
 comunque non dalla quantità di nodi in un grafo, ma dagli archi-contatti,
 che definiscono la struttura temporale ed inficiano direttamente la quantità
 di nodi da analizzare (che appartengono ai domini di compatibilità) ed
 il controllo utilizzato nella fase di matching.
\end_layout

\begin_layout Subsection
Dati sperimentali
\end_layout

\begin_layout Standard
Di seguito vengono presentati i grafici che rappresentano le performance
 all'aumentare della dimensione e della struttura di un grafo temporale.
\end_layout

\begin_layout Standard
Per la costruzione dei grafi target si voleva utilizzare un generatore di
 grafi temporali che si basa su due distribuzioni, una per i possibili archi
 (che è una Poisson per il grado di un nodo), ed una dei possibili tempi
 (che in realtà stabilisce delle mode intervallari dove poter far accadere
 i contatti), alla fine si è optato di utilizzare dei grafi temporali già
 disponibili leggermente modificati per facilitare il parsing e la ricerca
 delle occorrenze.
\end_layout

\begin_layout Standard
Per la costruzione del grafo query sono stati utilizzati grafi creati ad-hoc
 anche per simulare un procedimento reale, dove si vogliono trovare dei
 pattern specifici.
 Sono stati provati grafi query di dimensione crescente (uno da 4 nodi,uno
 da 16 nodi, uno da 32 e l'ultimo a 50 nodi), gli archi sono stati creati
 a mano.
\end_layout

\begin_layout Standard
Di seguito verranno considerati solo i casi di grafo query a 32 e 50 nodi,
 dato che è il più pesante computazionalmente.
\end_layout

\begin_layout Standard
Non sono stati considerati confronti con altri tool dato che quello che
 fanno nella maggior parte è tutt'altro (anche perché l'unico tool che sembra
 esistere per questo tipo di problemi è SNAP), cioè la ricerca di motif
 con 3 nodi e 3 archi.
\end_layout

\begin_layout Standard
Verrà invece considerato un confronto con l'algoritmo utilizzato in 
\begin_inset CommandInset citation
LatexCommand cite
key "Mackey2018"
literal "false"

\end_inset

 modificato dato che non trovava le stesse occorrenze dell'algoritmo utilizzato
 in questo studio ed anche perché non era molto performante, anche dopo
 la modifica non trova le stesse occorrenze, ma almeno funziona per grafi
 abbastanza complessi.
\end_layout

\begin_layout Standard
L'implementazione di base di questo algoritmo è scaricabile su github (
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://github.com/pnnl/temporal_subgraph_isomorphism
\end_layout

\end_inset

).
 Non sono stati trovati altri algoritmi utilizzabili o modificabili per
 fare un confronto completo, inoltre i risultati non potrebbero essere quelli
 visti ma leggermente diversi (dato che siamo in estate ed il mio computer
 stava fondendo), comunque i rapporti tra i tempi e le performance dovrebbero
 essere le stesse.
\end_layout

\begin_layout Standard
Vengono presentati singole misure per variabile perché durante alcune prove
 il tempo di esecuzione non sembrava fluttuare particolarmente (anche perchè
 il procedimento è poco variabile in tutti e due gli algoritmi).
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
I grafi target presi sono relativamente pochi anche perché il tempo di esecuzion
e non variava particolarmente con alcune variabili (i nodi del grafo target),
 mentre con gli archi di un grafo sembra seguire un andamento crescente
 (con una correlazione abbastanza tendente allo 0 perché comunque dipende
 dalla struttura di tutto il grafo e da come sono distribuiti gli archi,
 oltre all'andamento della struttura temporale).
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename nodetoruntimequery1.svg
	scale 28

\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\family sans
\size small
\color red
Query di 50 nodi
\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename nodetoruntimequery2.svg
	scale 28

\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\family sans
\size small
\color red
Query di 32 nodi
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Il numero di nodi non sembrà influenzare direttamente il tempo di esecuzione,
 dato che non agisce direttamente sulla ricerca dei possibili match.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename edgetoruntimequery1.svg
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\family sans
\size small
\color red
Query di 50 nodi
\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename edgetoruntimequery2.svg
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\family sans
\size small
\color red
Query di 32 nodi
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nel caso della correlazione con l'aumento di archi in un grafo, sembra invece
 che l'algoritmo risenta del maggiore carico computazionale nel controllo
 dei vari archi, quindi il tempo di esecuzione assume un andamento crescente
 all'aumentare dei contatti in un grafo temporale.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
Di seguito si presentano i confronti tra TemporalRI e l'algoritmo utilizzato
 in 
\begin_inset CommandInset citation
LatexCommand cite
key "Mackey2018"
literal "false"

\end_inset

:
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename confrontoaltronodi1.svg
	scale 28

\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\family sans
\size small
\color red
Query di 50 nodi
\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename confrontoaltronodi2.svg
	scale 28

\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\family sans
\size small
\color red
Query di 32 nodi
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Come già specificato, il numero di nodi non sembrà influenzare direttamente
 il tempo di esecuzione, e nonostante l'algoritmo confrontato con RI sia
 abbastanza poco performante, non sembra essere particolarmente attaccato
 da grafi abbastanza grandi.
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename confrontoaltroarchi1.svg
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\family sans
\size small
\color red
Query di 50 nodi
\end_layout

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "45col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename confrontoaltroarchi2.svg
	scale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\align center

\family sans
\size small
\color red
Query di 32 nodi
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Come si può facilmente vedere, TemporalRI è migliore in prestazioni, oltre
 a dare il giusto risultato in base alla definizione data durante questo
 studio.
 
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Futuro
\end_layout

\begin_layout Standard
Per il futuro vi sono la definizione chiara di una base di formalità per
 gli isomorfismi per intervalli multipli per ogni arco, dato che è molto
 più complicata e dipendente da quello che è stato esposto precedentemente.
\end_layout

\begin_layout Standard
Inoltre il codice è stato scritto in scala anche per favorire una possibile
 implementazione con SPARK e la trasposizione nel mondo dello stream processing
 o della computazione distribuita di grafi con librerie come Neo4j o GraphX.
\end_layout

\begin_layout Standard
Una possibilità non visitata è l'implementazione dei grafi temporali insieme
 a modelli di Markov o altri modelli statistici in modo da modellare pure
 il cambiamento di stati ed i collegamenti in modo puramente statistico,
 creando una struttura di base più completa ed ibrida.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset nomencl_print
LatexCommand printnomenclature
set_width "auto"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "V"
description "insiemi dei nodi di un grafo"
literal "false"

\end_inset


\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "E"
description "insiemi degli archi di un grafo"
literal "false"

\end_inset


\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "G"
description "(V,E) grafo statico"
literal "false"

\end_inset

 
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "GT"
description "(V,E) grafo temporale"
literal "false"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
nomenclature{$p_{itj}$}{($e_{it}$,$e_{tj}$) propagazione dal nodo i al nodo
 j attraverso il nodo t}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
nomenclature{$P_{t}$}{insieme delle propagazioni di un nodo $t$}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
btprint "btPrintCited"
bibfiles "citationsBibliograp"
options "plain"

\end_inset


\end_layout

\end_body
\end_document
