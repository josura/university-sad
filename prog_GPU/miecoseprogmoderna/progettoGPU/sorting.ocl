kernel void vecinit(global int * restrict arr, int nels){
	
	const int i= get_global_id(0);	
		
	if(i>=nels)return;
	
	arr[i]=nels-i;

}


kernel void vecinit_rep(global int * restrict arr, int nels,int repetition){
	
	const int gi= get_global_id(0);	
		
	if(gi>=nels)return;
	for(int i =0; i < repetition; i++ )
		arr[gi*repetition+i]=nels-gi;
	

}

inline size_t round_mul_up(size_t gws, size_t lws)
{
	return ((gws + lws - 1)/lws)*lws;
}

uint MWC64X(uint2 *state)
{
    enum { A=4294883355U};
    uint x=(*state).x, c=(*state).y;  // Unpack the state
    uint res=x^c;                     // Calculate the result
    uint hi=mul_hi(x,A);              // Step the RNG
    x=x*A+c;
    c=hi+(x<c);
    *state=(uint2)(x,c);               // Pack the state back up
    return res;                       // Return the next result
}

inline uint xorshift(uint2 randoms,uint2 seeds){
	uint seed = randoms.x + get_global_id(0)-seeds.x;
	uint t = seed ^ (seed << 11) ^seeds.x;  
	return (seeds.y ^ randoms.y ^ (randoms.y >> 19) ^ (t ^ (t >> 8)));
}

kernel void vecinit_random(global uint * restrict arr,int seed1,int seed2, int nels){
	const int gi = get_global_id(0);
	if(gi >= nels) return;
	uint2 state = (uint2)(gi>>1,get_local_id(0)*gi);
	uint2 seeds = (uint2)(seed1,seed2);
	arr[gi] = (xorshift(state,seeds) & 31);
}


// needed helper methods
inline void swap(uint *a, uint *b) {
        uint tmp;
        tmp = *b;
        *b = *a;
        *a = tmp;
}

// dir == 1 means ascending
inline void sort(uint *a, uint *b, char dir) {
        if ((*a > *b) == dir) swap(a, b);
}

inline void swapLocal(__local uint *a, __local uint *b) {
        uint tmp;
        tmp = *b;
        *b = *a;
        *a = tmp;
}

// dir == 1 means ascending
inline void sortLocal(__local uint *a, __local uint *b, char dir) {
        if ((*a > *b) == dir) swapLocal(a, b);
}

inline void Merge(global int* restrict arr,
	uint start, uint middle, uint end,
	local int * L,local int * R){
	    int i, j, k; 
	    int n1 = middle -start+ 1; 
	    int n2 = end - middle; 
	  
	    	    /* Copy data to temiddlep arrays L[] and R[] */
	    for(i = 0; i < n1; i++) 
		L[i] = arr[start+ i]; 
	    for(j = 0; j < n2; j++) 
		R[j] = arr[middle + 1+ j]; 
	  
	    /* Merge the temiddlep arrays back into arr[l..r]*/
	    i = 0; // Initiastartindex of first subarray 
	    j = 0; // Initiastartindex of second subarray 
	    k =start; // Initiastartindex of middleerged subarray 
	    while (i < n1 && j < n2) 
	    { 
		if (L[i] <= R[j]) 
		{ 
		    arr[k] = L[i]; 
		    i++; 
		} 
		else
		{ 
		    arr[k] = R[j]; 
		    j++; 
		} 
		k++; 
	    } 
	  
	    /* Copy the remaining elements of L[], if there 
	       are any */
	    while (i < n1) 
	    { 
		arr[k] = L[i]; 
		i++; 
		k++; 
	    } 
	  
	    /* Copy the remeaining elements of R[], if there 
	       are any */
	    while (j < n2) 
	    { 
		arr[k] = R[j]; 
		j++; 
		k++; 
	    } 
}

void merge(global int* ar1,global int* ar2, int m, int n) 
{ 
    // Iterate through all elements of ar2[] starting from 
    // the last element 
    for (int i=n-1; i>=0; i--) 
    { 
        /* Find the smallest element greater than ar2[i]. Move all 
           elements one position ahead till the smallest greater 
           element is not found */
        int j, last = ar1[m-1]; 
        for (j=m-2; j >= 0 && ar1[j] > ar2[i]; j--) 
            ar1[j+1] = ar1[j]; 
  
        // If there was a greater element 
        if (j != m-2 || last > ar2[i]) 
        { 
            ar1[j+1] = ar2[i]; 
            ar2[i] = last; 
        } 
    } 
} 

inline void printarr(global int* arr,int nels){
		for(int i =0;i < nels;i++){
			printf("%i ",arr[i]);
			}
		printf("\n");

}
inline void printarrlocal(local int* arr,int nels){
		for(int i =0;i < nels;i++){
			printf("%i ",arr[i]);
			}
		printf("\n");

}
inline int binaryIndex(int pivot,global int* find1, int size){
        if(pivot>find1[size-1]){
		return size;
	}
        if(pivot<find1[0])return 0;
        int l=0 ,m, r=size-1 ;
        while (l <= r ) { 
                m = l + ((r - l)>> 1);
	       	int confront1 = find1[m];	
                if ((m+1)<(size) && (pivot > confront1) && (find1[m+1] >= pivot)) 
                    return m+1; 
                if ((confront1 < pivot) ) 
                    l = m + 1; 
                else
                    r = m - 1; 
        }
	return m; 
}

inline int binaryIndexV2(int pivot,global int* find1, int size,int condition,int gi){
        if( (condition && pivot>find1[size-1]) || (!condition && pivot>=find1[size-1]) ){
		return size;
	}
        int l=0 ,m, r=size-1 ;
        while (l <= r ) { 
                m = l + ((r - l)>> 1); 
                if ((m+1)<(size)){
			if( (condition && (pivot > find1[m]) && (find1[m+1] >= pivot)) || 
			(!condition && (pivot >= find1[m]) && (find1[m+1] > pivot)) ) 
			    return m+1;
		}
                if (m<size && m>=0 &&((condition && (find1[m] < pivot)) ||  (!condition && (find1[m] <= pivot)) ) )
                    l = m + 1; 
           
                else
                    r = m - 1; 
        }
	return m; 
}

inline int binaryLoc(int pivot, global int* find1, int size){
	int pos = 0;
	for (int inc=size;inc>0;inc>>=1) // binary search in the sub-sequence, solo per size potenze di due
	{
		int j = pos+inc-1;
		int confront2 = find1[j];
		pos += (confront2 < pivot)  ? inc:0;
		pos = min(pos,size);
	}
	return pos;
}

inline int binaryIndexPower(int pivot,global int* find1, int size){
        int l=0 ,m, r=size-1 ;
        while (l <= r ) { 
                m = l + ((r - l)>> 1);
	       	int confront1 = find1[m];	
                if ((m+1)<(size) && (pivot > confront1) && (find1[m+1] >= pivot)) 
                    return m+1; 
                if ((confront1 < pivot) ) 
                    l = m + 1; 
                else
                    r = m - 1; 
        }
	return (m<size-1 ? m : size); 
}

inline int binaryIndexFullPower(int pivot,global int* find1, int size){
        int l=0 ,m, r=size-1;
        while (l<=r ){
                m = l + ((r - l)>> 1);
                int confront1 = find1[m];
                if ((confront1 < pivot) )
                    l = m +1;
                else
                    r = m -1;
        }
        return  l;
}

inline int binaryIndexFullPower_corr(char condition,int pivot,global int* find1, int size){
        int l=0 ,m, r=size-1;
        while (l<=r ){
                m = l + ((r - l)>> 1);
                int confront1 = find1[m];
                if ((confront1 < pivot)||(condition && confront1 == pivot) )
                    l = m +1;
                else
                    r = m -1;
        }
        return  l;
}

/*inline int binaryLoc_local(int pivot, global int* find1, int size,local int2* lmem, int localsize){
	int pos = 0;
	float normalizer = (localsize-1) / (float)(size-1); 
	for (int inc=size;inc>0;inc>>=1) // binary search in the sub-sequence
	{
		int j = pos+inc-1;
		//normalize in local memory
		const int localplace =  normalizer * j;
		int confront2;
		const int2 temp1 =(int2)( find1[j],j);
		confront2 = temp1.x;
		lmem[localplace] = temp1;
		pos += (confront2 < pivot)  ? inc:0;
		pos = min(pos,size);
	}
		printf("dai che sono aiuto %i \n",get_local_id(0));
		printarrlocal(lmem,localsize*2);
	return pos;
}*/

/*inline int binaryLoc_local_blocks(int pivot, global int* find1, int size,local int* lmem, int localsize){
	int pos = 0;
	for (int inc=size;inc>0;inc>>=1) // binary search in the sub-sequence
	{
		int j = pos+inc-1;
		int confront2 = (j<localsize ? lmem[j] : find1[j]);
		pos += (confront2 < pivot)  ? inc:0;
		pos = min(pos,size);
	}
	return pos;
}*/


inline int binaryIndex_local_blocks(int pivot,global int* find1, int size,local int* lmem, int localsize){
        int l=0 ,m, r=size-1;
        while (l<=r ){
                m = l + ((r - l)>> 1);
                int confront1 =(m<localsize ? lmem[m] : find1[m]);
		//printf("sto confrontando pivot %i con %i\n",pivot,confront1);
                if ((confront1 < pivot) )
                    l = m +1;
                else
                    r = m -1;
        }
        return  l;
}

inline int binaryIndex_local_blocks_corr(char condition,int pivot,global int* find1, int size,local int* lmem, int localsize){
        int l=0 ,m, r=size-1;
        while (l<=r ){
                m = l + ((r - l)>> 1);
                int confront1 =(m<localsize ? lmem[m] : find1[m]);
		//printf("sto confrontando pivot %i con %i\n",pivot,confront1);
                if ((confront1 < pivot) || (condition && confront1==pivot))
                    l = m +1;
                else
                    r = m -1;
        }
        return  l;
}

inline int binaryIndex_local_with_HASH(int pivot,global int* find1, int size,local int2* lmem, int localsize){
        int l=0 ,m, r=size-1;
	float normalizer = (localsize-1) / (float)(size-1); 
        while (l<=r ){
                m = l + ((r - l)>> 1);
                int confront1 ;
		const int localplace =  normalizer * m;
		const int2 comp1 = lmem[localplace];
			//if(get_global_id(0))printf("dai per %i %i\n",comp1.x,localplace);
	       	if(comp1.x != INT_MAX){
			//if(get_global_id(0)==0)printf("ciao aiutami %i\n",comp1.x);
			confront1 = (comp1.y == m)? comp1.x:find1[m];
		}
		else{
			//if(get_global_id(0)==0)printarrlocal(lmem,localsize*2);
			const int2 temp1 =(int2)( find1[m],m);
			confront1 = temp1.x;
			lmem[localplace] = temp1;
			barrier(CLK_LOCAL_MEM_FENCE);
		}
		//printf("sto confrontando pivot %i con %i\n",pivot,confront1);
                if ((confront1 < pivot) )
                    l = m +1;
                else
                    r = m -1;
        }
        return  l;
}

inline int binaryIndex_local_HASH_corr(char condition,int pivot,global int* find1, int size,local int2* lmem, int localsize){
        if(size <= 0)return 0;
	if(size ==1 ){
		const int conf=find1[0];
		return (pivot>conf || (condition && pivot==conf));
	}
	int l=0 ,m, r=size-1;
	float normalizer = (localsize-1) / (float)(size-1); 
        while (l<=r){
                m = l + ((r - l)>> 1);
                int confront1 ;
		const int localplace =  normalizer * m;
		int2 comp1 = lmem[localplace];
	       	if(comp1.y != m){
			comp1  = (int2)( find1[m],m);
		}
		confront1=comp1.x;
		lmem[localplace]=comp1;
                if ((confront1 < pivot) || (condition && confront1==pivot) )
                    l = m +1;
                else
                    r = m -1;
        }
	barrier(CLK_LOCAL_MEM_FENCE);
        return  l;
}


inline int binaryLoc_corr(int li,int pivot, global int* find1, int size){
	int pos = 0;
	for (int inc=size;inc>0;inc>>=1) // binary search in the sub-sequence
	{
		int j = pos+inc-1;
		int confront2 = find1[j];
		pos += (confront2 < pivot) || ( confront2 == pivot && j < li ) ? inc:0;
		pos = min(pos,size);
	}
	return pos;
}

inline int binaryLoc_corr2(char condition,int pivot, global int* find1, int size){
	int pos = 0;
	for (int inc=size;inc>0;inc>>=1) // binary search in the sub-sequence
	{
		int j = pos+inc-1;
		int confront2 = find1[j];
		pos += (confront2 < pivot) || ( confront2 == pivot && condition ) ? inc:0;
		pos = min(pos,size);
	}
	return pos;
}

kernel void mergebinaryWithRepParallel(global int * out ,global int* arr,int nels, int subsize ){
        const int gi = get_global_id(0);
	if(gi>=nels)return;
	const int lws = get_local_size(0);
	const int subsetid = gi/subsize;
	int start,end,index;
	if((subsetid & 1)){
		start = (subsetid - 1) * subsize;
	} else{
		start = (subsetid + 1) * subsize;
	}
	end = (start + subsize) < nels ? start + subsize : nels;
	int locindex=0;
	if(start<nels) locindex = binaryIndex(arr[gi],arr + start , end - start);
	index=(gi-(subsetid & 1 ? subsize : 0))+locindex;
	out[index] = arr[gi];
	int repetition=gi;
	while(repetition + 1 < nels && arr[gi]==arr[repetition+1]){
		out[++index]=arr[repetition++];
	}
	repetition = start+locindex;
	while(repetition < nels && arr[repetition]==arr[gi]){
		out[++index]=arr[repetition++];
	}
}

kernel void mergebinaryWithRepParallelV3(global int * out ,global int* arr,int nels, int subsize ){
        const int gi = get_global_id(0);
	if(gi>=nels)return;
	const int lws = get_local_size(0);
	const int subsetid = gi/subsize;
	int start,end,index;
	char condition = subsetid & 1;
	if(condition){
		start = (subsetid - 1) * subsize;
	} else{
		start = (subsetid + 1) * subsize;
	}
	end = (start + subsize) < nels ? start + subsize : nels;
	int locindex=0;
	if(start<nels) locindex = binaryLoc_corr2(condition,arr[gi],arr + start , end - start);
	index=(gi-(condition ? subsize : 0))+locindex;
	out[index] = arr[gi];
	
}

kernel void mergebinaryWithRepParallelV4(global int * out ,global int* arr,int nels, int subsize ){
        const int gi = get_global_id(0);
	if(gi>=nels)return;
	const int subsetid = gi/subsize;
	int start,end,index;
	const int pivot = arr[gi];
	char condition = subsetid & 1;
	if(condition){
		start = (subsetid - 1) * subsize;
	} else{
		start = (subsetid + 1) * subsize;
	}
	end = (start + subsize) < nels ? start + subsize : nels;
	int locindex=0;
	if(start<nels) locindex = binaryIndexFullPower_corr(condition,pivot,arr + start , end - start);
	index=(gi-(condition ? subsize : 0))+locindex;
	out[index] = pivot;
	
}

kernel void mergebinaryWithRepParallelV2(global int * restrict out ,global int* restrict arr, int nels,int subsize ){
        const int gi = get_global_id(0);
	if(gi>=nels)return;
	const int lws = get_local_size(0);
	const int subsetid = gi/subsize;
	int start,end,index;
	char condition = (subsetid & 1);
	//condition for what part of the array the workitem need to consider to find minors
	if(condition){
		start = (subsetid - 1) * subsize;
	} else{
		start = (subsetid + 1) * subsize;
	}
	end = (start + subsize) < nels ? start + subsize : nels;
	const int first_index = gi -(condition*subsize);  //the elements in the array that are already minors of the pivot, startindex already inside
	int locindex=0;
	
	
	if(start<nels) locindex = binaryLoc_corr2(condition,arr[gi],arr + start , end - start);
	index = first_index + locindex;
	//if(gi<8)printf("ciao sono %i start %i end %i valore %i minori %i pos finale %i,  ho sx %i e dx %i condition %i\n",gi,start,end,arr[gi],locindex,index,arr[start+locindex-1],arr[start+locindex+1],condition);
	out[index] = arr[gi];
}

kernel void mergebinaryWithRepParallelV3local(global int * out ,global int* arr,int nels, int subsize, local int* lmem,int local_subsize ){
        const int gi = get_global_id(0);
	if(gi>=nels)return;
	const int lws = get_local_size(0);
	const int subsetid = gi/subsize;
	const int li = get_local_id(0);
	int start,end,index;
	local int first,last;
	char condition= subsetid &1;
	const int pivot = arr[gi];
	if((condition)){
		start = (subsetid - 1) * subsize;
	} else{
		start = (subsetid + 1) * subsize;
	}
	end = (start + subsize) < nels ? start + subsize : nels;
	int size = ((start + subsize) < nels ? subsize : nels - start);
	int locindex=0;
	//caricamento dei dati a cui siamo interessati in local memory
	if(li==0){
		first= binaryIndexFullPower_corr(condition,pivot, arr+start, size);

	}
	barrier(CLK_LOCAL_MEM_FENCE);
	if(li==get_local_size(0)-1){ 
		last =binaryIndexFullPower_corr(condition,pivot, arr+start+first, size - first);

	}
	barrier(CLK_LOCAL_MEM_FENCE);
	//loading elements from global memory to local memory
	for(unsigned stride=0;stride <local_subsize && stride<=last;stride+=lws){
		int locplace=li+stride;
		if(locplace<last)lmem[locplace] = arr[start+first+li+stride];
	}
	barrier(CLK_LOCAL_MEM_FENCE);
	if(start<nels) locindex = binaryIndex_local_blocks_corr(condition,pivot,arr + start + first , last,lmem,local_subsize);
	index=(gi-(condition ? subsize : 0))+locindex + first;
	out[index] = pivot;
	
}

kernel void mergebinaryWithRepParallelV4local(global int * out ,global int* arr,int nels, int subsize, local int2* lmem,int local_subsize ){
        const int gi = get_global_id(0);
	//if(gi>=nels)return;
	const int lws = get_local_size(0);
	const int subsetid = gi/subsize;
	const int li = get_local_id(0);
	int start,end,index;
	local int first,last;
	char condition= subsetid &1;
	int pivot=INT_MAX;
	if(gi<nels)
	pivot = arr[gi];
	//if(gi==0)printarr(arr,nels);
	if((condition)){
		start = (subsetid - 1) * subsize;
	} else{
		start = (subsetid + 1) * subsize;
	}
	end = (start + subsize) < nels ? start + subsize : nels;
	int size = ((start + subsize) < nels ? subsize : nels - start);
	int locindex=0;
	//caricamento dei dati a cui siamo interessati in local memory
	if(li==0){
		first= binaryIndexFullPower(pivot, arr+start, size);

	}
		//printarrlocal(lmem,local_doub_size*2);
		//if(gi == 0)printf("dai che ci siamo sto casso\n");
	barrier(CLK_LOCAL_MEM_FENCE);
	if(li==get_local_size(0)-1){ 
		last =binaryIndexFullPower_corr(condition,pivot, arr+start+first, size - first);

	}
	barrier(CLK_LOCAL_MEM_FENCE);
	//carichiamo in local memory una parte dell'array dove cercare
	if(li==0)lmem[0] = (int2)(0,-1);
	barrier(CLK_LOCAL_MEM_FENCE);
	if(start<nels) locindex = binaryIndex_local_HASH_corr(condition,pivot,arr + start + first , last,lmem,local_subsize);
	index=(gi-(condition ? subsize : 0))+locindex + first;
	//if(gi<8)printf("ciao sono %i   start %i valore %i minori %i pos finale %i,first %i last %i\n",gi,start,pivot,locindex,index,first,last);
	if(gi<nels)
	out[index] = pivot;
	//if(gi==0){printf("gi%igi",gi);printarrlocal(lmem,local_subsize*2);}
	//problema di numeri ripetuti che si trovano in posizioni che differiscono di un posto nei rispettivi subarray
	//risolto cambiando leggermente l'algoritmo di ricerca degli indici
	
}

kernel void mergebinaryWithRepHalfParallel(global int * out ,global int* arr,int nels, int subsize ){
        const int gi = get_global_id(0);
	if(gi>=round_mul_up((nels)>>1,subsize))return;
	const int gws = get_global_size(0);
	short subindex = 0;
	for(int shiftsize=subsize;shiftsize>1;shiftsize>>=1)subindex++;
	//questo algoritmo richiede che la subsize sia una potenza di 2, altrimenti diventa difficile calcolare gli indici
	int subitem = gi & (subsize-1);
	//arr_start è il punto dove devono lavorare i (subsize) workitem, non ho trovato un modo per ora di risolvere la lettura fuori dall'array se non con una condizione 
	const int arr_start = (gi>>subindex)*(subsize<<1);
	if(arr_start + subitem < nels){
		int pivot = arr[arr_start + subitem];
		int start = arr_start+subsize , index, size;
		size = ((start + subsize) < nels ? subsize : nels - start);
		int locindex=0;
		if(start<nels) locindex = binaryIndex(pivot , arr + start , size);
		int element_index = arr_start + subitem;
		index = element_index + locindex;
		out[index] = pivot;
		// index of the place in between the numbers(or at the end or start) where the pivot was "found"
		int place_index = start + locindex - 1;
		int current_index = index;
		//deve copiare tutti gli elementi che sono minori del pivot e maggiori del suo elemento precedente
		if(element_index > arr_start){
			while(place_index>=start && arr[element_index-1]<=arr[place_index] ){
				out[--current_index]=arr[place_index--];
			}
		}
		//se è il primo elemento deve vedere se ci sono elementi minori nel secondo array e copiarli
		if(!(subitem & (subsize - 1))){
			while(place_index>= start)out[--current_index]=arr[place_index--];
		}
		//se è l'ultimo elemento deve vedere se ci sono elementi ancora non considerati e copiarli nell'array destinazione
		if(subitem == subsize-1){
			int repetition = start+locindex;
			while(repetition< start + size){
				out[++index]=arr[repetition++];
			}
		}
	}
}

kernel void mergebinaryWithRepHalfParallelV2(global int * out ,global int* arr,int nels, int subsize ){
        const int gi = get_global_id(0);
	if(gi>=round_mul_up((nels)>>1,subsize))return;
	const int gws = get_global_size(0);
	short subindex = 0;
	for(int shiftsize=subsize;shiftsize>1;shiftsize>>=1)subindex++;
	//questo algoritmo richiede che la subsize sia una potenza di 2, altrimenti diventa difficile calcolare gli indici
	int subitem = gi & (subsize-1);
	//arr_start è il punto dove devono lavorare i (subsize) workitem, non ho trovato un modo per ora di risolvere la lettura fuori dall'array se non con una condizione 
	const int arr_start = (gi>>subindex)*(subsize<<1);
	if(arr_start + subitem < nels){
		int pivot = arr[arr_start + subitem];
		int start = arr_start+subsize , index, size;
		size = ((start + subsize) < nels ? subsize : nels - start);
		int locindex=0;
		if(start<nels) locindex = binaryIndexFullPower(pivot , arr + start , size);
		int element_index = arr_start + subitem;
		index = element_index + locindex;
		out[index] = pivot;
		// index of the place in between the numbers(or at the end or start) where the pivot was "found"
		int place_index = start + locindex - 1;
		int current_index = index;
		//deve copiare tutti gli elementi che sono minori del pivot e maggiori del suo elemento precedente
		if(element_index > arr_start){
			int comp_previous = arr[element_index-1],comp_other;
			while(place_index>=start && arr[element_index-1]<=(comp_other=arr[place_index]) ){
				out[--current_index]=comp_other;
				place_index--;
			}
		}
		//se è il primo elemento deve vedere se ci sono elementi minori nel secondo array e copiarli
		if(!(subitem & (subsize - 1))){
			while(place_index>= start)out[--current_index]=arr[place_index--];
		}
		//se è l'ultimo elemento deve vedere se ci sono elementi ancora non considerati e copiarli nell'array destinazione
		if(subitem == subsize-1){
			int repetition = start+locindex;
			while(repetition< start + size){
				out[++index]=arr[repetition++];
			}
		}
	}
}

kernel void mergebinaryWithRepHalfParallelV3local(global int * out ,global int* arr,int nels, int subsize ,local int2* lmem, int local_doub_size){
        const int gi = get_global_id(0);
	if(gi>=round_mul_up((nels)>>1,subsize))return;
	const int gws = get_global_size(0);
	const int li = get_local_id(0);
	const int lws = get_local_size(0);
	lmem[li]=(int2)(INT_MAX,-1);
	short subindex = 0;
	for(int shiftsize=subsize;shiftsize>1;shiftsize>>=1)subindex++;
	//questo algoritmo richiede che la subsize sia una potenza di 2, altrimenti diventa difficile calcolare gli indici
	int subitem = gi & (subsize-1),pivot=INT_MAX;
	//arr_start è il punto dove devono lavorare i (subsize) workitem, non ho trovato un modo per ora di risolvere la lettura fuori dall'array se non con una condizione 
	const int arr_start = (gi>>subindex)*(subsize<<1);
	local int first,last;
	if(arr_start + subitem < nels)
		 pivot = arr[arr_start + subitem];
	int start = arr_start+subsize , index, size;
	size = ((start + subsize) < nels ? subsize : nels - start);
	int locindex=0;
	if(li==0){
		first= binaryIndexPower(pivot, arr+start, size);

	}
	barrier(CLK_LOCAL_MEM_FENCE);
		//printarrlocal(lmem,local_doub_size*2);
		//if(gi == 0)printf("dai che ci siamo sto casso\n");

	if(li==get_local_size(0)-1){ 
		last = binaryIndexPower(pivot, arr+start+first, size - first);
		//printarrlocal(lmem,local_doub_size*2);

	}
	barrier(CLK_LOCAL_MEM_FENCE);
	if(start<nels) locindex =binaryIndex_local_with_HASH(pivot, arr+start+first, last - first ,lmem,local_doub_size);
	int element_index = arr_start + subitem;
	index = element_index + locindex + first;
	out[index] = pivot;
	// index of the place in between the numbers(or at the end or start) where the pivot was "found"
	int place_index = start + locindex - 1;
	int current_index = index;
	//deve copiare tutti gli elementi che sono minori del pivot e maggiori del suo elemento precedente
	if(element_index > arr_start){
		int comp_previous = arr[element_index-1],comp_other;
		while(place_index>=start && arr[element_index-1]<=(comp_other=arr[place_index]) ){
			out[--current_index]=comp_other;
			place_index--;
		}
	}
	//se è il primo elemento deve vedere se ci sono elementi minori nel secondo array e copiarli
	if(!(subitem & (subsize - 1))){
		while(place_index>= start)out[--current_index]=arr[place_index--];
	}
	//se è l'ultimo elemento deve vedere se ci sono elementi ancora non considerati e copiarli nell'array destinazione
	if(subitem == subsize-1){
		int repetition = start+locindex;
		while(repetition< start + size){
			out[++index]=arr[repetition++];
		}
	}
	
}

kernel void mergebinaryWithRepHalfParallelV4local(global int * out ,global int* arr,int nels, int subsize ,local int* lmem, int local_doub_size){
        const int gi = get_global_id(0);
	if(gi>=round_mul_up((nels)>>1,subsize))return;
	const int gws = get_global_size(0);
	const int li = get_local_id(0);
	const int lws = get_local_size(0);
		
	//if(gi==0)printarr(arr,nels);
	short subindex = 0;
	for(int shiftsize=subsize;shiftsize>1;shiftsize>>=1)subindex++;
	//questo algoritmo richiede che la subsize sia una potenza di 2, altrimenti diventa difficile calcolare gli indici
	int subitem = gi & (subsize-1),pivot=INT_MAX;
	//arr_start è il punto dove devono lavorare i (subsize) workitem, non ho trovato un modo per ora di risolvere la lettura fuori dall'array se non con una condizione 
	const int arr_start = (gi>>subindex)*(subsize<<1);
	local int first,last;
	if(gi <( nels>>1))
		 pivot = arr[arr_start + subitem];
	int start = arr_start+subsize , index, size;
	size = ((start + subsize) < nels ? subsize : nels - start);
	int locindex=0;
	//troviamo indici di inizio e fine 
	if(li==0){
		first= binaryIndexPower(pivot, arr+start, size);

	}
		//printarrlocal(lmem,local_doub_size*2);
		//if(gi == 0)printf("dai che ci siamo sto casso\n");
	barrier(CLK_LOCAL_MEM_FENCE);
	if(li==get_local_size(0)-1){ 
		last =binaryIndexPower(pivot, arr+start+first, size - first);

	}
	barrier(CLK_LOCAL_MEM_FENCE);
	//carichiamo in local memory una parte dell'array dove cercare
	for(unsigned stride=0;stride <local_doub_size && stride<=last;stride+=lws){
		int locplace=li+stride;
		if(locplace<last)lmem[locplace] = arr[start+first+li+stride];
	}
	//if(gi==0)printarr(arr,nels);
	barrier(CLK_LOCAL_MEM_FENCE);
	//if(gi==0){printf(" li%ili ",gi);printarrlocal(lmem,local_doub_size);}
	if(start<nels) locindex = binaryIndex_local_blocks(pivot, arr+start+first, last ,lmem,local_doub_size);
	int element_index = arr_start + subitem;
	index = element_index + locindex + first; 
	out[index] = pivot;
	//if(gi<8)printf("ciao sono %i arr_start %i subitem %i start %i valore %i minori %i pos finale %i,first %i last %i\n",gi,arr_start,subitem,start,pivot,locindex,index,first,last);
	// index of the place in between the numbers(or at the end or start) where the pivot was "found"
	int place_index = start + first +  locindex - 1;
	int current_index = index;
	//deve copiare tutti gli elementi che sono minori del pivot e maggiori del suo elemento precedente
	if(element_index > arr_start){
		int comp_previous = arr[element_index-1],comp_other;
		while(place_index>=start && arr[element_index-1]<=(comp_other=arr[place_index]) ){
			out[--current_index]=comp_other;
			place_index--;
		}
	}
	//se è il primo elemento deve vedere se ci sono elementi minori nel secondo array e copiarli
	if(!(subitem & (subsize - 1))){
		while(place_index>= start)out[--current_index]=arr[place_index--];
	}
	//se è l'ultimo elemento deve vedere se ci sono elementi ancora non considerati e copiarli nell'array destinazione
	if(subitem == subsize-1){
		int repetition = start + first +locindex;
		while(repetition< start + size){
			out[++index]=arr[repetition++];
		}
	}
	
}

//in teoria si potrebbe fare tutto il merge di tutti i sottogruppi, 
//solo che ci vorrebbe una azione di sincronia tra i workitem 
//che non si può avere dato che abbiamo già sforato il local worksize

kernel void mergebinaryNoRepParallel(global int * restrict out ,global int* restrict arr, int nels,int subsize ){
        const int gi = get_global_id(0);
	if(gi>=nels)return;
	//if(gi==0){printarr(arr, nels); printf("DOVE SONO AIUTO\n");}
	const int lws = get_local_size(0);
	const int subsetid = gi/subsize;
	int start,end,index;
	if((subsetid & 1)){
		start = (subsetid - 1) * subsize;
	} else{
		start = (subsetid + 1) * subsize;
	}
	end = (start + subsize) < nels ? start + subsize : nels;
	int locindex=0;
	if(start<nels) locindex = binaryIndex(arr[gi],arr + start , end - start);
	index=(gi-(subsetid & 1 ? subsize : 0))+locindex;
	out[index] = arr[gi];
	//printf("ciao sono %i start %i end %i valore %i minori %i pos finale %i\n",gi,start,end,arr[gi],locindex,index);
}





//inizialmente abbiamo meta dei workitem attivi, quindi gws = nels/2
kernel void mergesortnaive(global int * restrict arr,int nels){
	unsigned actives = nels >> 1;  //gli attivi sono inizialmente metà dei workitem
	uint gi=get_global_id(0);
	if(gi>=nels)return;
	uint initial_el = gi << 1;
	uint offset = 1;
	/* create temp arrays , no dynamic dimensions because not supported by opencl
	* local arrays cannot be created in nonkernel function
	*/
	//    local int L[512], R[512]; 
	  
	if(gi==0){printf("global_size e local_size %i  %i\n",get_global_size(0),get_local_size(0));}

	for(int i=1;i<nels;i<<=1){
		uint active_mask = i-1;
		offset <<= 1;
		//printf("maschera e offset %i  %i \n ",active_mask,offset);
		if((gi & active_mask))return;   //se sei un work_item non attivo ritorna
		//printf("sono il workitem numero %i ",gi);
		merge(arr + initial_el,arr + initial_el + (offset >> 1) , (offset >> 1), (offset >> 1) );
		//Merge(arr, initial_el, initial_el + (offset >> 1) ,initial_el + offset,L,R);
	}

}

kernel void ParallelMerge_Local(global const int * in,int nels,global int * out,local int * lmem)
{
	const int li = get_local_id(0);
	int wg = get_local_size(0);
	const int gi = get_global_id(0);
	// Move to the start of the subarray
	int offset = get_group_id(0) * wg;
	// see if we are at the end of the array
	wg = (offset+wg)<nels ? wg : nels - offset; 
	in += offset; out += offset;

	//loading in local memory
	if(li<wg)
	lmem[li] = in[li];
	barrier(CLK_LOCAL_MEM_FENCE); 

	  // merging sub-sequences of length 1,2,...,WG/2
	for (int length=1;length<wg;length<<=1)
	{
		int pivot = lmem[li];
		int ii = li & (length-1);  // index in our sequence in 0..length-1
		int sibling = (li - ii) ^ length; // beginning of the sibling to find the position
		int pos = 0;
		for (int inc=length;inc>0;inc>>=1) // binary search in the sub-sequence
		{
			int j = sibling+pos+inc-1;
			int confront2 = (j<wg ?  lmem[j] : INT_MAX);
			bool smaller = (confront2 < pivot) || ( confront2 == pivot && j < li );
			pos += (smaller)?inc:0;
			pos = min(pos,length);
		}
		int bits = (length<<1)-1; // mask for destination
		int dest = ((ii + pos) & bits) | (li & ~bits); // destination index in merged sequence
		barrier(CLK_LOCAL_MEM_FENCE);
		lmem[dest] = pivot;
		barrier(CLK_LOCAL_MEM_FENCE);
	}

  // Write output
  	if(li<wg)
	out[li] = lmem[li];
}

kernel void miosort(global int * restrict arr,int nels){
	int gi=get_global_id(0);
	
	if(gi>=nels/2)return;
	for(int i=0;i<nels/2;i++){
		int indexin=( (gi<<1) >= nels-1 ? 0 : gi<<1) ;
		int indexfin=(indexin+1 >= nels ? indexin : indexin+1);
			if(arr[indexin]>arr[indexfin]){
			int tmp = arr[indexfin];
			arr[indexfin]=arr[indexin];
			arr[indexin]=tmp;
		}
		int indexpast=indexin;
		indexin=(indexin+1>=nels ? 0 : indexin+1);
		indexfin=(indexpast+2 >= nels ? nels-1 : indexpast+2);
		barrier(CLK_GLOBAL_MEM_FENCE);
		if(arr[indexin]>arr[indexfin]){
			int tmp = arr[indexfin];
			arr[indexfin]=arr[indexin];
			arr[indexin]=tmp;
		}
		barrier(CLK_GLOBAL_MEM_FENCE);

	}

}

kernel void miosort_sliding(global int * restrict arr,const int nels){
	int gi=get_global_id(0);
	int lws = get_local_size(0);
	int gws = (nels+1)>>1;
	if(gi>=gws)return;
	int shift = lws << 1;
	for(int i=0;i<nels >> 1;i++){
		for(int sliding_off=0;sliding_off<nels;sliding_off += shift){
			int iniziamo = (((gi << 1) + 1 + sliding_off) >= nels);
			//printf("iniziamo di %i e\' %i\n", gi, iniziamo);  
			int indexin = ( iniziamo ? 0 : ((gi << 1) + sliding_off)) ;
			int indexfin= ( iniziamo  >= nels ? nels-1 : indexin+1);
			//if(gi <=8){printf("indexin %i e indexfin %i del %i workitem\n",indexin,indexfin,gi);}
			if(arr[indexin]>arr[indexfin]){
				int tmp = arr[indexfin];
				arr[indexfin]=arr[indexin];
				arr[indexin]=tmp;
			}
		}
		for(int sliding_off=0;sliding_off<nels;sliding_off += shift){
			int iniziamo = (((gi << 1) + 1 + sliding_off) >= nels);
			int indexin = ( iniziamo ? 0 : ((gi << 1) + sliding_off)) ;
			int indexfin= ( iniziamo  >= nels ? nels-1 : indexin+1);
			int indexpast=indexin;
			indexin=(indexin+2>=nels ? 0 : indexin+1);
			indexfin=(indexpast+2 >= nels ? nels-1 : indexpast+2);
			barrier(CLK_GLOBAL_MEM_FENCE);
			if(arr[indexin]>arr[indexfin]){
				int tmp = arr[indexfin];
				arr[indexfin]=arr[indexin];
				arr[indexin]=tmp;
			}
			barrier(CLK_GLOBAL_MEM_FENCE);
		}
	}

}

//TODO alcuni workitem dello stesso workgroup vengono bloccati nella barriera e bloccano tutti i workitem 
//nello stesso workgroup, bisognerebbe fare entrare tutti i workitem nello stesso workgroup
kernel void local_miosort(global int * restrict arr,int nels, local int* lmem){
	const int gi=get_global_id(0);
	if(gi>=(nels+1)/2)return;
	const uint lws=get_local_size(0);
	const uint groupid=get_group_id(0);
	const uint start=(get_group_id(0)*lws)<<1;
	const uint end=(start+(lws<<1)>nels ? nels : start+(lws<<1));
	const int li=get_local_id(0);
	//if(li==0)printf("block_id %i local_item %i start %i end %i\n",groupid,li,start,end);
	for(int i=0;i<lws;i++){
		int indexin=( (gi<<1) + 1 >= end ? start : gi<<1) ;
		int indexfin=(indexin + 1 >= end ? end-1 : indexin+1);
		//printf("indexin %i e indexfin %i del workitem %i\n",indexin,indexfin,gi);
		if(arr[indexin]>arr[indexfin]){
			int tmp = arr[indexfin];
			arr[indexfin]=arr[indexin];
			arr[indexin]=tmp;
		}
		int indexpast=indexin;
		indexin=(indexin+2>=end ? start : indexin+1);
		indexfin=(indexpast+2 >= end ? end-1 : indexpast+2);
		//printf("22indexin %i e indexfin %i del workitem %i\n",indexin,indexfin,gi);
		barrier(CLK_GLOBAL_MEM_FENCE);
		if(arr[indexin]>arr[indexfin]){
			int tmp = arr[indexfin];
			arr[indexfin]=arr[indexin];
			arr[indexin]=tmp;
		}
		barrier(CLK_GLOBAL_MEM_FENCE);

	}
	//if(gi==0)printarr(arr,nels);

}

kernel void local_miosort_lmem(global int * restrict arr,int nels, local int* lmem){
	const int gi=get_global_id(0);
	const uint lws=get_local_size(0);
	if(gi>=(nels+(lws>>1))/2)return;
	const uint groupid=get_group_id(0);
	const uint start=get_group_id(0)*(lws<<1);
	const uint end=(start+(lws<<1)>nels ? nels : start+(lws<<1));
	const uint el_lws = end-start ;
	const int li=get_local_id(0);
	const uint arr_local_index = li << 1;
	const uint arr_global_index = gi << 1;
	lmem[arr_local_index]=arr[arr_global_index];
	lmem[(arr_local_index)+1]=arr[(arr_global_index)+1];
	barrier(CLK_LOCAL_MEM_FENCE);
	//if(li==0)printf("block_id %i local_item %i start %i end %i\n",groupid,li,start,end);
//#pragma unroll
	for(int i=0;i<lws;i++){
		int indexin=( (arr_local_index)+1 >= el_lws ? 0 : arr_local_index) ;
		int indexfin=indexin+1;
		//printf("local indexin %i e local indexfin %i del workitem %i\n",indexin,indexfin,gi);
		if(lmem[indexin]>lmem[indexfin]){
			int tmp = lmem[indexfin];
			lmem[indexfin]=lmem[indexin];
			lmem[indexin]=tmp;
		}
		indexin=(indexin+2>=el_lws ? 0 : indexin+1);
		indexfin=indexin+1;
		//printf("2local indexin %i e local indexfin %i del workitem %i\n",indexin,indexfin,gi);
		barrier(CLK_LOCAL_MEM_FENCE);
		if(lmem[indexin]>lmem[indexfin]){
			int tmp = lmem[indexfin];
			lmem[indexfin]=lmem[indexin];
			lmem[indexin]=tmp;
		}
		barrier(CLK_LOCAL_MEM_FENCE);

	}
	arr[arr_global_index]=lmem[arr_local_index];
	arr[(arr_global_index)+1]=lmem[(arr_local_index)+1];
}

kernel void local_miosort_lmemV2(global int2 * restrict arr,int nels, local int* lmem){
	const int gi=get_global_id(0);
	const uint lws=get_local_size(0);
	if(gi>=(nels+(lws>>1))/2)return;
	const uint groupid=get_group_id(0);
	const uint start=get_group_id(0)*(lws<<1);
	const uint end=(start+(lws<<1)>nels ? nels : start+(lws<<1));
	const uint el_lws = end-start ;
	const int li=get_local_id(0);
	const uint arr_local_index = li << 1;
	int2 tmp= arr[gi];
	lmem[arr_local_index]=tmp.x;
	lmem[arr_local_index+1]=tmp.y;
	barrier(CLK_LOCAL_MEM_FENCE);
	//if(arr_local_index==0){printarr((global int*)arr,nels);printarrlocal(lmem,lws);}
//#pragma unroll
	for(int i=0;i<lws;i++){
		int indexin=( (arr_local_index)+1 >= el_lws ? 0 : arr_local_index) ;
		int indexfin=indexin+1;
		if(lmem[indexin]>lmem[indexfin]){
			int tmp = lmem[indexfin];
			lmem[indexfin]=lmem[indexin];
			lmem[indexin]=tmp;
		}
		indexin=(indexin+2>=el_lws ? 0 : indexin+1);
		indexfin=indexin+1;
		barrier(CLK_LOCAL_MEM_FENCE);
		if(lmem[indexin]>lmem[indexfin]){
			int tmp = lmem[indexfin];
			lmem[indexfin]=lmem[indexin];
			lmem[indexin]=tmp;
		}
		barrier(CLK_LOCAL_MEM_FENCE);

	}
	tmp = (int2)(lmem[arr_local_index],lmem[arr_local_index+1]);
	arr[gi]=tmp;
}

kernel void local_miosort_lmemV3(global int2 * restrict arr,int nels, local int* lmem){
	const int gi=get_global_id(0);
	const uint lws=get_local_size(0);
	if(gi>=(nels+(lws>>1))/2)return;
	const uint groupid=get_group_id(0);
	const uint start=get_group_id(0)*(lws<<1);
	const uint end=(start+(lws<<1)>nels ? nels : start+(lws<<1));
	const uint el_lws = end-start ;
	const int li=get_local_id(0);
	const uint arr_local_index = li << 1;
	int2 tmp= arr[gi];
	//we are supposing that the numer of elements is divisible for 2
	int indexfin1=arr_local_index | 1;
	int indexin2=(indexfin1<el_lws-1 ? indexfin1 : 0);
	int indexfin2=(indexin2 != 0 ? indexin2 + 1 : el_lws - 1);
	lmem[arr_local_index]=tmp.x;
	lmem[indexfin1]=tmp.y;
	barrier(CLK_LOCAL_MEM_FENCE);
	#pragma unroll
	for(int i=0;i< lws;i++){
		int confront1 = lmem[arr_local_index],confront2 = lmem[indexfin1];
		char comp=(confront1>confront2);
		lmem[indexfin1]=comp ? confront1 : confront2;
		lmem[arr_local_index]=comp ? confront2 : confront1;
		barrier(CLK_LOCAL_MEM_FENCE);
		confront1 = lmem[indexin2],confront2 = lmem[indexfin2];
		comp=(confront1>confront2);
		lmem[indexfin2]=comp ? confront1 : confront2;
		lmem[indexin2]=comp ? confront2 : confront1;
		barrier(CLK_LOCAL_MEM_FENCE);

	}
	tmp = (int2)(lmem[arr_local_index],lmem[indexfin1]);
	arr[gi]=tmp;
}

kernel void local_count_sort(global int * restrict arr,int nels,local int * lmem){
	const int gi= get_global_id(0);
	if(gi>=nels)return;
	int pivot = arr[gi];
	const int li=get_local_id(0);
	const int lws=get_local_size(0);
	const int groupid = get_group_id(0);
	const int first_el = groupid*lws;
	int counter=0,repetition=0;
	for(int i=first_el;i<(first_el + lws); i++){
		if(arr[i] == pivot){repetition++;}
		else if(arr[i] < pivot){counter++;}
	}
	barrier(CLK_LOCAL_MEM_FENCE);
	for(int i = 0; i < repetition; i++){
		arr[first_el+counter+i]=pivot;	
	}
}

kernel void local_count_sort_lmem(global int * restrict arr,int nels,local int * lmem){
	const int gi= get_global_id(0);
	if(gi>=nels)return;
	int pivot = arr[gi];
	const int li=get_local_id(0);
	lmem[li]=pivot;
	const int lws=get_local_size(0);
	const int groupid = get_group_id(0);
	const int first_el = groupid*lws;
	int counter=0,repetition=0;
	barrier(CLK_LOCAL_MEM_FENCE);
	for(int i=0;i<lws; i++){
		if(lmem[i] == pivot){repetition++;}
		else if(lmem[i] < pivot){counter++;}
	}
	barrier(CLK_LOCAL_MEM_FENCE);
	for(int i = 0; i < repetition; i++){
		arr[first_el+counter+i]=pivot;	
	}
}

/*int4 __OVERLOADABLE__  isless(int4 first,int4 second){	
	return (int4)((first.s0 < second.s0 ? 1 : 0), (first.s1 < second.s1 ? 1 : 0), (first.s2 < second.s2 ? 1 : 0), (first.s3 < second.s3 ? 1 : 0));
}

int4 __OVERLOADABLE__ isequal(int4 first,int4 second){
	return (int4)((first.s0 == second.s0 ? 1 : 0), (first.s1 == second.s1 ? 1 : 0), (first.s2 == second.s2 ? 1 : 0), (first.s3 == second.s3 ? 1 : 0));
}*/

inline void printvec(const int4 vect){
	printf("s0 = %i s1 = %i s2 = %i s3 = %i \n",vect.s0,vect.s1,vect.s2,vect.s3);
}

kernel void local_count_sort_vect(global int4 * restrict arr,int nels, global int* restrict res,local int4 * lmem){
	const int gi= get_global_id(0);
	const int nquarts=nels>>2;
	if(gi>=nels)return;
	int pivot = res[gi];
	const int li=get_local_id(0);
	const int lws=get_local_size(0);
	const int groupid = get_group_id(0);
	const int first_el = groupid*lws;
	const int first_quart = first_el>>2;
	int counter=0,repetition=0;
	int4 counter4 = (int4)(0),repetition4 = (int4)(0);
	for(int i=first_quart;i<(first_quart + (lws>>2)); i++){
		repetition4 -= arr[i] == pivot;
		counter4 -= arr[i] < pivot;
	}
	barrier(CLK_LOCAL_MEM_FENCE);
	repetition=repetition4.s0+repetition4.s1+repetition4.s2+repetition4.s3; 
	counter=counter4.s0+counter4.s1+counter4.s2+counter4.s3; 
	for(int i = 0; i < repetition; i++){
		res[ first_el + counter + i]=pivot;	
	}
}

kernel void local_count_sort_vectlmem(global int4 * restrict arr,int nels, global int* restrict res,local int4 * lmem){
	const int gi= get_global_id(0);
	const int nquarts=nels>>2;
	if(gi>=nels)return;


	int pivot = res[gi] ;
	const int li=get_local_id(0);
	const int lws=get_local_size(0);
	const int groupid = get_group_id(0);
	const int first_el = groupid*lws;
	const int first_quart = first_el>>2;
	const int reading_quarts=lws>>2;
	const int reading_place = (groupid * reading_quarts) + li; 
	if(li<reading_quarts){
		lmem[li] = arr[reading_place];
	}
	barrier(CLK_LOCAL_MEM_FENCE);
	int counter=0,repetition=0;
	int4 counter4 = (int4)(0),repetition4 = (int4)(0);
	for(int i=0;i<(reading_quarts); i++){
		repetition4 -= lmem[i]==pivot;
		counter4 -= lmem[i]< pivot;
	}
	barrier(CLK_LOCAL_MEM_FENCE);
	repetition=repetition4.s0+repetition4.s1+repetition4.s2+repetition4.s3; 
	counter=counter4.s0+counter4.s1+counter4.s2+counter4.s3; 
	for(int i = first_el + counter; i < first_el + counter + repetition; i++){
		res[i]=pivot;	
	}
}

kernel void local_count_sort_vectlmemV2(global int4 * restrict arr,int nels, global int* restrict res,local int4 * lmem){
	const int gi= get_global_id(0);
	const int place = gi & 3; 
	const int nquarts=nels>>2;
	const int group_id = get_group_id(0);
	int pivot;
	const int li=get_local_id(0);
	const int lws=get_local_size(0);
	const int first_el = group_id*lws;
	const int reading_quarts=(group_id == nels/lws ? (nels-(nels/lws)*lws)>>2 : lws>>2);
	const int reading_place = (group_id * (lws>>2)) + li;
		
	if(gi<nels){
		if(place == 0){
			pivot = arr[gi>>2].x;
		} else if(place == 1){
			pivot = arr[gi>>2].y;
		} else if(place == 2){
			pivot = arr[gi>>2].z;
		} else if(place == 3){
			pivot = arr[gi>>2].w;
		}
		if(li<reading_quarts){
			lmem[li] = arr[reading_place];
		}
		//if(group_id == nels/lws ){printf("MI CHIAMO %i NOME LOCALE %i reading_quarts %i reading_place %i DIMMI COSA SONO PER FAVORE %i\n",gi,li,reading_quarts,reading_place,arr[reading_place]);}
	}
	barrier(CLK_LOCAL_MEM_FENCE);
	int counter=0,repetition=0;
	int4 counter4 = (int4)(0),repetition4 = (int4)(0);
	if(gi<nels){
		for(int i=0;i<(reading_quarts); i++){
			repetition4 -= lmem[i]==pivot;
			counter4 -= lmem[i]<pivot;
		}
	}
	barrier(CLK_LOCAL_MEM_FENCE);
	if(gi<nels){
		repetition=repetition4.s0+repetition4.s1+repetition4.s2+repetition4.s3; 
		counter=counter4.s0+counter4.s1+counter4.s2+counter4.s3;
		for(int i = first_el + counter; i < first_el + counter + repetition; i++){
			res[i]=pivot;
		}
	}
}

kernel void local_count_sort_vectlmemV3(global int4 * restrict arr,int nels, global int* restrict res,local int4 * lmem){
	const int gi= get_global_id(0);
	const int group_id = get_group_id(0);
	int pivot;
	const int li=get_local_id(0);
	const int lws=get_local_size(0);
	const int first_el = group_id*lws;
	const int reading_quarts=(group_id == nels/lws ? (nels-(nels/lws)*lws)>>2 : lws>>2);
	const int reading_place = (group_id * (lws>>2)) + li;
	global int* restrict arr_scalar = (global int* )arr;
	if(gi<nels){
		pivot = arr_scalar[gi];
		if(li<reading_quarts){
			lmem[li] = arr[reading_place];
		}
	}
	barrier(CLK_LOCAL_MEM_FENCE);
	int counter=0,repetition=0;
	int4 counter4 = (int4)(0),repetition4 = (int4)(0);
	if(gi<nels){
		for(int i=0;i<(reading_quarts); i++){
			const int4 compar = lmem[i];
			repetition4 -= compar == pivot ;
			counter4 -= compar < pivot;
		}
	}
	barrier(CLK_LOCAL_MEM_FENCE);
	if(gi<nels){
		repetition=repetition4.s0+repetition4.s1+repetition4.s2+repetition4.s3; 
		counter=counter4.s0+counter4.s1+counter4.s2+counter4.s3;
		for(int i = first_el + counter; i < first_el + counter + repetition; i++){
			res[i]=pivot;
		}
	}
}

kernel void stable_local_count_sort_vectlmemV3(global int4 * restrict arr,int nels, global int* restrict res,local int4 * lmem){
	const int gi= get_global_id(0);
	const int group_id = get_group_id(0);
	int pivot;
	const int li=get_local_id(0);
	const int lws=get_local_size(0);
	const int first_el = group_id*lws;
	const int reading_quarts=(group_id == nels/lws ? (nels-(nels/lws)*lws)>>2 : lws>>2);
	const int reading_place = (group_id * (lws>>2)) + li;
	global int* restrict arr_scalar = (global int* )arr;
	if(gi<nels){
		pivot = arr_scalar[gi];
		if(li<reading_quarts){
			lmem[li] = arr[reading_place];
		}
	}
	barrier(CLK_LOCAL_MEM_FENCE);
	int counter=0,repetition=0;
	int4 counter4 = (int4)(0),repetition4 = (int4)(0);
	if(gi<nels){
		for(int i=0;i<(reading_quarts); i++){
			const int4 compar = lmem[i];
			repetition4 -= compar == pivot ;
			counter4 -= compar < pivot;
		}
	}
	barrier(CLK_LOCAL_MEM_FENCE);
	if(gi<nels){
		repetition=repetition4.s0+repetition4.s1+repetition4.s2+repetition4.s3; 
		counter=counter4.s0+counter4.s1+counter4.s2+counter4.s3;
		for(int i = first_el + counter; i < first_el + counter + repetition; i++){
			res[i]=pivot;
		}
	}
}
