kernel void vecinit(global int * restrict arr, int nels){
	
	const int i= get_global_id(0);	
		
	if(i>=nels)return;
	
	arr[i]=nels-i;

}


kernel void vecinit_rep(global int * restrict arr, int nels,int repetition){
	
	const int gi= get_global_id(0);	
		
	if(gi>=nels)return;
	for(int i =0; i < repetition; i++ )
		arr[gi*repetition+i]=nels-gi;
	

}

inline size_t round_mul_up(size_t gws, size_t lws)
{
	return ((gws + lws - 1)/lws)*lws;
}

uint MWC64X(uint2 *state)
{
    enum { A=4294883355U};
    uint x=(*state).x, c=(*state).y;  // Unpack the state
    uint res=x^c;                     // Calculate the result
    uint hi=mul_hi(x,A);              // Step the RNG
    x=x*A+c;
    c=hi+(x<c);
    *state=(uint2)(x,c);               // Pack the state back up
    return res;                       // Return the next result
}

inline uint xorshift(uint2 randoms,uint2 seeds){
	uint seed = randoms.x + get_global_id(0)-seeds.x;
	uint t = seed ^ (seed << 11) ^seeds.x;  
	return (seeds.y ^ randoms.y ^ (randoms.y >> 19) ^ (t ^ (t >> 8)));
}

kernel void vecinit_random(global uint * restrict arr,int seed1,int seed2, int nels){
	const int gi = get_global_id(0);
	if(gi >= nels) return;
	uint2 state = (uint2)(gi>>1,get_local_id(0)*gi);
	uint2 seeds = (uint2)(seed1,seed2);
	arr[gi] = (xorshift(state,seeds) & 31);
}


// needed helper methods
inline void swap(uint *a, uint *b) {
        uint tmp;
        tmp = *b;
        *b = *a;
        *a = tmp;
}

// dir == 1 means ascending
inline void sort(uint *a, uint *b, char dir) {
        if ((*a > *b) == dir) swap(a, b);
}

inline void swapLocal(__local uint *a, __local uint *b) {
        uint tmp;
        tmp = *b;
        *b = *a;
        *a = tmp;
}

// dir == 1 means ascending
inline void sortLocal(__local uint *a, __local uint *b, char dir) {
        if ((*a > *b) == dir) swapLocal(a, b);
}

inline void Merge(global int* restrict arr,
	uint start, uint middle, uint end,
	local int * L,local int * R){
	    int i, j, k; 
	    int n1 = middle -start+ 1; 
	    int n2 = end - middle; 
	  
	    	    /* Copy data to temiddlep arrays L[] and R[] */
	    for(i = 0; i < n1; i++) 
		L[i] = arr[start+ i]; 
	    for(j = 0; j < n2; j++) 
		R[j] = arr[middle + 1+ j]; 
	  
	    /* Merge the temiddlep arrays back into arr[l..r]*/
	    i = 0; // Initiastartindex of first subarray 
	    j = 0; // Initiastartindex of second subarray 
	    k =start; // Initiastartindex of middleerged subarray 
	    while (i < n1 && j < n2) 
	    { 
		if (L[i] <= R[j]) 
		{ 
		    arr[k] = L[i]; 
		    i++; 
		} 
		else
		{ 
		    arr[k] = R[j]; 
		    j++; 
		} 
		k++; 
	    } 
	  
	    /* Copy the remaining elements of L[], if there 
	       are any */
	    while (i < n1) 
	    { 
		arr[k] = L[i]; 
		i++; 
		k++; 
	    } 
	  
	    /* Copy the remeaining elements of R[], if there 
	       are any */
	    while (j < n2) 
	    { 
		arr[k] = R[j]; 
		j++; 
		k++; 
	    } 
}

void merge(global int* ar1,global int* ar2, int m, int n) 
{ 
    // Iterate through all elements of ar2[] starting from 
    // the last element 
    for (int i=n-1; i>=0; i--) 
    { 
        /* Find the smallest element greater than ar2[i]. Move all 
           elements one position ahead till the smallest greater 
           element is not found */
        int j, last = ar1[m-1]; 
        for (j=m-2; j >= 0 && ar1[j] > ar2[i]; j--) 
            ar1[j+1] = ar1[j]; 
  
        // If there was a greater element 
        if (j != m-2 || last > ar2[i]) 
        { 
            ar1[j+1] = ar2[i]; 
            ar2[i] = last; 
        } 
    } 
} 

inline void printarr(global int* arr,int nels){
		for(int i =0;i < nels;i++){
			printf("%i ",arr[i]);
			}
		printf("\n");

}

inline int binaryIndex(int pivot,global int* find1, int size){
        if(pivot>find1[size-1]){
		return size;
	}
        if(pivot<find1[0])return 0;
        int l=0 ,m, r=size-1 ;
        while (l <= r ) { 
                m = l + ((r - l)>> 1); 
                if ((m+1)<(size) && (pivot > find1[m]) && (find1[m+1] >= pivot)) 
                    return m+1; 
                if ((find1[m] < pivot) ) 
                    l = m + 1; 
                else
                    r = m - 1; 
        }
	return m; 
}

inline int binaryIndexV2(int pivot,global int* find1, int size,int condition,int gi){
        if( (condition && pivot>find1[size-1]) || (!condition && pivot>=find1[size-1]) ){
		return size;
	}
        /*if((condition && pivot<find1[0]) || (!condition && pivot<=find1[0]) )return 0;*/
        int l=0 ,m, r=size-1 ;
        while (l <= r ) { 
                m = l + ((r - l)>> 1); 
			//if(  gi<=7)printf("binary %i pivot %i find1[%i] %i find1[%i+1] %i condition %i\n ", gi,pivot,m , find1[m], m ,find1[m+1],condition);
                if ((m+1)<(size)){
			if( (condition && (pivot > find1[m]) && (find1[m+1] >= pivot)) || 
			(!condition && (pivot >= find1[m]) && (find1[m+1] > pivot)) ) 
			    return m+1;
		}
                if (m<size && m>=0 &&((condition && (find1[m] < pivot)) ||  (!condition && (find1[m] <= pivot)) ) )
                    l = m + 1; 
           
                else
                    r = m - 1; 
        }
	return m; 
}

kernel void mergebinaryWithRepParallel(global int * out ,global int* arr,int nels, int subsize ){
        const int gi = get_global_id(0);
	if(gi>=nels)return;
	const int lws = get_local_size(0);
	const int subsetid = gi/subsize;
	int start,end,index;
	if((subsetid & 1)){
		start = (subsetid - 1) * subsize;
	} else{
		start = (subsetid + 1) * subsize;
	}
	end = (start + subsize) < nels ? start + subsize : nels;
	int locindex=0;
	if(start<nels) locindex = binaryIndex(arr[gi],arr + start , end - start);
	index=(gi-(subsetid & 1 ? subsize : 0))+locindex;
	out[index] = arr[gi];
	//if(gi<8)printf("ciao sono %i start %i end %i valore %i minori %i pos finale %i,  ho sx %i e dx %i\n",gi,start,end,arr[gi],locindex,index,arr[start+locindex-1],arr[start+locindex+1]);
	int repetition=gi;
	while(repetition + 1 < nels && arr[gi]==arr[repetition+1]){
		out[++index]=arr[repetition++];
	}
	repetition = start+locindex;
	while(repetition < nels && arr[repetition]==arr[gi]){
		out[++index]=arr[repetition++];
	}
}

kernel void mergebinaryWithRepParallelV2(global int * restrict out ,global int* restrict arr, int nels,int subsize ){
        const int gi = get_global_id(0);
	if(gi>=nels)return;
	const int lws = get_local_size(0);
	const int subsetid = gi/subsize;
	int start,end,index;
	char condition = (subsetid & 1);
	//condition for what part of the array the workitem need to consider to find minors
	if(condition){
		start = (subsetid - 1) * subsize;
	} else{
		start = (subsetid + 1) * subsize;
	}
	end = (start + subsize) < nels ? start + subsize : nels;
	const int first_index = gi -(condition*subsize);  //the elements in the array that are already minors of the pivot, startindex already inside
	int locindex=0;
	if(start<nels) locindex = binaryIndexV2(arr[gi],arr + start , end - start,condition,gi);
	index = first_index + locindex;
	//if(gi<8)printf("ciao sono %i start %i end %i valore %i minori %i pos finale %i,  ho sx %i e dx %i condition %i\n",gi,start,end,arr[gi],locindex,index,arr[start+locindex-1],arr[start+locindex+1],condition);
	out[index] = arr[gi];
}

kernel void mergebinaryWithRepHalfParallel(global int * out ,global int* arr,int nels, int subsize ){
        const int gi = get_global_id(0);
	if(gi>=round_mul_up((nels)>>1,subsize))return;
	const int gws = get_global_size(0);
	short subindex = 0;
	for(int shiftsize=subsize;shiftsize>1;shiftsize>>=1)subindex++;
	//questo algoritmo richiede che la subsize sia una potenza di 2, altrimenti diventa difficile calcolare gli indici
	int subitem = gi & (subsize-1);
	//arr_start è il punto dove devono lavorare i (subsize) workitem, non ho trovato un modo per ora di risolvere la lettura fuori dall'array se non con una condizione 
	const int arr_start = (gi>>subindex)*(subsize<<1);
	if(arr_start + subitem < nels){
		int pivot = arr[arr_start + subitem];
		int start = arr_start+subsize , index, size;
		size = ((start + subsize) < nels ? subsize : nels - start);
		int locindex=0;
		if(start<nels) locindex = binaryIndex(pivot , arr + start , size);
		int element_index = arr_start + subitem;
		index = element_index + locindex;
		out[index] = pivot;
		// index of the place in between the numbers(or at the end or start) where the pivot was "found"
		int place_index = start + locindex - 1;
		int current_index = index;
		//deve copiare tutti gli elementi che sono minori del pivot e maggiori del suo elemento precedente
		if(element_index > arr_start){
			while(place_index>=start && arr[element_index-1]<=arr[place_index] ){
				out[--current_index]=arr[place_index--];
			}
		}
		//se è il primo elemento deve vedere se ci sono elementi minori nel secondo array e copiarli
		if(!(subitem & (subsize - 1))){
			while(place_index>= start)out[--current_index]=arr[place_index--];
		}
		//se è l'ultimo elemento deve vedere se ci sono elementi ancora non considerati e copiarli nell'array destinazione
		if(subitem == subsize-1){
			int repetition = start+locindex;
			while(repetition< start + size){
				out[++index]=arr[repetition++];
			}
		}
	}
}


/*
void mergebinaryNoRepHalfParallel(int * out,int nelstot ,int* arr2,int* arr1,int nels1,int nels2 ){
        int lastindex=0;
        for(int i=0;i<nels1;i++){
                int locindex = binaryIndex(arr1[i],arr2,nels2);
                int index = i + locindex;
                if(index>lastindex)lastindex=index;
                printf("per %i il posto e\' %i\n",arr1[i],index);
                out[index] = arr1[i];
                int minors = locindex-1;
                //printf("minors %i arr1 %i %i arr2 %i\n",minors,arr1[i-1],arr1[i],arr2[minors]);
                while(i-1>=0 && minors >= 0 &&  arr1[i-1]<=arr2[minors]){
                        printf("confronto %i < %i minors %i ",arr1[i-1],arr2[minors],minors);
                        out[--index]=arr2[minors--];
                        printf("per %i il posto e\' %i\n",arr1[minors+1],index+1);
                }
                
        }
        if(lastindex<nelstot-1){
                while(nelstot>lastindex+1){
                        out[--nelstot]=arr2[--nels2];
                }
        }
        
}*/

//in teoria si potrebbe fare tutto il merge di tutti i sottogruppi, 
//solo che ci vorrebbe una azione di sincronia tra i workitem 
//che non si può avere dato che abbiamo già sforato il local worksize

kernel void mergebinaryNoRepParallel(global int * restrict out ,global int* restrict arr, int nels,int subsize ){
        const int gi = get_global_id(0);
	if(gi>=nels)return;
	//if(gi==0){printarr(arr, nels); printf("DOVE SONO AIUTO\n");}
	const int lws = get_local_size(0);
	const int subsetid = gi/subsize;
	int start,end,index;
	if((subsetid & 1)){
		start = (subsetid - 1) * subsize;
	} else{
		start = (subsetid + 1) * subsize;
	}
	end = (start + subsize) < nels ? start + subsize : nels;
	int locindex=0;
	if(start<nels) locindex = binaryIndex(arr[gi],arr + start , end - start);
	index=(gi-(subsetid & 1 ? subsize : 0))+locindex;
	out[index] = arr[gi];
	//printf("ciao sono %i start %i end %i valore %i minori %i pos finale %i\n",gi,start,end,arr[gi],locindex,index);
}





//inizialmente abbiamo meta dei workitem attivi, quindi gws = nels/2
kernel void mergesortnaive(global int * restrict arr,int nels){
	unsigned actives = nels >> 1;  //gli attivi sono inizialmente metà dei workitem
	uint gi=get_global_id(0);
	if(gi>=nels)return;
	uint initial_el = gi << 1;
	uint offset = 1;
	/* create temp arrays , no dynamic dimensions because not supported by opencl
	* local arrays cannot be created in nonkernel function
	*/
	//    local int L[512], R[512]; 
	  
	if(gi==0){printf("global_size e local_size %i  %i\n",get_global_size(0),get_local_size(0));}

	for(int i=1;i<nels;i<<=1){
		uint active_mask = i-1;
		offset <<= 1;
		//printf("maschera e offset %i  %i \n ",active_mask,offset);
		if((gi & active_mask))return;   //se sei un work_item non attivo ritorna
		//printf("sono il workitem numero %i ",gi);
		merge(arr + initial_el,arr + initial_el + (offset >> 1) , (offset >> 1), (offset >> 1) );
		//Merge(arr, initial_el, initial_el + (offset >> 1) ,initial_el + offset,L,R);
	}

}

kernel void ParallelMerge_Local(global const int * in,global int * out,__local int * aux)
{
  int i = get_local_id(0);
  int wg = get_local_size(0);

  // Move IN, OUT to block start
  int offset = get_group_id(0) * wg;
  in += offset; out += offset;

  //loading in local memory
  aux[i] = in[i];
  barrier(CLK_LOCAL_MEM_FENCE); // make sure AUX is entirely up to date

  // Now we will merge sub-sequences of length 1,2,...,WG/2
  for (int length=1;length<wg;length<<=1)
  {
    int iData = aux[i];
    uint confront1 = iData;
    int ii = i & (length-1);  // index in our sequence in 0..length-1
    int sibling = (i - ii) ^ length; // beginning of the sibling sequence
    int pos = 0;
    for (int inc=length;inc>0;inc>>=1) // increment for dichotomic search
    {
      int j = sibling+pos+inc-1;
      uint confront2 = aux[j];
      bool smaller = (confront2 < confront1) || ( confront2 == confront1 && j < i );
      pos += (smaller)?inc:0;
      pos = min(pos,length);
    }
    int bits = 2*length-1; // mask for destination
    int dest = ((ii + pos) & bits) | (i & ~bits); // destination index in merged sequence
    barrier(CLK_LOCAL_MEM_FENCE);
    aux[dest] = iData;
    barrier(CLK_LOCAL_MEM_FENCE);
  }

  // Write output
  out[i] = aux[i];
}

kernel void miosort(global int * restrict arr,int nels){
	int gi=get_global_id(0);
	
	if(gi>=nels/2)return;
	for(int i=0;i<nels/2;i++){
		int indexin=( (gi<<1) >= nels-1 ? 0 : gi<<1) ;
		int indexfin=(indexin+1 >= nels ? indexin : indexin+1);
			if(arr[indexin]>arr[indexfin]){
			int tmp = arr[indexfin];
			arr[indexfin]=arr[indexin];
			arr[indexin]=tmp;
		}
		int indexpast=indexin;
		indexin=(indexin+1>=nels ? 0 : indexin+1);
		indexfin=(indexpast+2 >= nels ? nels-1 : indexpast+2);
		barrier(CLK_GLOBAL_MEM_FENCE);
		if(arr[indexin]>arr[indexfin]){
			int tmp = arr[indexfin];
			arr[indexfin]=arr[indexin];
			arr[indexin]=tmp;
		}
		barrier(CLK_GLOBAL_MEM_FENCE);

	}

}

kernel void miosort_sliding(global int * restrict arr,const int nels){
	int gi=get_global_id(0);
	int lws = get_local_size(0);
	int gws = (nels+1)>>1;
	if(gi>=gws)return;
	int shift = lws << 1;
	for(int i=0;i<nels >> 1;i++){
		for(int sliding_off=0;sliding_off<nels;sliding_off += shift){
			int iniziamo = (((gi << 1) + 1 + sliding_off) >= nels);
			//printf("iniziamo di %i e\' %i\n", gi, iniziamo);  
			int indexin = ( iniziamo ? 0 : ((gi << 1) + sliding_off)) ;
			int indexfin= ( iniziamo  >= nels ? nels-1 : indexin+1);
			//if(gi <=8){printf("indexin %i e indexfin %i del %i workitem\n",indexin,indexfin,gi);}
			if(arr[indexin]>arr[indexfin]){
				int tmp = arr[indexfin];
				arr[indexfin]=arr[indexin];
				arr[indexin]=tmp;
			}
		}
		for(int sliding_off=0;sliding_off<nels;sliding_off += shift){
			int iniziamo = (((gi << 1) + 1 + sliding_off) >= nels);
			int indexin = ( iniziamo ? 0 : ((gi << 1) + sliding_off)) ;
			int indexfin= ( iniziamo  >= nels ? nels-1 : indexin+1);
			int indexpast=indexin;
			indexin=(indexin+2>=nels ? 0 : indexin+1);
			indexfin=(indexpast+2 >= nels ? nels-1 : indexpast+2);
			barrier(CLK_GLOBAL_MEM_FENCE);
			if(arr[indexin]>arr[indexfin]){
				int tmp = arr[indexfin];
				arr[indexfin]=arr[indexin];
				arr[indexin]=tmp;
			}
			barrier(CLK_GLOBAL_MEM_FENCE);
		}
	}

}

//TODO alcuni workitem dello stesso workgroup vengono bloccati nella barriera e bloccano tutti i workitem 
//nello stesso workgroup, bisognerebbe fare entrare tutti i workitem nello stesso workgroup
kernel void local_miosort(global int * restrict arr,int nels, local int* lmem){
	const int gi=get_global_id(0);
	if(gi>=(nels+1)/2)return;
	const uint lws=get_local_size(0);
	const uint groupid=get_group_id(0);
	const uint start=(get_group_id(0)*lws)<<1;
	const uint end=(start+(lws<<1)>nels ? nels : start+(lws<<1));
	const int li=get_local_id(0);
	//if(li==0)printf("block_id %i local_item %i start %i end %i\n",groupid,li,start,end);
	for(int i=0;i<lws;i++){
		int indexin=( (gi<<1) + 1 >= end ? start : gi<<1) ;
		int indexfin=(indexin + 1 >= end ? end-1 : indexin+1);
		//printf("indexin %i e indexfin %i del workitem %i\n",indexin,indexfin,gi);
		if(arr[indexin]>arr[indexfin]){
			int tmp = arr[indexfin];
			arr[indexfin]=arr[indexin];
			arr[indexin]=tmp;
		}
		int indexpast=indexin;
		indexin=(indexin+2>=end ? start : indexin+1);
		indexfin=(indexpast+2 >= end ? end-1 : indexpast+2);
		//printf("22indexin %i e indexfin %i del workitem %i\n",indexin,indexfin,gi);
		barrier(CLK_GLOBAL_MEM_FENCE);
		if(arr[indexin]>arr[indexfin]){
			int tmp = arr[indexfin];
			arr[indexfin]=arr[indexin];
			arr[indexin]=tmp;
		}
		barrier(CLK_GLOBAL_MEM_FENCE);

	}
	//if(gi==0)printarr(arr,nels);

}

kernel void local_miosort_lmem(global int * restrict arr,int nels, local int* lmem){
	const int gi=get_global_id(0);
	const uint lws=get_local_size(0);
	if(gi>=(nels+(lws>>1))/2)return;
	const uint groupid=get_group_id(0);
	const uint start=get_group_id(0)*(lws<<1);
	const uint end=(start+(lws<<1)>nels ? nels : start+(lws<<1));
	const uint el_lws = end-start ;
	const int li=get_local_id(0);
	const uint arr_local_index = li << 1;
	const uint arr_global_index = gi << 1;
	lmem[arr_local_index]=arr[arr_global_index];
	lmem[(arr_local_index)+1]=arr[(arr_global_index)+1];
	barrier(CLK_LOCAL_MEM_FENCE);
	//if(li==0)printf("block_id %i local_item %i start %i end %i\n",groupid,li,start,end);
//#pragma unroll
	for(int i=0;i<lws;i++){
		int indexin=( (arr_local_index)+1 >= el_lws ? 0 : arr_local_index) ;
		int indexfin=indexin+1;
		//printf("local indexin %i e local indexfin %i del workitem %i\n",indexin,indexfin,gi);
		if(lmem[indexin]>lmem[indexfin]){
			int tmp = lmem[indexfin];
			lmem[indexfin]=lmem[indexin];
			lmem[indexin]=tmp;
		}
		indexin=(indexin+2>=el_lws ? 0 : indexin+1);
		indexfin=indexin+1;
		//printf("2local indexin %i e local indexfin %i del workitem %i\n",indexin,indexfin,gi);
		barrier(CLK_LOCAL_MEM_FENCE);
		if(lmem[indexin]>lmem[indexfin]){
			int tmp = lmem[indexfin];
			lmem[indexfin]=lmem[indexin];
			lmem[indexin]=tmp;
		}
		barrier(CLK_LOCAL_MEM_FENCE);

	}
	arr[arr_global_index]=lmem[arr_local_index];
	arr[(arr_global_index)+1]=lmem[(arr_local_index)+1];
}


kernel void local_count_sort(global int * restrict arr,int nels,local int * lmem){
	const int gi= get_global_id(0);
	if(gi>=nels)return;
	int pivot = arr[gi];
	const int li=get_local_id(0);
	const int lws=get_local_size(0);
	const int groupid = get_group_id(0);
	const int first_el = groupid*lws;
	int counter=0,repetition=0;
	for(int i=first_el;i<(first_el + lws); i++){
		if(arr[i] == pivot){repetition++;}
		else if(arr[i] < pivot){counter++;}
	}
	barrier(CLK_LOCAL_MEM_FENCE);
	for(int i = 0; i < repetition; i++){
		arr[first_el+counter+i]=pivot;	
	}
}

kernel void local_count_sort_lmem(global int * restrict arr,int nels,local int * lmem){
	const int gi= get_global_id(0);
	if(gi>=nels)return;
	int pivot = arr[gi];
	const int li=get_local_id(0);
	lmem[li]=pivot;
	const int lws=get_local_size(0);
	const int groupid = get_group_id(0);
	const int first_el = groupid*lws;
	int counter=0,repetition=0;
	barrier(CLK_LOCAL_MEM_FENCE);
	for(int i=0;i<lws; i++){
		if(lmem[i] == pivot){repetition++;}
		else if(lmem[i] < pivot){counter++;}
	}
	barrier(CLK_LOCAL_MEM_FENCE);
	for(int i = 0; i < repetition; i++){
		arr[first_el+counter+i]=pivot;	
	}
}

/*int4 __OVERLOADABLE__  isless(int4 first,int4 second){	
	return (int4)((first.s0 < second.s0 ? 1 : 0), (first.s1 < second.s1 ? 1 : 0), (first.s2 < second.s2 ? 1 : 0), (first.s3 < second.s3 ? 1 : 0));
}

int4 __OVERLOADABLE__ isequal(int4 first,int4 second){
	return (int4)((first.s0 == second.s0 ? 1 : 0), (first.s1 == second.s1 ? 1 : 0), (first.s2 == second.s2 ? 1 : 0), (first.s3 == second.s3 ? 1 : 0));
}*/

inline void printvec(const int4 vect){
	printf("s0 = %i s1 = %i s2 = %i s3 = %i \n",vect.s0,vect.s1,vect.s2,vect.s3);
}

kernel void local_count_sort_vect(global int4 * restrict arr,int nels, global int* restrict res,local int4 * lmem){
	const int gi= get_global_id(0);
	const int nquarts=nels>>2;
	if(gi>=nels)return;
	int pivot = res[gi];
	const int li=get_local_id(0);
	const int lws=get_local_size(0);
	const int groupid = get_group_id(0);
	const int first_el = groupid*lws;
	const int first_quart = first_el>>2;
	int counter=0,repetition=0;
	int4 counter4 = (int4)(0),repetition4 = (int4)(0);
	for(int i=first_quart;i<(first_quart + (lws>>2)); i++){
		repetition4 -= arr[i] == pivot;
		counter4 -= arr[i] < pivot;
	}
	barrier(CLK_LOCAL_MEM_FENCE);
	repetition=repetition4.s0+repetition4.s1+repetition4.s2+repetition4.s3; 
	counter=counter4.s0+counter4.s1+counter4.s2+counter4.s3; 
	for(int i = 0; i < repetition; i++){
		res[ first_el + counter + i]=pivot;	
	}
}

kernel void local_count_sort_vectlmem(global int4 * restrict arr,int nels, global int* restrict res,local int4 * lmem){
	const int gi= get_global_id(0);
	const int nquarts=nels>>2;
	if(gi>=nels)return;


	int pivot = res[gi] ;
	const int li=get_local_id(0);
	const int lws=get_local_size(0);
	const int groupid = get_group_id(0);
	const int first_el = groupid*lws;
	const int first_quart = first_el>>2;
	const int reading_quarts=lws>>2;
	const int reading_place = (groupid * reading_quarts) + li; 
	if(li<reading_quarts){
		lmem[li] = arr[reading_place];
	}
	barrier(CLK_LOCAL_MEM_FENCE);
	int counter=0,repetition=0;
	int4 counter4 = (int4)(0),repetition4 = (int4)(0);
	for(int i=0;i<(reading_quarts); i++){
		repetition4 -= lmem[i]==pivot;
		counter4 -= lmem[i]< pivot;
	}
	barrier(CLK_LOCAL_MEM_FENCE);
	repetition=repetition4.s0+repetition4.s1+repetition4.s2+repetition4.s3; 
	counter=counter4.s0+counter4.s1+counter4.s2+counter4.s3; 
	for(int i = first_el + counter; i < first_el + counter + repetition; i++){
		res[i]=pivot;	
	}
}

kernel void local_count_sort_vectlmemV2(global int4 * restrict arr,int nels, global int* restrict res,local int4 * lmem){
	const int gi= get_global_id(0);
	const int place = gi & 3; 
	const int nquarts=nels>>2;
	const int group_id = get_group_id(0);
	int pivot;
	const int li=get_local_id(0);
	const int lws=get_local_size(0);
	const int first_el = group_id*lws;
	const int first_quart = first_el>>2;
	const int reading_quarts=(group_id == nels/lws ? (nels-(nels/lws)*lws)>>2 : lws>>2);
	const int reading_place = (group_id * (lws>>2)) + li;
		
	if(gi<nels){
		if(place == 0){
			pivot = arr[gi>>2].x;
		} else if(place == 1){
			pivot = arr[gi>>2].y;
		} else if(place == 2){
			pivot = arr[gi>>2].z;
		} else if(place == 3){
			pivot = arr[gi>>2].w;
		}
		if(li<reading_quarts){
			lmem[li] = arr[reading_place];
		}
		//if(group_id == nels/lws ){printf("MI CHIAMO %i NOME LOCALE %i reading_quarts %i reading_place %i DIMMI COSA SONO PER FAVORE %i\n",gi,li,reading_quarts,reading_place,arr[reading_place]);}
	}
	barrier(CLK_LOCAL_MEM_FENCE);
	int counter=0,repetition=0;
	int4 counter4 = (int4)(0),repetition4 = (int4)(0);
	if(gi<nels){
		for(int i=0;i<(reading_quarts); i++){
			repetition4 -= lmem[i]==pivot;
			counter4 -= lmem[i]<pivot;
		}
	}
	barrier(CLK_LOCAL_MEM_FENCE);
	if(gi<nels){
		repetition=repetition4.s0+repetition4.s1+repetition4.s2+repetition4.s3; 
		counter=counter4.s0+counter4.s1+counter4.s2+counter4.s3;
		for(int i = first_el + counter; i < first_el + counter + repetition; i++){
			res[i]=pivot;
		}
	}
}

kernel void local_count_sort_vectlmemV3(global int4 * restrict arr,int nels, global int* restrict res,local int4 * lmem){
	const int gi= get_global_id(0);
	const int place = gi & 3; 
	const int nquarts=nels>>2;
	const int group_id = get_group_id(0);
	int pivot;
	const int li=get_local_id(0);
	const int lws=get_local_size(0);
	const int first_el = group_id*lws;
	const int first_quart = first_el>>2;
	const int reading_quarts=(group_id == nels/lws ? (nels-(nels/lws)*lws)>>2 : lws>>2);
	const int reading_place = (group_id * (lws>>2)) + li;
	global int* restrict arr_scalar = (global int* )arr;
	if(gi<nels){
		pivot = arr_scalar[gi];
		if(li<reading_quarts){
			lmem[li] = arr[reading_place];
		}
		//if(group_id == nels/lws ){printf("MI CHIAMO %i NOME LOCALE %i reading_quarts %i reading_place %i DIMMI COSA SONO PER FAVORE %i\n",gi,li,reading_quarts,reading_place,arr[reading_place]);}
	}
	barrier(CLK_LOCAL_MEM_FENCE);
	int counter=0,repetition=0;
	int4 counter4 = (int4)(0),repetition4 = (int4)(0);
	if(gi<nels){
		for(int i=0;i<(reading_quarts); i++){
			repetition4 -= lmem[i] == pivot ;
			counter4 -= lmem[i] < pivot;
		}
	}
	barrier(CLK_LOCAL_MEM_FENCE);
	if(gi<nels){
		repetition=repetition4.s0+repetition4.s1+repetition4.s2+repetition4.s3; 
		counter=counter4.s0+counter4.s1+counter4.s2+counter4.s3;
		for(int i = first_el + counter; i < first_el + counter + repetition; i++){
			res[i]=pivot;
		}
	}
}
