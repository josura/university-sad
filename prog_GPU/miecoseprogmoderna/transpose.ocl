kernel void matinit(global int *A, int nrows, int ncols)
{
	int r = get_global_id(1);
	int c = get_global_id(0);

	if (c >= ncols) return;

	A[r*ncols + c] = r - c;
}

kernel void transpose(
	global int * restrict T,
	global const int * restrict A,
	int nrows_T, int ncols_T)
{
	const int r_T = get_global_id(1);
	const int c_T = get_global_id(0);

	if (c_T >= ncols_T) return;
	if (r_T >= nrows_T) return;

	const int r_A = c_T;
	const int c_A = r_T;
	const int ncols_A = nrows_T;

	// T[ c_A*rows_A + r_A ] = A[ r_A*ncols_A + c_A ];
	T[ r_T*ncols_T + c_T ] = A[ r_A*ncols_A + c_A ];
}

kernel void transpose2(
	global int2 * restrict T,
	global const int2 * restrict A,
	// assumption: nrows_T and ncols_T multiples of 2
	int nrows_T, int ncols_T)
{
	const int nvcols_T = ncols_T/2;

	const int c2_T = get_global_id(0); /* da 0 a ncols_T/2 */
	const int r2_T = get_global_id(1); /* da 0 a nrows_T/2 */

	if (c2_T >= nvcols_T) return;
	if (r2_T >= nrows_T/2) return;

	const int c2_A = r2_T;
	const int r2_A = c2_T;
	const int nvcols_A = nrows_T/2;

	const int2 v0 = A[ (2*r2_A + 0)*nvcols_A + c2_A ];
	const int2 v1 = A[ (2*r2_A + 1)*nvcols_A + c2_A ];

	const int2 w0 = (int2)(v0.x, v1.x);
	const int2 w1 = (int2)(v0.y, v1.y);

	T[ (2*r2_T + 0)*nvcols_T + c2_T ] = w0;
	T[ (2*r2_T + 1)*nvcols_T + c2_T ] = w1;
}

kernel void transpose4(
	global int4 * restrict T,
	global const int4 * restrict A,
	// assumption: nrows_T and ncols_T multiples of 4
	int nrows_T, int ncols_T)
{
	const int nvcols_T = ncols_T/4;

	const int c4_T = get_global_id(0); /* da 0 a ncols_T/4 */
	const int r4_T = get_global_id(1); /* da 0 a nrows_T/4 */

	if (c4_T >= nvcols_T) return;
	if (r4_T >= nrows_T/4) return;

	const int c4_A = r4_T;
	const int r4_A = c4_T;
	const int nvcols_A = nrows_T/4;

	const int4 v0 = A[ (4*r4_A + 0)*nvcols_A + c4_A ];
	const int4 v1 = A[ (4*r4_A + 1)*nvcols_A + c4_A ];
	const int4 v2 = A[ (4*r4_A + 2)*nvcols_A + c4_A ];
	const int4 v3 = A[ (4*r4_A + 3)*nvcols_A + c4_A ];

	const int4 w0 = (int4)(v0.s0, v1.s0, v2.s0, v3.s0);
	const int4 w1 = (int4)(v0.s1, v1.s1, v2.s1, v3.s1);
	const int4 w2 = (int4)(v0.s2, v1.s2, v2.s2, v3.s2);
	const int4 w3 = (int4)(v0.s3, v1.s3, v2.s3, v3.s3);

	T[ (4*r4_T + 0)*nvcols_T + c4_T ] = w0;
	T[ (4*r4_T + 1)*nvcols_T + c4_T ] = w1;
	T[ (4*r4_T + 2)*nvcols_T + c4_T ] = w2;
	T[ (4*r4_T + 3)*nvcols_T + c4_T ] = w3;
}

kernel void transpose8(
	global int8 * restrict T,
	global const int8 * restrict A,
	// assumption: nrows_T and ncols_T multiples of 8
	int nrows_T, int ncols_T)
{
	const int nvcols_T = ncols_T/8;

	const int c8_T = get_global_id(0); /* da 0 a ncols_T/4 */
	const int r8_T = get_global_id(1); /* da 0 a nrows_T/4 */

	if (c8_T >= nvcols_T) return;
	if (r8_T >= nrows_T/8) return;

	const int c8_A = r8_T;
	const int r8_A = c8_T;
	const int nvcols_A = nrows_T/8;

	const int8 v0 = A[ (8*r8_A + 0)*nvcols_A + c8_A ];
	const int8 v1 = A[ (8*r8_A + 1)*nvcols_A + c8_A ];
	const int8 v2 = A[ (8*r8_A + 2)*nvcols_A + c8_A ];
	const int8 v3 = A[ (8*r8_A + 3)*nvcols_A + c8_A ];
	const int8 v4 = A[ (8*r8_A + 4)*nvcols_A + c8_A ];
	const int8 v5 = A[ (8*r8_A + 5)*nvcols_A + c8_A ];
	const int8 v6 = A[ (8*r8_A + 6)*nvcols_A + c8_A ];
	const int8 v7 = A[ (8*r8_A + 7)*nvcols_A + c8_A ];


	const int8 w0 = (int8)(v0.s0, v1.s0, v2.s0, v3.s0,v4.s0, v5.s0, v6.s0, v7.s0);
	const int8 w1 = (int8)(v0.s1, v1.s1, v2.s1, v3.s1,v4.s1, v5.s1, v6.s1, v7.s1);
	const int8 w2 = (int8)(v0.s2, v1.s2, v2.s2, v3.s2,v4.s2, v5.s2, v6.s2, v7.s2);
	const int8 w3 = (int8)(v0.s3, v1.s3, v2.s3, v3.s3,v4.s3, v5.s3, v6.s3, v7.s3);
	const int8 w4 = (int8)(v0.s4, v1.s4, v2.s4, v3.s4,v4.s4, v5.s4, v6.s4, v7.s4);
	const int8 w5 = (int8)(v0.s5, v1.s5, v2.s5, v3.s5,v4.s5, v5.s5, v6.s5, v7.s5);
	const int8 w6 = (int8)(v0.s6, v1.s6, v2.s6, v3.s6,v4.s6, v5.s6, v6.s6, v7.s6);
	const int8 w7 = (int8)(v0.s7, v1.s7, v2.s7, v3.s7,v4.s7, v5.s7, v6.s7, v7.s7);

	T[ (8*r8_T + 0)*nvcols_T + c8_T ] = w0;
	T[ (8*r8_T + 1)*nvcols_T + c8_T ] = w1;
	T[ (8*r8_T + 2)*nvcols_T + c8_T ] = w2;
	T[ (8*r8_T + 3)*nvcols_T + c8_T ] = w3;
	T[ (8*r8_T + 4)*nvcols_T + c8_T ] = w4;
	T[ (8*r8_T + 5)*nvcols_T + c8_T ] = w5;
	T[ (8*r8_T + 6)*nvcols_T + c8_T ] = w6;
	T[ (8*r8_T + 7)*nvcols_T + c8_T ] = w7;
}

/* Requirements:
   * square work-group size (lxl)
   * cache sized as l*l*sizeof(cl_int)
*/
kernel void transpose_lmem(
	global int * restrict T,
	global const int * restrict A,
	int nrows_T, int ncols_T,
	local int * restrict cache)
{
	const int local_size = get_local_size(0); // or get_local_size(1), which should be the same
	const int block_row_T = get_group_id(1);
	const int block_col_T = get_group_id(0);
	const int block_row_A = block_col_T;
	const int block_col_A = block_row_T;

	const int r_A = block_row_A*local_size + get_local_id(1);
	const int c_A = block_col_A*local_size + get_local_id(0);
	const int ncols_A = nrows_T;

	if (c_A < ncols_A && r_A < ncols_T)
		cache[get_local_id(1)*(local_size+1) + get_local_id(0)] = A[r_A*ncols_A  +  c_A];

	barrier(CLK_LOCAL_MEM_FENCE);

	const int r_T = get_global_id(1); // get_group_id(1)*get_local_size(1)+get_local_id(1)
	const int c_T = get_global_id(0); // get_group_id(0)*get_local_size(0)+get_local_id(0)

	if (c_T < ncols_T && r_T < nrows_T)
		T[r_T*ncols_T + c_T] = cache[get_local_id(0)*(local_size+1) + get_local_id(1)];
}


kernel void transpose_lmem_vect(
	global int4 * restrict T,
	global const int4 * restrict A,
	int nrows_quarts_T, int ncols_quarts_T,
	local int4 * restrict cache)
{
	const int local_size = get_local_size(0); // or get_local_size(1), which should be the same
	const int block_row_T = get_group_id(1);
	const int block_col_T = get_group_id(0);
	const int block_row_A = block_col_T;
	const int block_col_A = block_row_T;

	const int r_A = block_row_A*local_size + get_local_id(1);      //get_global_id(1)
	const int c_A = block_col_A*local_size + get_local_id(0);      //get_global_id(0)
	const int ncols_quarts_A = nrows_quarts_T;

	if (c_A >= nrows_quarts_T) return;
	if (r_A >= ncols_quarts_T) return;
	
	if (c_A < ncols_quarts_A && r_A < ncols_quarts_T)
		cache[get_local_id(1)*(local_size) + get_local_id(0)] = A[r_A*ncols_quarts_A  +  c_A];

	barrier(CLK_LOCAL_MEM_FENCE);
	
	const int4 w0 = (int4)(cache[0].s0, cache[1].s0, cache[2].s0, cache[3].s0);
	const int4 w1 = (int4)(cache[0].s1, cache[1].s1, cache[2].s1, cache[3].s1);
	const int4 w2 = (int4)(cache[0].s2, cache[1].s2, cache[2].s2, cache[3].s2);
	const int4 w3 = (int4)(cache[0].s3, cache[1].s3, cache[2].s3, cache[3].s3);

	if (get_global_id(0) < ncols_quarts_T && get_global_id(1) < nrows_quarts_T){
		T[(get_global_id(1)+0)*ncols_quarts_T + get_global_id(0) ] = (int4)(cache[0].s0, cache[1].s0, cache[2].s0, cache[3].s0);
		T[(get_global_id(1)+1)*ncols_quarts_T + get_global_id(0) ] = (int4)(cache[0].s1, cache[1].s1, cache[2].s1, cache[3].s1);
		T[(get_global_id(1)+2)*ncols_quarts_T + get_global_id(0) ] = (int4)(cache[0].s2, cache[1].s2, cache[2].s2, cache[3].s2);
		T[(get_global_id(1)+3)*ncols_quarts_T + get_global_id(0) ] = (int4)(cache[0].s3, cache[1].s3, cache[2].s3, cache[3].s3);
	
	}	
}

