kernel void matinit(global int *A, int nrows, int ncols)
{
	const int r = get_global_id(1);
	const int c = get_global_id(0);

	if (c >= ncols) return;

	A[r*ncols + c] = r - c;
}

kernel void imginit(write_only image2d_t I)
{
	const int r = get_global_id(1);
	const int c = get_global_id(0);

	const int2 dim = get_image_dim(I);

	if (c >= dim.x || r >= dim.y ) return;

	write_imagei(I, (int2)(c, r), (int4)(r - c, 0, 0, 0));
}


kernel void transpose_img(
	global int * restrict T,
	read_only image2d_t I)
{
	const int r_T = get_global_id(1);
	const int c_T = get_global_id(0);

	int ncols_T = get_image_height(I);
	int nrows_T = get_image_width(I);

	if (c_T >= ncols_T) return;
	if (r_T >= nrows_T) return;

	const int r_A = c_T;
	const int c_A = r_T;

	T[ r_T*ncols_T + c_T ] = read_imagei(I, (int2)(c_A, r_A)).x;
}


kernel void transpose_img_vect(
	global int4* restrict T,
	read_only image2d_t I)
{ 
	const int r_quart_T = get_global_id(1);
	const int c_quart_T = get_global_id(0);

	int ncols_T = get_image_height(I);
	int nrows_T = get_image_width(I);

	if (c_quart_T >= ncols_T/4) return;
	if (r_quart_T >= nrows_T/4) return;

	const int r_quart_A = c_quart_T;
	const int c_quart_A = r_quart_T;
	
	const int4 v0 = (int4)
		(read_imagei(I, (int2)(c_quart_A*4+0, r_quart_A*4+0)).x,
		read_imagei(I, (int2)(c_quart_A*4+1, r_quart_A*4+0)).x,
		read_imagei(I, (int2)(c_quart_A*4+2, r_quart_A*4+0)).x,
		read_imagei(I, (int2)(c_quart_A*4+3, r_quart_A*4+0)).x);
	const int4 v1 = (int4)
		(read_imagei(I, (int2)(c_quart_A*4+0, r_quart_A*4+1)).x,
		read_imagei(I, (int2)(c_quart_A*4+1, r_quart_A*4+1)).x,
		read_imagei(I, (int2)(c_quart_A*4+2, r_quart_A*4+1)).x,
		read_imagei(I, (int2)(c_quart_A*4+3, r_quart_A*4+1)).x);
	const int4 v2 = (int4)
		(read_imagei(I, (int2)(c_quart_A*4+0, r_quart_A*4+2)).x,
		read_imagei(I, (int2)(c_quart_A*4+1, r_quart_A*4+2)).x,
		read_imagei(I, (int2)(c_quart_A*4+2, r_quart_A*4+2)).x,
		read_imagei(I, (int2)(c_quart_A*4+3, r_quart_A*4+2)).x);
	const int4 v3 = (int4)
		(read_imagei(I, (int2)(c_quart_A*4+0, r_quart_A*4+3)).x,
		read_imagei(I, (int2)(c_quart_A*4+1, r_quart_A*4+3)).x,
		read_imagei(I, (int2)(c_quart_A*4+2, r_quart_A*4+3)).x,
		read_imagei(I, (int2)(c_quart_A*4+3, r_quart_A*4+3)).x);	
	
	const int4 w0 = (int4)(v0.s0, v1.s0, v2.s0, v3.s0);
	const int4 w1 = (int4)(v0.s1, v1.s1, v2.s1, v3.s1);
	const int4 w2 = (int4)(v0.s2, v1.s2, v2.s2, v3.s2);
	const int4 w3 = (int4)(v0.s3, v1.s3, v2.s3, v3.s3);


	T[ (4*r_quart_T+0)*(ncols_T/4) + c_quart_T ] =w0; 
	T[ (4*r_quart_T+1)*(ncols_T/4) + c_quart_T ] =w1; 
	T[ (4*r_quart_T+2)*(ncols_T/4) + c_quart_T ] =w2; 
	T[ (4*r_quart_T+3)*(ncols_T/4) + c_quart_T ] =w3; 
	
	
}


kernel void transpose_img_lmem(
	global int * restrict T,
	read_only image2d_t I,
	local int* restrict cache)
{

	int ncols_T = get_image_height(I);
	int nrows_T = get_image_width(I);

	const int local_size = get_local_size(0); // or get_local_size(1), which should be the same
	const int block_row_T = get_group_id(1);
	const int block_col_T = get_group_id(0);
	const int block_row_A = block_col_T;
	const int block_col_A = block_row_T;

	const int r_A = block_row_A*local_size + get_local_id(1);
	const int c_A = block_col_A*local_size + get_local_id(0);
	const int ncols_A = nrows_T;
	int effective_col = get_local_id(0) + get_local_id(1);
#if LWS_POW2
	effective_col &= local_size - 1;
#else
	if (effective_col > local_size)
		effective_col -= local_size;
#endif
	if (c_A < ncols_A && r_A < ncols_T)
		cache[get_local_id(1)*local_size + effective_col ] = read_imagei(I, (int2)(c_A, r_A)).x;

	barrier(CLK_LOCAL_MEM_FENCE);

	const int r_T = get_global_id(1); // get_group_id(1)*get_local_size(1)+get_local_id(1)
	const int c_T = get_global_id(0); // get_group_id(0)*get_local_size(0)+get_local_id(0)


	if (c_T >= ncols_T) return;
	if (r_T >= nrows_T) return;


	T[ r_T*ncols_T + c_T ] = cache[get_local_id(0)*local_size + effective_col];
}
