kernel void vecinit(global int * restrict arr, int nels){
	
	const int i= get_global_id(0);	
		
	if(i>=nels)return;
	
	arr[i]=nels-i;

}


// needed helper methods
inline void swap(uint *a, uint *b) {
        uint tmp;
        tmp = *b;
        *b = *a;
        *a = tmp;
}

// dir == 1 means ascending
inline void sort(uint *a, uint *b, char dir) {
        if ((*a > *b) == dir) swap(a, b);
}

inline void swapLocal(__local uint *a, __local uint *b) {
        uint tmp;
        tmp = *b;
        *b = *a;
        *a = tmp;
}

// dir == 1 means ascending
inline void sortLocal(__local uint *a, __local uint *b, char dir) {
        if ((*a > *b) == dir) swapLocal(a, b);
}

inline void Merge(global int* restrict arr,
	uint start, uint middle, uint end,
	local int * L,local int * R){
	    int i, j, k; 
	    int n1 = middle -start+ 1; 
	    int n2 = end - middle; 
	  
	    	    /* Copy data to temiddlep arrays L[] and R[] */
	    for(i = 0; i < n1; i++) 
		L[i] = arr[start+ i]; 
	    for(j = 0; j < n2; j++) 
		R[j] = arr[middle + 1+ j]; 
	  
	    /* Merge the temiddlep arrays back into arr[l..r]*/
	    i = 0; // Initiastartindex of first subarray 
	    j = 0; // Initiastartindex of second subarray 
	    k =start; // Initiastartindex of middleerged subarray 
	    while (i < n1 && j < n2) 
	    { 
		if (L[i] <= R[j]) 
		{ 
		    arr[k] = L[i]; 
		    i++; 
		} 
		else
		{ 
		    arr[k] = R[j]; 
		    j++; 
		} 
		k++; 
	    } 
	  
	    /* Copy the remaining elements of L[], if there 
	       are any */
	    while (i < n1) 
	    { 
		arr[k] = L[i]; 
		i++; 
		k++; 
	    } 
	  
	    /* Copy the remeaining elements of R[], if there 
	       are any */
	    while (j < n2) 
	    { 
		arr[k] = R[j]; 
		j++; 
		k++; 
	    } 
}

void merge(global int* ar1,global int* ar2, int m, int n) 
{ 
    // Iterate through all elements of ar2[] starting from 
    // the last element 
    for (int i=n-1; i>=0; i--) 
    { 
        /* Find the smallest element greater than ar2[i]. Move all 
           elements one position ahead till the smallest greater 
           element is not found */
        int j, last = ar1[m-1]; 
        for (j=m-2; j >= 0 && ar1[j] > ar2[i]; j--) 
            ar1[j+1] = ar1[j]; 
  
        // If there was a greater element 
        if (j != m-2 || last > ar2[i]) 
        { 
            ar1[j+1] = ar2[i]; 
            ar2[i] = last; 
        } 
    } 
} 

inline void printarr(global int* arr,int nels){
		for(int i =0;i < nels;i++){
			printf("%i ",arr[i]);
			}
		printf("\n");

}

//inizialmente abbiamo meta dei workitem attivi, quindi gws = nels/2
kernel void mergesortnaive(global int * restrict arr,int nels){
	unsigned actives = nels >> 1;  //gli attivi sono inizialmente metÃ  dei workitem
	uint gi=get_global_id(0);
	if(gi>=nels)return;
	uint initial_el = gi << 1;
	uint offset = 1;
	/* create temp arrays , no dynamic dimensions because not supported by opencl
	* local arrays cannot be created in nonkernel function
	*/
	//    local int L[512], R[512]; 
	  
	if(gi==0){printf("global_size e local_size %i  %i\n",get_global_size(0),get_local_size(0));}

	for(int i=1;i<nels;i<<=1){
		uint active_mask = i-1;
		offset <<= 1;
		//printf("maschera e offset %i  %i \n ",active_mask,offset);
		if((gi & active_mask))return;   //se sei un work_item non attivo ritorna
		//printf("sono il workitem numero %i ",gi);
		merge(arr + initial_el,arr + initial_el + (offset >> 1) , (offset >> 1), (offset >> 1) );
		//Merge(arr, initial_el, initial_el + (offset >> 1) ,initial_el + offset,L,R);
	}

}

kernel void ParallelMerge_Local(global const int * in,global int * out,__local int * aux)
{
  int i = get_local_id(0);
  int wg = get_local_size(0);

  // Move IN, OUT to block start
  int offset = get_group_id(0) * wg;
  in += offset; out += offset;

  //loading in local memory
  aux[i] = in[i];
  barrier(CLK_LOCAL_MEM_FENCE); // make sure AUX is entirely up to date

  // Now we will merge sub-sequences of length 1,2,...,WG/2
  for (int length=1;length<wg;length<<=1)
  {
    int iData = aux[i];
    uint confront1 = iData;
    int ii = i & (length-1);  // index in our sequence in 0..length-1
    int sibling = (i - ii) ^ length; // beginning of the sibling sequence
    int pos = 0;
    for (int inc=length;inc>0;inc>>=1) // increment for dichotomic search
    {
      int j = sibling+pos+inc-1;
      uint confront2 = aux[j];
      bool smaller = (confront2 < confront1) || ( confront2 == confront1 && j < i );
      pos += (smaller)?inc:0;
      pos = min(pos,length);
    }
    int bits = 2*length-1; // mask for destination
    int dest = ((ii + pos) & bits) | (i & ~bits); // destination index in merged sequence
    barrier(CLK_LOCAL_MEM_FENCE);
    aux[dest] = iData;
    barrier(CLK_LOCAL_MEM_FENCE);
  }

  // Write output
  out[i] = aux[i];
}

kernel void miosort(global int * restrict arr,int nels){
	int gi=get_global_id(0);
	
	if(gi>=nels/2)return;
	for(int i=0;i<nels/2;i++){
		int indexin=( (gi<<1) >= nels-1 ? 0 : gi<<1) ;
		int indexfin=(indexin+1 >= nels ? indexin : indexin+1);
			if(arr[indexin]>arr[indexfin]){
			int tmp = arr[indexfin];
			arr[indexfin]=arr[indexin];
			arr[indexin]=tmp;
		}
		int indexpast=indexin;
		indexin=(indexin+1>=nels ? 0 : indexin+1);
		indexfin=(indexpast+2 >= nels ? nels-1 : indexpast+2);
		barrier(CLK_GLOBAL_MEM_FENCE);
		if(arr[indexin]>arr[indexfin]){
			int tmp = arr[indexfin];
			arr[indexfin]=arr[indexin];
			arr[indexin]=tmp;
		}
		barrier(CLK_GLOBAL_MEM_FENCE);

	}

}

kernel void miosort_sliding(global int * restrict arr,const int nels){
	int gi=get_global_id(0);
	int lws = get_local_size(0);
	int gws = (nels+1)>>1;
	if(gi>=gws)return;
	int shift = lws << 1;
	for(int i=0;i<nels >> 1;i++){
		for(int sliding_off=0;sliding_off<nels;sliding_off += shift){
			int iniziamo = (((gi << 1) + 1 + sliding_off) >= nels);
			//printf("iniziamo di %i e\' %i\n", gi, iniziamo);  
			int indexin = ( iniziamo ? 0 : ((gi << 1) + sliding_off)) ;
			int indexfin= ( iniziamo  >= nels ? nels-1 : indexin+1);
			//if(gi <=8){printf("indexin %i e indexfin %i del %i workitem\n",indexin,indexfin,gi);}
			if(arr[indexin]>arr[indexfin]){
				int tmp = arr[indexfin];
				arr[indexfin]=arr[indexin];
				arr[indexin]=tmp;
			}
		}
		for(int sliding_off=0;sliding_off<nels;sliding_off += shift){
			int iniziamo = (((gi << 1) + 1 + sliding_off) >= nels);
			int indexin = ( iniziamo ? 0 : ((gi << 1) + sliding_off)) ;
			int indexfin= ( iniziamo  >= nels ? nels-1 : indexin+1);
			int indexpast=indexin;
			indexin=(indexin+2>=nels ? 0 : indexin+1);
			indexfin=(indexpast+2 >= nels ? nels-1 : indexpast+2);
			barrier(CLK_GLOBAL_MEM_FENCE);
			if(arr[indexin]>arr[indexfin]){
				int tmp = arr[indexfin];
				arr[indexfin]=arr[indexin];
				arr[indexin]=tmp;
			}
			barrier(CLK_GLOBAL_MEM_FENCE);
		}
	}

}

//TODO alcuni workitem dello stesso workgroup vengono bloccati nella barriera e bloccano tutti i workitem 
//nello stesso workgroup, bisognerebbe fare entrare tutti i workitem nello stesso workgroup
kernel void local_miosort(global int * restrict arr,int nels, local int* lmem){
	const int gi=get_global_id(0);
	if(gi>=(nels+1)/2)return;
	const uint lws=get_local_size(0);
	const uint groupid=get_group_id(0);
	const uint start=(get_group_id(0)*lws)<<1;
	const uint end=(start+(lws<<1)>nels ? nels : start+(lws<<1));
	const int li=get_local_id(0);
	//if(li==0)printf("block_id %i local_item %i start %i end %i\n",groupid,li,start,end);
	for(int i=0;i<lws;i++){
		int indexin=( (gi<<1) + 1 >= end ? start : gi<<1) ;
		int indexfin=(indexin + 1 >= end ? end-1 : indexin+1);
		//printf("indexin %i e indexfin %i del workitem %i\n",indexin,indexfin,gi);
		if(arr[indexin]>arr[indexfin]){
			int tmp = arr[indexfin];
			arr[indexfin]=arr[indexin];
			arr[indexin]=tmp;
		}
		int indexpast=indexin;
		indexin=(indexin+2>=end ? start : indexin+1);
		indexfin=(indexpast+2 >= end ? end-1 : indexpast+2);
		//printf("22indexin %i e indexfin %i del workitem %i\n",indexin,indexfin,gi);
		barrier(CLK_GLOBAL_MEM_FENCE);
		if(arr[indexin]>arr[indexfin]){
			int tmp = arr[indexfin];
			arr[indexfin]=arr[indexin];
			arr[indexin]=tmp;
		}
		barrier(CLK_GLOBAL_MEM_FENCE);

	}
	//if(gi==0)printarr(arr,nels);

}

kernel void local_miosort_lmem(global int * restrict arr,int nels, local int* lmem){
	const int gi=get_global_id(0);
	const uint lws=get_local_size(0);
	if(gi>=(nels+(lws>>1))/2)return;
	const uint groupid=get_group_id(0);
	const uint start=get_group_id(0)*(lws<<1);
	const uint end=(start+(lws<<1)>nels ? nels : start+(lws<<1));
	const uint el_lws = end-start ;
	const int li=get_local_id(0);
	const uint arr_local_index = li << 1;
	const uint arr_global_index = gi << 1;
	lmem[arr_local_index]=arr[arr_global_index];
	lmem[(arr_local_index)+1]=arr[(arr_global_index)+1];
	barrier(CLK_LOCAL_MEM_FENCE);
	//if(li==0)printf("block_id %i local_item %i start %i end %i\n",groupid,li,start,end);
//#pragma unroll
	for(int i=0;i<lws;i++){
		int indexin=( (arr_local_index)+1 >= el_lws ? 0 : arr_local_index) ;
		int indexfin=indexin+1;
		//printf("local indexin %i e local indexfin %i del workitem %i\n",indexin,indexfin,gi);
		if(lmem[indexin]>lmem[indexfin]){
			int tmp = lmem[indexfin];
			lmem[indexfin]=lmem[indexin];
			lmem[indexin]=tmp;
		}
		indexin=(indexin+2>=el_lws ? 0 : indexin+1);
		indexfin=indexin+1;
		//printf("2local indexin %i e local indexfin %i del workitem %i\n",indexin,indexfin,gi);
		barrier(CLK_LOCAL_MEM_FENCE);
		if(lmem[indexin]>lmem[indexfin]){
			int tmp = lmem[indexfin];
			lmem[indexfin]=lmem[indexin];
			lmem[indexin]=tmp;
		}
		barrier(CLK_LOCAL_MEM_FENCE);

	}
	arr[arr_global_index]=lmem[arr_local_index];
	arr[(arr_global_index)+1]=lmem[(arr_local_index)+1];
}


kernel void local_count_sort(global int * restrict arr,int nels,local int * lmem){
	const int gi= get_global_id(0);
	if(gi>=nels)return;
	int pivot = arr[gi];
	const int li=get_local_id(0);
	const int lws=get_local_size(0);
	const int groupid = get_group_id(0);
	const int first_el = groupid*lws;
	int counter=0,repetition=0;
	for(int i=first_el;i<(first_el + lws); i++){
		if(arr[i] == pivot){repetition++;}
		else if(arr[i] < pivot){counter++;}
	}
	barrier(CLK_LOCAL_MEM_FENCE);
	for(int i = 0; i < repetition; i++){
		arr[first_el+counter+i]=pivot;	
	}
	//if(gi==0)printarr(arr,nels);
}

kernel void local_count_sort_lmem(global int * restrict arr,int nels,local int * lmem){
	const int gi= get_global_id(0);
	if(gi>=nels)return;
	int pivot = arr[gi];
	const int li=get_local_id(0);
	lmem[li]=pivot;
	const int lws=get_local_size(0);
	const int groupid = get_group_id(0);
	const int first_el = groupid*lws;
	int counter=0,repetition=0;
	barrier(CLK_LOCAL_MEM_FENCE);
	for(int i=0;i<lws; i++){
		if(lmem[i] == pivot){repetition++;}
		else if(lmem[i] < pivot){counter++;}
	}
	barrier(CLK_LOCAL_MEM_FENCE);
	for(int i = 0; i < repetition; i++){
		arr[first_el+counter+i]=pivot;	
	}
	//if(gi==0)printarr(arr,nels);
}

int4 __OVERLOADABLE__  isless(int4 first,int4 second){
	int4 res;
	res.s0 = (first.s0 < second.s0 ? 1 : 0); 
	res.s1 = (first.s1 < second.s1 ? 1 : 0); 
	res.s2 = (first.s2 < second.s2 ? 1 : 0); 
	res.s3 = (first.s3 < second.s3 ? 1 : 0); 
	return res;
}

int4 __OVERLOADABLE__ isequal(int4 first,int4 second){
	int4 res;
	res.s0 = (first.s0 == second.s0 ? 1 : 0); 
	res.s1 = (first.s1 == second.s1 ? 1 : 0); 
	res.s2 = (first.s2 == second.s2 ? 1 : 0); 
	res.s3 = (first.s3 == second.s3 ? 1 : 0); 
	return res;
}

kernel void local_count_sort_vect(global int4 * restrict arr,int nels, global int* restrict res,local int4 * lmem){
	const int gi= get_global_id(0);
	const int nquarts=nels/4;
	if(gi>=nquarts)return;
	int pivot = arr[gi].s0;
	int4 vecpivot= (int4)(pivot);
	const int li=get_local_id(0);
	const int lws=get_local_size(0);
	const int groupid = get_group_id(0);
	const int first_quart = groupid*lws;
	int counter=0,repetition=0;
	int4 counter4 = (int4)(0),repetition4 = (int4)(0);
	for(int i=first_quart;i<(first_quart + lws); i++){
		repetition4 += isequal(arr[i],pivot);
		counter4 += isless(arr[i], pivot);
	}
	barrier(CLK_LOCAL_MEM_FENCE);
	repetition=repetition4.s0+repetition4.s1+repetition4.s2+repetition4.s3; 
	counter=counter4.s0+counter4.s1+counter4.s2+counter4.s3; 
	for(int i = 0; i < repetition; i++){
		res[ (first_quart*4) + counter + i]=pivot;	
	}
	if(gi==0)printarr(arr,nels);
}
